; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal_rcc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal_rcc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal_rcc.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1680     */
;;;1681   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1682   {
;;;1683     /* NOTE : This function should not be modified, when the callback is needed,
;;;1684               the HAL_RCC_CSSCallback should be implemented in the user file
;;;1685      */
;;;1686   }
;;;1687   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;1045     */
;;;1046   HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1047   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d05e              BEQ      |L2.200|
;;;1048     uint32_t tickstart;
;;;1049   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1050     uint32_t hpre = RCC_SYSCLK_DIV1;
;;;1051   #endif
;;;1052     HAL_StatusTypeDef status;
;;;1053   
;;;1054     /* Check Null pointer */
;;;1055     if(RCC_ClkInitStruct == NULL)
;;;1056     {
;;;1057       return HAL_ERROR;
;;;1058     }
;;;1059   
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;1062     assert_param(IS_FLASH_LATENCY(FLatency));
;;;1063   
;;;1064     /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;1065       must be correctly programmed according to the frequency of the CPU clock
;;;1066       (HCLK) and the supply voltage of the device. */
;;;1067   
;;;1068     /* Increasing the number of wait states because of higher CPU frequency */
;;;1069     if(FLatency > __HAL_FLASH_GET_LATENCY())
00000a  f8df8108          LDR      r8,|L2.276|
00000e  f8d80000          LDR      r0,[r8,#0]
000012  f0000007          AND      r0,r0,#7
000016  42a8              CMP      r0,r5
000018  d20c              BCS      |L2.52|
;;;1070     {
;;;1071       /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;1072       __HAL_FLASH_SET_LATENCY(FLatency);
00001a  f8d81000          LDR      r1,[r8,#0]
00001e  f0210107          BIC      r1,r1,#7
000022  4329              ORRS     r1,r1,r5
000024  f8c81000          STR      r1,[r8,#0]
;;;1073   
;;;1074       /* Check that the new number of wait states is taken into account to access the Flash
;;;1075       memory by reading the FLASH_ACR register */
;;;1076       if(__HAL_FLASH_GET_LATENCY() != FLatency)
000028  f8d80000          LDR      r0,[r8,#0]
00002c  f0000007          AND      r0,r0,#7
000030  42a8              CMP      r0,r5
000032  d149              BNE      |L2.200|
                  |L2.52|
;;;1077       {
;;;1078         return HAL_ERROR;
;;;1079       }
;;;1080     }
;;;1081   
;;;1082     /*------------------------- SYSCLK Configuration ---------------------------*/
;;;1083     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000034  7820              LDRB     r0,[r4,#0]
;;;1084     {
;;;1085       assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;1086   
;;;1087       /* PLL is selected as System Clock Source */
;;;1088       if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;1089       {
;;;1090         /* Check the PLL ready flag */
;;;1091         if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
000036  4e38              LDR      r6,|L2.280|
000038  07c0              LSLS     r0,r0,#31             ;1083
00003a  d02b              BEQ      |L2.148|
00003c  6860              LDR      r0,[r4,#4]            ;1088
00003e  2803              CMP      r0,#3                 ;1088
000040  d011              BEQ      |L2.102|
;;;1092         {
;;;1093           return HAL_ERROR;
;;;1094         }
;;;1095   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1096         /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
;;;1097         /* Compute target PLL output frequency */
;;;1098         if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
;;;1099         {
;;;1100           if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
;;;1101           {
;;;1102             /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
;;;1103             MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
;;;1104             hpre = RCC_SYSCLK_DIV2;
;;;1105           }
;;;1106           else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
;;;1107           {
;;;1108             /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
;;;1109             MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
;;;1110             hpre = RCC_SYSCLK_DIV2;
;;;1111           }
;;;1112           else
;;;1113           {
;;;1114             /* nothing to do */
;;;1115           }
;;;1116         }
;;;1117   #endif
;;;1118       }
;;;1119       else
;;;1120       {
;;;1121         /* HSE is selected as System Clock Source */
;;;1122         if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000042  2802              CMP      r0,#2
000044  d012              BEQ      |L2.108|
;;;1123         {
;;;1124           /* Check the HSE ready flag */
;;;1125           if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
;;;1126           {
;;;1127             return HAL_ERROR;
;;;1128           }
;;;1129         }
;;;1130         /* MSI is selected as System Clock Source */
;;;1131         else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
;;;1132         {
;;;1133           /* Check the MSI ready flag */
;;;1134           if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
;;;1135           {
;;;1136             return HAL_ERROR;
;;;1137           }
;;;1138         }
;;;1139         /* HSI is selected as System Clock Source */
;;;1140         else
;;;1141         {
;;;1142           /* Check the HSI ready flag */
;;;1143           if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
000046  6831              LDR      r1,[r6,#0]
000048  b198              CBZ      r0,|L2.114|
00004a  0549              LSLS     r1,r1,#21
                  |L2.76|
00004c  2900              CMP      r1,#0
00004e  da3b              BGE      |L2.200|
;;;1144           {
;;;1145             return HAL_ERROR;
;;;1146           }
;;;1147         }
;;;1148   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1149         /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
;;;1150         if(HAL_RCC_GetSysClockFreq() > 80000000U)
;;;1151         {
;;;1152           /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
;;;1153           MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
;;;1154           hpre = RCC_SYSCLK_DIV2;
;;;1155         }
;;;1156   #endif
;;;1157   
;;;1158       }
;;;1159   
;;;1160       MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
000050  68b1              LDR      r1,[r6,#8]
000052  f0210103          BIC      r1,r1,#3
000056  4301              ORRS     r1,r1,r0
000058  60b1              STR      r1,[r6,#8]
;;;1161   
;;;1162       /* Get Start Tick*/
;;;1163       tickstart = HAL_GetTick();
00005a  f7fffffe          BL       HAL_GetTick
00005e  4607              MOV      r7,r0
;;;1164   
;;;1165       while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
;;;1166       {
;;;1167         if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
000060  f2413988          MOV      r9,#0x1388
000064  e00f              B        |L2.134|
                  |L2.102|
000066  6831              LDR      r1,[r6,#0]            ;1091
000068  0189              LSLS     r1,r1,#6              ;1091
00006a  e7ef              B        |L2.76|
                  |L2.108|
00006c  6831              LDR      r1,[r6,#0]            ;1125
00006e  0389              LSLS     r1,r1,#14             ;1125
000070  e7ec              B        |L2.76|
                  |L2.114|
000072  0789              LSLS     r1,r1,#30             ;1134
000074  e7ea              B        |L2.76|
                  |L2.118|
000076  f7fffffe          BL       HAL_GetTick
00007a  1bc1              SUBS     r1,r0,r7
00007c  4549              CMP      r1,r9
00007e  d902              BLS      |L2.134|
;;;1168         {
;;;1169           return HAL_TIMEOUT;
000080  2003              MOVS     r0,#3
                  |L2.130|
;;;1170         }
;;;1171       }
;;;1172     }
;;;1173   
;;;1174     /*-------------------------- HCLK Configuration --------------------------*/
;;;1175     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
;;;1176     {
;;;1177       assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;1178       MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
;;;1179     }
;;;1180   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1181     else
;;;1182     {
;;;1183       /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
;;;1184       if(hpre == RCC_SYSCLK_DIV2)
;;;1185       {
;;;1186         MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
;;;1187       }
;;;1188     }
;;;1189   #endif
;;;1190   
;;;1191     /* Decreasing the number of wait states because of lower CPU frequency */
;;;1192     if(FLatency < __HAL_FLASH_GET_LATENCY())
;;;1193     {
;;;1194       /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;1195       __HAL_FLASH_SET_LATENCY(FLatency);
;;;1196   
;;;1197       /* Check that the new number of wait states is taken into account to access the Flash
;;;1198       memory by reading the FLASH_ACR register */
;;;1199       if(__HAL_FLASH_GET_LATENCY() != FLatency)
;;;1200       {
;;;1201         return HAL_ERROR;
;;;1202       }
;;;1203     }
;;;1204   
;;;1205     /*-------------------------- PCLK1 Configuration ---------------------------*/
;;;1206     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;1207     {
;;;1208       assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;1209       MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;1210     }
;;;1211   
;;;1212     /*-------------------------- PCLK2 Configuration ---------------------------*/
;;;1213     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;1214     {
;;;1215       assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;1216       MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
;;;1217     }
;;;1218   
;;;1219     /* Update the SystemCoreClock global variable */
;;;1220     SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
;;;1221   
;;;1222     /* Configure the source of time base considering new system clocks settings*/
;;;1223     status = HAL_InitTick (TICK_INT_PRIORITY);
;;;1224   
;;;1225     return status;
;;;1226   }
000082  e8bd87f0          POP      {r4-r10,pc}
                  |L2.134|
000086  68b0              LDR      r0,[r6,#8]            ;1165
000088  6861              LDR      r1,[r4,#4]            ;1165
00008a  f000000c          AND      r0,r0,#0xc            ;1165
00008e  ebb00f81          CMP      r0,r1,LSL #2          ;1165
000092  d1f0              BNE      |L2.118|
                  |L2.148|
000094  7820              LDRB     r0,[r4,#0]            ;1175
000096  0780              LSLS     r0,r0,#30             ;1175
000098  d505              BPL      |L2.166|
00009a  68b0              LDR      r0,[r6,#8]            ;1178
00009c  68a1              LDR      r1,[r4,#8]            ;1178
00009e  f02000f0          BIC      r0,r0,#0xf0           ;1178
0000a2  4308              ORRS     r0,r0,r1              ;1178
0000a4  60b0              STR      r0,[r6,#8]            ;1178
                  |L2.166|
0000a6  f8d81000          LDR      r1,[r8,#0]            ;1192
0000aa  4640              MOV      r0,r8                 ;1192
0000ac  f0010107          AND      r1,r1,#7              ;1192
0000b0  42a9              CMP      r1,r5                 ;1192
0000b2  d90b              BLS      |L2.204|
0000b4  6801              LDR      r1,[r0,#0]            ;1195
0000b6  f0210107          BIC      r1,r1,#7              ;1195
0000ba  4329              ORRS     r1,r1,r5              ;1195
0000bc  6001              STR      r1,[r0,#0]            ;1195
0000be  6800              LDR      r0,[r0,#0]            ;1199
0000c0  f0000007          AND      r0,r0,#7              ;1199
0000c4  42a8              CMP      r0,r5                 ;1199
0000c6  d001              BEQ      |L2.204|
                  |L2.200|
0000c8  2001              MOVS     r0,#1                 ;1201
0000ca  e7da              B        |L2.130|
                  |L2.204|
0000cc  7820              LDRB     r0,[r4,#0]            ;1206
0000ce  0740              LSLS     r0,r0,#29             ;1206
0000d0  d505              BPL      |L2.222|
0000d2  68b0              LDR      r0,[r6,#8]            ;1209
0000d4  68e1              LDR      r1,[r4,#0xc]          ;1209
0000d6  f42060e0          BIC      r0,r0,#0x700          ;1209
0000da  4308              ORRS     r0,r0,r1              ;1209
0000dc  60b0              STR      r0,[r6,#8]            ;1209
                  |L2.222|
0000de  7820              LDRB     r0,[r4,#0]            ;1213
0000e0  0700              LSLS     r0,r0,#28             ;1213
0000e2  d506              BPL      |L2.242|
0000e4  68b0              LDR      r0,[r6,#8]            ;1216
0000e6  6921              LDR      r1,[r4,#0x10]         ;1216
0000e8  f4205060          BIC      r0,r0,#0x3800         ;1216
0000ec  ea4000c1          ORR      r0,r0,r1,LSL #3       ;1216
0000f0  60b0              STR      r0,[r6,#8]            ;1216
                  |L2.242|
0000f2  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0000f6  68b1              LDR      r1,[r6,#8]            ;1220
0000f8  4a08              LDR      r2,|L2.284|
0000fa  f3c11103          UBFX     r1,r1,#4,#4           ;1220
0000fe  5c51              LDRB     r1,[r2,r1]            ;1220
000100  f001011f          AND      r1,r1,#0x1f           ;1220
000104  40c8              LSRS     r0,r0,r1              ;1220
000106  4906              LDR      r1,|L2.288|
000108  6008              STR      r0,[r1,#0]            ;1223  ; SystemCoreClock
00010a  e8bd47f0          POP      {r4-r10,lr}           ;1223
00010e  2000              MOVS     r0,#0                 ;1223
000110  f7ffbffe          B.W      HAL_InitTick
;;;1227   
                          ENDP

                  |L2.276|
                          DCD      0x40022000
                  |L2.280|
                          DCD      0x40021000
                  |L2.284|
                          DCD      AHBPrescTable
                  |L2.288|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;279      */
;;;280    HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;281    {
;;;282      uint32_t tickstart;
;;;283    
;;;284      /* Set MSION bit */
;;;285      SET_BIT(RCC->CR, RCC_CR_MSION);
000004  4c31              LDR      r4,|L3.204|
000006  6820              LDR      r0,[r4,#0]
000008  f0400001          ORR      r0,r0,#1
00000c  6020              STR      r0,[r4,#0]
;;;286    
;;;287      /* Insure MSIRDY bit is set before writing default MSIRANGE value */
;;;288      /* Get start tick */
;;;289      tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;290    
;;;291      /* Wait till MSI is ready */
;;;292      while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
000014  e004              B        |L3.32|
                  |L3.22|
;;;293      {
;;;294        if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b40              SUBS     r0,r0,r5
00001c  2802              CMP      r0,#2
00001e  d830              BHI      |L3.130|
                  |L3.32|
000020  6820              LDR      r0,[r4,#0]            ;292
000022  0780              LSLS     r0,r0,#30             ;292
000024  d5f7              BPL      |L3.22|
;;;295        {
;;;296          return HAL_TIMEOUT;
;;;297        }
;;;298      }
;;;299    
;;;300      /* Set MSIRANGE default value */
;;;301      MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
000026  6820              LDR      r0,[r4,#0]
000028  f02000f0          BIC      r0,r0,#0xf0
00002c  f0400060          ORR      r0,r0,#0x60
000030  6020              STR      r0,[r4,#0]
;;;302    
;;;303      /* Reset CFGR register (MSI is selected as system clock source) */
;;;304      CLEAR_REG(RCC->CFGR);
000032  2600              MOVS     r6,#0
000034  60a6              STR      r6,[r4,#8]
;;;305    
;;;306      /* Update the SystemCoreClock global variable for MSI as system clock source */
;;;307      SystemCoreClock = MSI_VALUE;
000036  4927              LDR      r1,|L3.212|
000038  4825              LDR      r0,|L3.208|
;;;308    
;;;309      /* Configure the source of time base considering new system clock settings  */
;;;310      if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
00003a  6008              STR      r0,[r1,#0]  ; SystemCoreClock
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       HAL_InitTick
000042  b110              CBZ      r0,|L3.74|
;;;311      {
;;;312        return HAL_ERROR;
000044  2001              MOVS     r0,#1
                  |L3.70|
;;;313      }
;;;314    
;;;315      /* Insure MSI selected as system clock source */
;;;316      /* Get start tick */
;;;317      tickstart = HAL_GetTick();
;;;318    
;;;319      /* Wait till system clock source is ready */
;;;320      while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
;;;321      {
;;;322        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;323        {
;;;324          return HAL_TIMEOUT;
;;;325        }
;;;326      }
;;;327    
;;;328      /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
;;;329    #if defined(RCC_PLLSAI2_SUPPORT)
;;;330    
;;;331      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
;;;332    
;;;333    #elif defined(RCC_PLLSAI1_SUPPORT)
;;;334    
;;;335      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON);
;;;336    
;;;337    #else
;;;338    
;;;339      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON);
;;;340    
;;;341    #endif /* RCC_PLLSAI2_SUPPORT */
;;;342    
;;;343      /* Insure PLLRDY, PLLSAI1RDY and PLLSAI2RDY (if present) are reset */
;;;344      /* Get start tick */
;;;345      tickstart = HAL_GetTick();
;;;346    
;;;347    #if defined(RCC_PLLSAI2_SUPPORT)
;;;348    
;;;349      while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY) != 0U)
;;;350    
;;;351    #elif defined(RCC_PLLSAI1_SUPPORT)
;;;352    
;;;353      while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY) != 0U)
;;;354    
;;;355    #else
;;;356    
;;;357      while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
;;;358    
;;;359    #endif
;;;360      {
;;;361        if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;362        {
;;;363          return HAL_TIMEOUT;
;;;364        }
;;;365      }
;;;366    
;;;367      /* Reset PLLCFGR register */
;;;368      CLEAR_REG(RCC->PLLCFGR);
;;;369      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
;;;370    
;;;371    #if defined(RCC_PLLSAI1_SUPPORT)
;;;372    
;;;373      /* Reset PLLSAI1CFGR register */
;;;374      CLEAR_REG(RCC->PLLSAI1CFGR);
;;;375      SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
;;;376    
;;;377    #endif /* RCC_PLLSAI1_SUPPORT */
;;;378    
;;;379    #if defined(RCC_PLLSAI2_SUPPORT)
;;;380    
;;;381      /* Reset PLLSAI2CFGR register */
;;;382      CLEAR_REG(RCC->PLLSAI2CFGR);
;;;383      SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
;;;384    
;;;385    #endif /* RCC_PLLSAI2_SUPPORT */
;;;386    
;;;387      /* Reset HSEBYP bit */
;;;388      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
;;;389    
;;;390      /* Disable all interrupts */
;;;391      CLEAR_REG(RCC->CIER);
;;;392    
;;;393      /* Clear all interrupt flags */
;;;394      WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
;;;395    
;;;396      /* Clear all reset flags */
;;;397      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;398    
;;;399      return HAL_OK;
;;;400    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L3.74|
00004a  f7fffffe          BL       HAL_GetTick
00004e  4605              MOV      r5,r0                 ;317
000050  f2413788          MOV      r7,#0x1388            ;322
000054  e004              B        |L3.96|
                  |L3.86|
000056  f7fffffe          BL       HAL_GetTick
00005a  1b40              SUBS     r0,r0,r5              ;322
00005c  42b8              CMP      r0,r7                 ;322
00005e  d810              BHI      |L3.130|
                  |L3.96|
000060  68a0              LDR      r0,[r4,#8]            ;320
000062  f0100f0c          TST      r0,#0xc               ;320
000066  d1f6              BNE      |L3.86|
000068  6820              LDR      r0,[r4,#0]            ;331
00006a  491b              LDR      r1,|L3.216|
00006c  4008              ANDS     r0,r0,r1              ;331
00006e  6020              STR      r0,[r4,#0]            ;331
000070  f7fffffe          BL       HAL_GetTick
000074  4605              MOV      r5,r0                 ;345
000076  e006              B        |L3.134|
                  |L3.120|
000078  f7fffffe          BL       HAL_GetTick
00007c  1b40              SUBS     r0,r0,r5              ;361
00007e  2802              CMP      r0,#2                 ;361
000080  d901              BLS      |L3.134|
                  |L3.130|
000082  2003              MOVS     r0,#3                 ;363
000084  e7df              B        |L3.70|
                  |L3.134|
000086  6820              LDR      r0,[r4,#0]            ;349
000088  f0105f28          TST      r0,#0x2a000000        ;349
00008c  d1f4              BNE      |L3.120|
00008e  60e6              STR      r6,[r4,#0xc]          ;368
000090  68e0              LDR      r0,[r4,#0xc]          ;369
000092  f4405080          ORR      r0,r0,#0x1000         ;369
000096  60e0              STR      r0,[r4,#0xc]          ;369
000098  6126              STR      r6,[r4,#0x10]         ;374
00009a  6920              LDR      r0,[r4,#0x10]         ;375
00009c  f4405080          ORR      r0,r0,#0x1000         ;375
0000a0  6120              STR      r0,[r4,#0x10]         ;375
0000a2  6166              STR      r6,[r4,#0x14]         ;382
0000a4  6960              LDR      r0,[r4,#0x14]         ;383
0000a6  f4405080          ORR      r0,r0,#0x1000         ;383
0000aa  6160              STR      r0,[r4,#0x14]         ;383
0000ac  6820              LDR      r0,[r4,#0]            ;388
0000ae  f4202080          BIC      r0,r0,#0x40000        ;388
0000b2  6020              STR      r0,[r4,#0]            ;388
0000b4  61a6              STR      r6,[r4,#0x18]         ;391
0000b6  f04f30ff          MOV      r0,#0xffffffff        ;394
0000ba  6220              STR      r0,[r4,#0x20]         ;394
0000bc  f8d40094          LDR      r0,[r4,#0x94]         ;397
0000c0  f4400000          ORR      r0,r0,#0x800000       ;397
0000c4  f8c40094          STR      r0,[r4,#0x94]         ;397
0000c8  2000              MOVS     r0,#0                 ;399
0000ca  e7bc              B        |L3.70|
;;;401    
                          ENDP

                  |L3.204|
                          DCD      0x40021000
                  |L3.208|
                          DCD      0x003d0900
                  |L3.212|
                          DCD      SystemCoreClock
                  |L3.216|
                          DCD      0xeafef4ff

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;1653     */
;;;1654   void HAL_RCC_EnableCSS(void)
000000  4802              LDR      r0,|L4.12|
;;;1655   {
;;;1656     SET_BIT(RCC->CR, RCC_CR_CSSON) ;
000002  6801              LDR      r1,[r0,#0]
000004  f4412100          ORR      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;1657   }
00000a  4770              BX       lr
;;;1658   
                          ENDP

                  |L4.12|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1618     */
;;;1619   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1620   {
;;;1621     /* Check the parameters */
;;;1622     assert_param(RCC_ClkInitStruct != (void  *)NULL);
;;;1623     assert_param(pFLatency != (void *)NULL);
;;;1624   
;;;1625     /* Set all possible values for the Clock type parameter --------------------*/
;;;1626     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1627   
;;;1628     /* Get the SYSCLK configuration --------------------------------------------*/
;;;1629     RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L5.56|
000006  6893              LDR      r3,[r2,#8]
000008  f0030303          AND      r3,r3,#3
;;;1630   
;;;1631     /* Get the HCLK configuration ----------------------------------------------*/
;;;1632     RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
00000c  6043              STR      r3,[r0,#4]
00000e  6893              LDR      r3,[r2,#8]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1633   
;;;1634     /* Get the APB1 configuration ----------------------------------------------*/
;;;1635     RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
000014  6083              STR      r3,[r0,#8]
000016  6893              LDR      r3,[r2,#8]
000018  f40363e0          AND      r3,r3,#0x700
;;;1636   
;;;1637     /* Get the APB2 configuration ----------------------------------------------*/
;;;1638     RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6892              LDR      r2,[r2,#8]
;;;1639   
;;;1640     /* Get the Flash Wait State (Latency) configuration ------------------------*/
;;;1641     *pFLatency = __HAL_FLASH_GET_LATENCY();
;;;1642   }
000020  f44f63e0          MOV      r3,#0x700
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1641
00002a  4804              LDR      r0,|L5.60|
00002c  6800              LDR      r0,[r0,#0]            ;1641
00002e  f0000007          AND      r0,r0,#7              ;1641
000032  6008              STR      r0,[r1,#0]            ;1641
000034  4770              BX       lr
;;;1643   
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40021000
                  |L5.60|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1423     */
;;;1424   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L6.8|
;;;1425   {
;;;1426     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1427   }
000004  4770              BX       lr
;;;1428   
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1459     */
;;;1460   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b510              PUSH     {r4,lr}
;;;1461   {
;;;1462     /* Check the parameters */
;;;1463     assert_param(RCC_OscInitStruct != (void *)NULL);
;;;1464   
;;;1465     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1466   #if defined(RCC_HSI48_SUPPORT)
;;;1467     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
;;;1468                                         RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSI48;
;;;1469   #else
;;;1470     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
000002  211f              MOVS     r1,#0x1f
;;;1471                                         RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1472   #endif /* RCC_HSI48_SUPPORT */
;;;1473   
;;;1474     /* Get the HSE configuration -----------------------------------------------*/
;;;1475     if(READ_BIT(RCC->CR, RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000004  6001              STR      r1,[r0,#0]
000006  4935              LDR      r1,|L7.220|
000008  680a              LDR      r2,[r1,#0]
00000a  0353              LSLS     r3,r2,#13
00000c  f04f0200          MOV      r2,#0
000010  d502              BPL      |L7.24|
;;;1476     {
;;;1477       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  f44f23a0          MOV      r3,#0x50000
000016  e004              B        |L7.34|
                  |L7.24|
;;;1478     }
;;;1479     else if(READ_BIT(RCC->CR, RCC_CR_HSEON) == RCC_CR_HSEON)
000018  680b              LDR      r3,[r1,#0]
00001a  03db              LSLS     r3,r3,#15
00001c  d503              BPL      |L7.38|
;;;1480     {
;;;1481       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001e  f44f3380          MOV      r3,#0x10000
                  |L7.34|
000022  6043              STR      r3,[r0,#4]
000024  e000              B        |L7.40|
                  |L7.38|
;;;1482     }
;;;1483     else
;;;1484     {
;;;1485       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000026  6042              STR      r2,[r0,#4]
                  |L7.40|
;;;1486     }
;;;1487   
;;;1488      /* Get the MSI configuration -----------------------------------------------*/
;;;1489     if(READ_BIT(RCC->CR, RCC_CR_MSION) == RCC_CR_MSION)
000028  680b              LDR      r3,[r1,#0]
00002a  07dc              LSLS     r4,r3,#31
;;;1490     {
;;;1491       RCC_OscInitStruct->MSIState = RCC_MSI_ON;
00002c  f04f0301          MOV      r3,#1
000030  d001              BEQ      |L7.54|
000032  6183              STR      r3,[r0,#0x18]
000034  e000              B        |L7.56|
                  |L7.54|
;;;1492     }
;;;1493     else
;;;1494     {
;;;1495       RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
000036  6182              STR      r2,[r0,#0x18]
                  |L7.56|
;;;1496     }
;;;1497   
;;;1498     RCC_OscInitStruct->MSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos;
000038  684c              LDR      r4,[r1,#4]
00003a  f3c42407          UBFX     r4,r4,#8,#8
;;;1499     RCC_OscInitStruct->MSIClockRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
00003e  61c4              STR      r4,[r0,#0x1c]
000040  680c              LDR      r4,[r1,#0]
000042  f00404f0          AND      r4,r4,#0xf0
;;;1500   
;;;1501     /* Get the HSI configuration -----------------------------------------------*/
;;;1502     if(READ_BIT(RCC->CR, RCC_CR_HSION) == RCC_CR_HSION)
000046  6204              STR      r4,[r0,#0x20]
000048  680c              LDR      r4,[r1,#0]
00004a  05e4              LSLS     r4,r4,#23
00004c  d503              BPL      |L7.86|
;;;1503     {
;;;1504       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
00004e  f44f7480          MOV      r4,#0x100
000052  60c4              STR      r4,[r0,#0xc]
000054  e000              B        |L7.88|
                  |L7.86|
;;;1505     }
;;;1506     else
;;;1507     {
;;;1508       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000056  60c2              STR      r2,[r0,#0xc]
                  |L7.88|
;;;1509     }
;;;1510   
;;;1511     RCC_OscInitStruct->HSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos;
000058  684c              LDR      r4,[r1,#4]
00005a  f3c46404          UBFX     r4,r4,#24,#5
;;;1512   
;;;1513     /* Get the LSE configuration -----------------------------------------------*/
;;;1514     if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
00005e  6104              STR      r4,[r0,#0x10]
000060  f8d14090          LDR      r4,[r1,#0x90]
000064  0764              LSLS     r4,r4,#29
000066  d502              BPL      |L7.110|
;;;1515     {
;;;1516   #if defined(RCC_BDCR_LSESYSDIS)
;;;1517       if((RCC->BDCR & RCC_BDCR_LSESYSDIS) == RCC_BDCR_LSESYSDIS)
;;;1518       {
;;;1519         RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_RTC_ONLY;
;;;1520       }
;;;1521       else
;;;1522   #endif /* RCC_BDCR_LSESYSDIS */
;;;1523       {
;;;1524         RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
000068  2405              MOVS     r4,#5
00006a  6084              STR      r4,[r0,#8]
00006c  e006              B        |L7.124|
                  |L7.110|
;;;1525       }
;;;1526     }
;;;1527     else if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
00006e  f8d14090          LDR      r4,[r1,#0x90]
000072  07e4              LSLS     r4,r4,#31
000074  d001              BEQ      |L7.122|
;;;1528     {
;;;1529   #if defined(RCC_BDCR_LSESYSDIS)
;;;1530       if((RCC->BDCR & RCC_BDCR_LSESYSDIS) == RCC_BDCR_LSESYSDIS)
;;;1531       {
;;;1532         RCC_OscInitStruct->LSEState = RCC_LSE_ON_RTC_ONLY;
;;;1533       }
;;;1534       else
;;;1535   #endif /* RCC_BDCR_LSESYSDIS */
;;;1536       {
;;;1537         RCC_OscInitStruct->LSEState = RCC_LSE_ON;
000076  6083              STR      r3,[r0,#8]
000078  e000              B        |L7.124|
                  |L7.122|
;;;1538       }
;;;1539     }
;;;1540     else
;;;1541     {
;;;1542       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00007a  6082              STR      r2,[r0,#8]
                  |L7.124|
;;;1543     }
;;;1544   
;;;1545     /* Get the LSI configuration -----------------------------------------------*/
;;;1546     if(READ_BIT(RCC->CSR, RCC_CSR_LSION) == RCC_CSR_LSION)
00007c  f8d14094          LDR      r4,[r1,#0x94]
000080  07e4              LSLS     r4,r4,#31
000082  d001              BEQ      |L7.136|
;;;1547     {
;;;1548       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000084  6143              STR      r3,[r0,#0x14]
000086  e000              B        |L7.138|
                  |L7.136|
;;;1549     }
;;;1550     else
;;;1551     {
;;;1552       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000088  6142              STR      r2,[r0,#0x14]
                  |L7.138|
;;;1553     }
;;;1554   #if defined(RCC_CSR_LSIPREDIV)
;;;1555   
;;;1556     /* Get the LSI configuration -----------------------------------------------*/
;;;1557     if((RCC->CSR & RCC_CSR_LSIPREDIV) == RCC_CSR_LSIPREDIV)
;;;1558     {
;;;1559       RCC_OscInitStruct->LSIDiv = RCC_LSI_DIV128;
;;;1560     }
;;;1561     else
;;;1562     {
;;;1563       RCC_OscInitStruct->LSIDiv = RCC_LSI_DIV1;
;;;1564     }
;;;1565   #endif /* RCC_CSR_LSIPREDIV */
;;;1566   
;;;1567   #if defined(RCC_HSI48_SUPPORT)
;;;1568     /* Get the HSI48 configuration ---------------------------------------------*/
;;;1569     if(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON) == RCC_CRRCR_HSI48ON)
;;;1570     {
;;;1571       RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
;;;1576     }
;;;1577   #else
;;;1578     RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
;;;1579   #endif /* RCC_HSI48_SUPPORT */
;;;1580   
;;;1581     /* Get the PLL configuration -----------------------------------------------*/
;;;1582     if(READ_BIT(RCC->CR, RCC_CR_PLLON) == RCC_CR_PLLON)
00008a  6242              STR      r2,[r0,#0x24]
00008c  680a              LDR      r2,[r1,#0]
00008e  01d2              LSLS     r2,r2,#7
000090  d502              BPL      |L7.152|
;;;1583     {
;;;1584       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
000092  2202              MOVS     r2,#2
000094  6282              STR      r2,[r0,#0x28]
000096  e000              B        |L7.154|
                  |L7.152|
;;;1585     }
;;;1586     else
;;;1587     {
;;;1588       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000098  6283              STR      r3,[r0,#0x28]
                  |L7.154|
;;;1589     }
;;;1590     RCC_OscInitStruct->PLL.PLLSource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
00009a  68ca              LDR      r2,[r1,#0xc]
00009c  f0020203          AND      r2,r2,#3
;;;1591     RCC_OscInitStruct->PLL.PLLM = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
0000a0  62c2              STR      r2,[r0,#0x2c]
0000a2  68ca              LDR      r2,[r1,#0xc]
0000a4  f3c21202          UBFX     r2,r2,#4,#3
0000a8  1c52              ADDS     r2,r2,#1
;;;1592     RCC_OscInitStruct->PLL.PLLN = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
0000aa  6302              STR      r2,[r0,#0x30]
0000ac  68ca              LDR      r2,[r1,#0xc]
0000ae  f3c22206          UBFX     r2,r2,#8,#7
;;;1593     RCC_OscInitStruct->PLL.PLLQ = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
0000b2  6342              STR      r2,[r0,#0x34]
0000b4  68ca              LDR      r2,[r1,#0xc]
0000b6  f3c25241          UBFX     r2,r2,#21,#2
0000ba  1c52              ADDS     r2,r2,#1
0000bc  0052              LSLS     r2,r2,#1
;;;1594     RCC_OscInitStruct->PLL.PLLR = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) << 1U);
0000be  63c2              STR      r2,[r0,#0x3c]
0000c0  68ca              LDR      r2,[r1,#0xc]
0000c2  f3c26241          UBFX     r2,r2,#25,#2
0000c6  1c52              ADDS     r2,r2,#1
0000c8  0052              LSLS     r2,r2,#1
;;;1595   #if defined(RCC_PLLP_SUPPORT)
;;;1596   #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;1597     RCC_OscInitStruct->PLL.PLLP = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;1598   #else
;;;1599     if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
0000ca  6402              STR      r2,[r0,#0x40]
0000cc  68c9              LDR      r1,[r1,#0xc]
0000ce  0389              LSLS     r1,r1,#14
0000d0  d501              BPL      |L7.214|
;;;1600     {
;;;1601       RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV17;
0000d2  2111              MOVS     r1,#0x11
0000d4  e000              B        |L7.216|
                  |L7.214|
;;;1602     }
;;;1603     else
;;;1604     {
;;;1605       RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV7;
0000d6  2107              MOVS     r1,#7
                  |L7.216|
0000d8  6381              STR      r1,[r0,#0x38]         ;1601
;;;1606     }
;;;1607   #endif /* RCC_PLLP_DIV_2_31_SUPPORT */
;;;1608   #endif /* RCC_PLLP_SUPPORT */
;;;1609   }
0000da  bd10              POP      {r4,pc}
;;;1610   
                          ENDP

                  |L7.220|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1434     */
;;;1435   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4805              LDR      r0,|L8.24|
;;;1436   {
;;;1437     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1438     return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
000002  4906              LDR      r1,|L8.28|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6889              LDR      r1,[r1,#8]
000008  4a05              LDR      r2,|L8.32|
00000a  f3c12102          UBFX     r1,r1,#8,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  f001011f          AND      r1,r1,#0x1f
000014  40c8              LSRS     r0,r0,r1
;;;1439   }
000016  4770              BX       lr
;;;1440   
                          ENDP

                  |L8.24|
                          DCD      SystemCoreClock
                  |L8.28|
                          DCD      0x40021000
                  |L8.32|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1446     */
;;;1447   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4805              LDR      r0,|L9.24|
;;;1448   {
;;;1449     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1450     return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
000002  4906              LDR      r1,|L9.28|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6889              LDR      r1,[r1,#8]
000008  4a05              LDR      r2,|L9.32|
00000a  f3c121c2          UBFX     r1,r1,#11,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  f001011f          AND      r1,r1,#0x1f
000014  40c8              LSRS     r0,r0,r1
;;;1451   }
000016  4770              BX       lr
;;;1452   
                          ENDP

                  |L9.24|
                          DCD      SystemCoreClock
                  |L9.28|
                          DCD      0x40021000
                  |L9.32|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;1336     */
;;;1337   uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1338   {
;;;1339     uint32_t msirange = 0U, sysclockfreq = 0U;
;;;1340     uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
;;;1341     uint32_t sysclk_source, pll_oscsource;
;;;1342   
;;;1343     sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
000002  4b26              LDR      r3,|L10.156|
000004  2200              MOVS     r2,#0                 ;1339
000006  4610              MOV      r0,r2                 ;1339
000008  6899              LDR      r1,[r3,#8]
;;;1344     pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
00000a  68dc              LDR      r4,[r3,#0xc]
00000c  f011010c          ANDS     r1,r1,#0xc            ;1343
000010  f0040603          AND      r6,r4,#3
;;;1345   
;;;1346     if((sysclk_source == RCC_CFGR_SWS_MSI) ||
;;;1347        ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
;;;1348     {
;;;1349       /* MSI or PLL with MSI source used as system clock source */
;;;1350   
;;;1351       /* Get SYSCLK source */
;;;1352       if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
;;;1353       { /* MSISRANGE from RCC_CSR applies */
;;;1354         msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
;;;1355       }
;;;1356       else
;;;1357       { /* MSIRANGE from RCC_CR applies */
;;;1358         msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
;;;1359       }
;;;1360       /*MSI frequency range in HZ*/
;;;1361       msirange = MSIRangeTable[msirange];
;;;1362   
;;;1363       if(sysclk_source == RCC_CFGR_SWS_MSI)
;;;1364       {
;;;1365         /* MSI used as system clock source */
;;;1366         sysclockfreq = msirange;
;;;1367       }
;;;1368     }
;;;1369     else if(sysclk_source == RCC_CFGR_SWS_HSI)
;;;1370     {
;;;1371       /* HSI used as system clock source */
;;;1372       sysclockfreq = HSI_VALUE;
000014  4c22              LDR      r4,|L10.160|
;;;1373     }
;;;1374     else if(sysclk_source == RCC_CFGR_SWS_HSE)
;;;1375     {
;;;1376       /* HSE used as system clock source */
;;;1377       sysclockfreq = HSE_VALUE;
000016  ea4f0564          ASR      r5,r4,#1
00001a  d008              BEQ      |L10.46|
00001c  290c              CMP      r1,#0xc               ;1347
00001e  d004              BEQ      |L10.42|
000020  2904              CMP      r1,#4                 ;1369
000022  d025              BEQ      |L10.112|
000024  2908              CMP      r1,#8                 ;1374
000026  d025              BEQ      |L10.116|
000028  e010              B        |L10.76|
                  |L10.42|
00002a  2e01              CMP      r6,#1                 ;1347
00002c  d110              BNE      |L10.80|
                  |L10.46|
00002e  681a              LDR      r2,[r3,#0]            ;1352
000030  0712              LSLS     r2,r2,#28             ;1352
000032  d404              BMI      |L10.62|
000034  f8d32094          LDR      r2,[r3,#0x94]         ;1354
000038  f3c22203          UBFX     r2,r2,#8,#4           ;1354
00003c  e002              B        |L10.68|
                  |L10.62|
00003e  681a              LDR      r2,[r3,#0]            ;1358
000040  f3c21203          UBFX     r2,r2,#4,#4           ;1358
                  |L10.68|
000044  4e17              LDR      r6,|L10.164|
000046  f8562022          LDR      r2,[r6,r2,LSL #2]     ;1361
00004a  b179              CBZ      r1,|L10.108|
                  |L10.76|
;;;1378     }
;;;1379     else
;;;1380     {
;;;1381       /* unexpected case: sysclockfreq at 0 */
;;;1382     }
;;;1383   
;;;1384     if(sysclk_source == RCC_CFGR_SWS_PLL)
00004c  290c              CMP      r1,#0xc
00004e  d10e              BNE      |L10.110|
                  |L10.80|
;;;1385     {
;;;1386       /* PLL used as system clock  source */
;;;1387   
;;;1388       /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
;;;1389       SYSCLK = PLL_VCO / PLLR
;;;1390       */
;;;1391       pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
000050  68d8              LDR      r0,[r3,#0xc]
000052  f0000103          AND      r1,r0,#3
;;;1392       pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
000056  68d8              LDR      r0,[r3,#0xc]
000058  f3c01002          UBFX     r0,r0,#4,#3
00005c  1c40              ADDS     r0,r0,#1
;;;1393   
;;;1394       switch (pllsource)
00005e  2902              CMP      r1,#2
000060  d00a              BEQ      |L10.120|
000062  2903              CMP      r1,#3
000064  d00b              BEQ      |L10.126|
;;;1395       {
;;;1396       case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
;;;1397         pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
;;;1398         break;
;;;1399   
;;;1400       case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
;;;1401         pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
;;;1402         break;
;;;1403   
;;;1404       case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
;;;1405       default:
;;;1406         pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
000066  fbb2f0f0          UDIV     r0,r2,r0
;;;1407         break;
00006a  e00a              B        |L10.130|
                  |L10.108|
00006c  4610              MOV      r0,r2                 ;1366
                  |L10.110|
;;;1408       }
;;;1409       pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
;;;1410       sysclockfreq = pllvco/pllr;
;;;1411     }
;;;1412   
;;;1413     return sysclockfreq;
;;;1414   }
00006e  bd70              POP      {r4-r6,pc}
                  |L10.112|
000070  4620              MOV      r0,r4                 ;1372
000072  bd70              POP      {r4-r6,pc}
                  |L10.116|
000074  4628              MOV      r0,r5                 ;1377
000076  bd70              POP      {r4-r6,pc}
                  |L10.120|
000078  fbb4f0f0          UDIV     r0,r4,r0              ;1397
00007c  e001              B        |L10.130|
                  |L10.126|
00007e  fbb5f0f0          UDIV     r0,r5,r0              ;1401
                  |L10.130|
000082  68d9              LDR      r1,[r3,#0xc]          ;1397
000084  f3c12106          UBFX     r1,r1,#8,#7           ;1397
000088  4348              MULS     r0,r1,r0              ;1397
00008a  68d9              LDR      r1,[r3,#0xc]          ;1409
00008c  f3c16141          UBFX     r1,r1,#25,#2          ;1409
000090  1c49              ADDS     r1,r1,#1              ;1409
000092  0049              LSLS     r1,r1,#1              ;1409
000094  fbb0f0f1          UDIV     r0,r0,r1              ;1410
000098  bd70              POP      {r4-r6,pc}
;;;1415   
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
                          DCD      0x40021000
                  |L10.160|
                          DCD      0x00f42400
                  |L10.164|
                          DCD      MSIRangeTable

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;1277     */
;;;1278   void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b570              PUSH     {r4-r6,lr}
;;;1279   {
;;;1280     GPIO_InitTypeDef GPIO_InitStruct;
;;;1281   
;;;1282     /* Check the parameters */
;;;1283     assert_param(IS_RCC_MCO(RCC_MCOx));
;;;1284     assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;1285     assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;1286   
;;;1287     /* Prevent unused argument(s) compilation warning if no assert_param check */
;;;1288     UNUSED(RCC_MCOx);
;;;1289   
;;;1290     /* MCO Clock Enable */
;;;1291     __MCO1_CLK_ENABLE();
000002  4c10              LDR      r4,|L11.68|
000004  b086              SUB      sp,sp,#0x18           ;1279
000006  4616              MOV      r6,r2                 ;1279
000008  6ce0              LDR      r0,[r4,#0x4c]
00000a  460d              MOV      r5,r1                 ;1279
00000c  f0400001          ORR      r0,r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  6ce0              LDR      r0,[r4,#0x4c]
;;;1292   
;;;1293     /* Configue the MCO1 pin in alternate function mode */
;;;1294     GPIO_InitStruct.Pin = MCO1_PIN;
;;;1295     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;1296     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
;;;1297     GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;1298     GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;1299     HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
000014  4669              MOV      r1,sp
000016  f0000001          AND      r0,r0,#1              ;1291
00001a  9005              STR      r0,[sp,#0x14]         ;1294
00001c  15a0              ASRS     r0,r4,#22             ;1294
00001e  9000              STR      r0,[sp,#0]            ;1295
000020  2002              MOVS     r0,#2                 ;1295
000022  9001              STR      r0,[sp,#4]            ;1296
000024  9003              STR      r0,[sp,#0xc]          ;1297
000026  2000              MOVS     r0,#0                 ;1297
000028  9002              STR      r0,[sp,#8]            ;1298
00002a  9004              STR      r0,[sp,#0x10]
00002c  f04f4090          MOV      r0,#0x48000000
000030  f7fffffe          BL       HAL_GPIO_Init
;;;1300   
;;;1301     /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
;;;1302     MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv ));
000034  68a0              LDR      r0,[r4,#8]
000036  4335              ORRS     r5,r5,r6
000038  f02040ee          BIC      r0,r0,#0x77000000
00003c  4328              ORRS     r0,r0,r5
00003e  60a0              STR      r0,[r4,#8]
;;;1303   }
000040  b006              ADD      sp,sp,#0x18
000042  bd70              POP      {r4-r6,pc}
;;;1304   
                          ENDP

                  |L11.68|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1663     */
;;;1664   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1665   {
;;;1666     /* Check RCC CSSF interrupt flag  */
;;;1667     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L12.20|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  05c0              LSLS     r0,r0,#23
000008  d503              BPL      |L12.18|
;;;1668     {
;;;1669       /* RCC Clock Security System interrupt user callback */
;;;1670       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1671   
;;;1672       /* Clear RCC CSS pending bit */
;;;1673       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  15a0              ASRS     r0,r4,#22
000010  6220              STR      r0,[r4,#0x20]
                  |L12.18|
;;;1674     }
;;;1675   }
000012  bd10              POP      {r4,pc}
;;;1676   
                          ENDP

                  |L12.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;415      */
;;;416    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;417    {
000004  0004              MOVS     r4,r0
                  |L13.6|
000006  d07c              BEQ      |L13.258|
;;;418      uint32_t tickstart;
;;;419      HAL_StatusTypeDef status;
;;;420      uint32_t sysclk_source, pll_oscsource;
;;;421    
;;;422      /* Check Null pointer */
;;;423      if(RCC_OscInitStruct == NULL)
;;;424      {
;;;425        return HAL_ERROR;
;;;426      }
;;;427    
;;;428      /* Check the parameters */
;;;429      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;430    
;;;431      sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
000008  4dfa              LDR      r5,|L13.1012|
00000a  68a8              LDR      r0,[r5,#8]
00000c  f000060c          AND      r6,r0,#0xc
;;;432      pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
000010  68e8              LDR      r0,[r5,#0xc]
000012  f0000703          AND      r7,r0,#3
;;;433    
;;;434      /*----------------------------- MSI Configuration --------------------------*/
;;;435      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
000016  7820              LDRB     r0,[r4,#0]
000018  06c0              LSLS     r0,r0,#27
00001a  d562              BPL      |L13.226|
;;;436      {
;;;437        /* Check the parameters */
;;;438        assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
;;;439        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
;;;440        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
;;;441    
;;;442        /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
;;;443        if((sysclk_source == RCC_CFGR_SWS_MSI) ||
00001c  b176              CBZ      r6,|L13.60|
;;;444           ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
00001e  2e0c              CMP      r6,#0xc
000020  d101              BNE      |L13.38|
000022  2f01              CMP      r7,#1
000024  d00a              BEQ      |L13.60|
                  |L13.38|
;;;445        {
;;;446          if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
;;;447          {
;;;448            return HAL_ERROR;
;;;449          }
;;;450    
;;;451           /* Otherwise, just the calibration and MSI range change are allowed */
;;;452          else
;;;453          {
;;;454            /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;455               must be correctly programmed according to the frequency of the CPU clock
;;;456               (HCLK) and the supply voltage of the device. */
;;;457            if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
;;;458            {
;;;459              /* First increase number of wait states update if necessary */
;;;460              if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
;;;461              {
;;;462                return HAL_ERROR;
;;;463              }
;;;464    
;;;465              /* Selects the Multiple Speed oscillator (MSI) clock range .*/
;;;466              __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
;;;467              /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
;;;468              __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
;;;469            }
;;;470            else
;;;471            {
;;;472              /* Else, keep current flash latency while decreasing applies */
;;;473              /* Selects the Multiple Speed oscillator (MSI) clock range .*/
;;;474              __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
;;;475              /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
;;;476              __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
;;;477    
;;;478              /* Decrease number of wait states update if necessary */
;;;479              if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
;;;480              {
;;;481                return HAL_ERROR;
;;;482              }
;;;483            }
;;;484    
;;;485            /* Update the SystemCoreClock global variable */
;;;486            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
;;;487    
;;;488            /* Configure the source of time base considering new system clocks settings*/
;;;489            status = HAL_InitTick (TICK_INT_PRIORITY);
;;;490            if(status != HAL_OK)
;;;491            {
;;;492              return status;
;;;493            }
;;;494          }
;;;495        }
;;;496        else
;;;497        {
;;;498          /* Check the MSI State */
;;;499          if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
000026  69a0              LDR      r0,[r4,#0x18]
000028  2800              CMP      r0,#0
;;;500          {
;;;501            /* Enable the Internal High Speed oscillator (MSI). */
;;;502            __HAL_RCC_MSI_ENABLE();
;;;503    
;;;504            /* Get timeout */
;;;505            tickstart = HAL_GetTick();
;;;506    
;;;507            /* Wait till MSI is ready */
;;;508            while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
;;;509            {
;;;510              if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
;;;511              {
;;;512                return HAL_TIMEOUT;
;;;513              }
;;;514            }
;;;515             /* Selects the Multiple Speed oscillator (MSI) clock range .*/
;;;516            __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
;;;517             /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
;;;518            __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
;;;519    
;;;520          }
;;;521          else
;;;522          {
;;;523            /* Disable the Internal High Speed oscillator (MSI). */
;;;524            __HAL_RCC_MSI_DISABLE();
00002a  6828              LDR      r0,[r5,#0]
00002c  d078              BEQ      |L13.288|
00002e  f0400001          ORR      r0,r0,#1              ;502
000032  6028              STR      r0,[r5,#0]            ;502
000034  f7fffffe          BL       HAL_GetTick
000038  4680              MOV      r8,r0                 ;505
00003a  e059              B        |L13.240|
                  |L13.60|
00003c  6828              LDR      r0,[r5,#0]            ;446
00003e  0780              LSLS     r0,r0,#30             ;446
000040  d502              BPL      |L13.72|
000042  69a0              LDR      r0,[r4,#0x18]         ;446
000044  2800              CMP      r0,#0                 ;446
000046  d0de              BEQ      |L13.6|
                  |L13.72|
000048  6a21              LDR      r1,[r4,#0x20]         ;457
00004a  6828              LDR      r0,[r5,#0]            ;457
00004c  0700              LSLS     r0,r0,#28             ;457
00004e  d503              BPL      |L13.88|
000050  6828              LDR      r0,[r5,#0]            ;457
000052  f00000f0          AND      r0,r0,#0xf0           ;457
000056  e004              B        |L13.98|
                  |L13.88|
000058  f8d50094          LDR      r0,[r5,#0x94]         ;457
;;;525    
;;;526            /* Get timeout */
;;;527            tickstart = HAL_GetTick();
;;;528    
;;;529            /* Wait till MSI is ready */
;;;530            while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
;;;531            {
;;;532              if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
;;;533              {
;;;534                return HAL_TIMEOUT;
;;;535              }
;;;536            }
;;;537          }
;;;538        }
;;;539      }
;;;540      /*------------------------------- HSE Configuration ------------------------*/
;;;541      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
;;;542      {
;;;543        /* Check the parameters */
;;;544        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;545    
;;;546        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;547        if((sysclk_source == RCC_CFGR_SWS_HSE) ||
;;;548           ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSE)))
;;;549        {
;;;550          if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
;;;551          {
;;;552            return HAL_ERROR;
;;;553          }
;;;554        }
;;;555        else
;;;556        {
;;;557          /* Set the new HSE configuration ---------------------------------------*/
;;;558          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
;;;559    
;;;560          /* Check the HSE State */
;;;561          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
;;;562          {
;;;563            /* Get Start Tick*/
;;;564            tickstart = HAL_GetTick();
;;;565    
;;;566            /* Wait till HSE is ready */
;;;567            while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
;;;568            {
;;;569              if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
;;;570              {
;;;571                return HAL_TIMEOUT;
;;;572              }
;;;573            }
;;;574          }
;;;575          else
;;;576          {
;;;577            /* Get Start Tick*/
;;;578            tickstart = HAL_GetTick();
;;;579    
;;;580            /* Wait till HSE is disabled */
;;;581            while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
;;;582            {
;;;583              if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
;;;584              {
;;;585                return HAL_TIMEOUT;
;;;586              }
;;;587            }
;;;588          }
;;;589        }
;;;590      }
;;;591      /*----------------------------- HSI Configuration --------------------------*/
;;;592      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
;;;593      {
;;;594        /* Check the parameters */
;;;595        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;596        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;597    
;;;598        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
;;;599        if((sysclk_source == RCC_CFGR_SWS_HSI) ||
;;;600           ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSI)))
;;;601        {
;;;602          /* When HSI is used as system clock it will not be disabled */
;;;603          if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
;;;604          {
;;;605            return HAL_ERROR;
;;;606          }
;;;607          /* Otherwise, just the calibration is allowed */
;;;608          else
;;;609          {
;;;610            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;611            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;612          }
;;;613        }
;;;614        else
;;;615        {
;;;616          /* Check the HSI State */
;;;617          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;618          {
;;;619            /* Enable the Internal High Speed oscillator (HSI). */
;;;620            __HAL_RCC_HSI_ENABLE();
;;;621    
;;;622            /* Get Start Tick*/
;;;623            tickstart = HAL_GetTick();
;;;624    
;;;625            /* Wait till HSI is ready */
;;;626            while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
;;;627            {
;;;628              if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
;;;629              {
;;;630                return HAL_TIMEOUT;
;;;631              }
;;;632            }
;;;633    
;;;634            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;635            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;636          }
;;;637          else
;;;638          {
;;;639            /* Disable the Internal High Speed oscillator (HSI). */
;;;640            __HAL_RCC_HSI_DISABLE();
;;;641    
;;;642            /* Get Start Tick*/
;;;643            tickstart = HAL_GetTick();
;;;644    
;;;645            /* Wait till HSI is disabled */
;;;646            while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
;;;647            {
;;;648              if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
;;;649              {
;;;650                return HAL_TIMEOUT;
;;;651              }
;;;652            }
;;;653          }
;;;654        }
;;;655      }
;;;656      /*------------------------------ LSI Configuration -------------------------*/
;;;657      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
;;;658      {
;;;659        /* Check the parameters */
;;;660        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;661    
;;;662        /* Check the LSI State */
;;;663        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
;;;664        {
;;;665    #if defined(RCC_CSR_LSIPREDIV)
;;;666          uint32_t csr_temp = RCC->CSR;
;;;667    
;;;668          /* Check LSI division factor */
;;;669          assert_param(IS_RCC_LSIDIV(RCC_OscInitStruct->LSIDiv));
;;;670    
;;;671          if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPREDIV))
;;;672          {
;;;673            if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
;;;674                ((csr_temp & RCC_CSR_LSION) != RCC_CSR_LSION))
;;;675            {
;;;676               /* If LSIRDY is set while LSION is not enabled,
;;;677                  LSIPREDIV can't be updated  */
;;;678              return HAL_ERROR;
;;;679            }
;;;680    
;;;681            /* Turn off LSI before changing RCC_CSR_LSIPREDIV */
;;;682            if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
;;;683            {
;;;684              __HAL_RCC_LSI_DISABLE();
;;;685    
;;;686              /* Get Start Tick*/
;;;687              tickstart = HAL_GetTick();
;;;688    
;;;689              /* Wait till LSI is disabled */
;;;690              while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
;;;691              {
;;;692                if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
;;;693                {
;;;694                  return HAL_TIMEOUT;
;;;695                }
;;;696              }
;;;697            }
;;;698    
;;;699            /* Set LSI division factor */
;;;700            MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
;;;701          }
;;;702    #endif /* RCC_CSR_LSIPREDIV */
;;;703    
;;;704          /* Enable the Internal Low Speed oscillator (LSI). */
;;;705          __HAL_RCC_LSI_ENABLE();
;;;706    
;;;707          /* Get Start Tick*/
;;;708          tickstart = HAL_GetTick();
;;;709    
;;;710          /* Wait till LSI is ready */
;;;711          while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
;;;712          {
;;;713            if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
;;;714            {
;;;715              return HAL_TIMEOUT;
;;;716            }
;;;717          }
;;;718        }
;;;719        else
;;;720        {
;;;721          /* Disable the Internal Low Speed oscillator (LSI). */
;;;722          __HAL_RCC_LSI_DISABLE();
;;;723    
;;;724          /* Get Start Tick*/
;;;725          tickstart = HAL_GetTick();
;;;726    
;;;727          /* Wait till LSI is disabled */
;;;728          while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
;;;729          {
;;;730            if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
;;;731            {
;;;732              return HAL_TIMEOUT;
;;;733            }
;;;734          }
;;;735        }
;;;736      }
;;;737      /*------------------------------ LSE Configuration -------------------------*/
;;;738      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
;;;739      {
;;;740        FlagStatus       pwrclkchanged = RESET;
;;;741    
;;;742        /* Check the parameters */
;;;743        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;744    
;;;745        /* Update LSE configuration in Backup Domain control register    */
;;;746        /* Requires to enable write access to Backup Domain of necessary */
;;;747        if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
;;;748        {
;;;749          __HAL_RCC_PWR_CLK_ENABLE();
;;;750          pwrclkchanged = SET;
;;;751        }
;;;752    
;;;753        if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
;;;754        {
;;;755          /* Enable write access to Backup domain */
;;;756          SET_BIT(PWR->CR1, PWR_CR1_DBP);
;;;757    
;;;758          /* Wait for Backup domain Write protection disable */
;;;759          tickstart = HAL_GetTick();
;;;760    
;;;761          while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
;;;762          {
;;;763            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
;;;764            {
;;;765              return HAL_TIMEOUT;
;;;766            }
;;;767          }
;;;768        }
;;;769    
;;;770        /* Set the new LSE configuration -----------------------------------------*/
;;;771    #if defined(RCC_BDCR_LSESYSDIS)
;;;772        if((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
;;;773        {
;;;774          /* Set LSESYSDIS bit according to LSE propagation option (enabled or disabled) */
;;;775          MODIFY_REG(RCC->BDCR, RCC_BDCR_LSESYSDIS, (RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSDIS));
;;;776    
;;;777          if((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
;;;778          {
;;;779            /* LSE oscillator bypass enable */
;;;780            SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
;;;781            SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
;;;782          }
;;;783          else
;;;784          {
;;;785            /* LSE oscillator enable */
;;;786            SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
;;;787          }
;;;788        }
;;;789        else
;;;790        {
;;;791          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
;;;792          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
;;;793        }
;;;794    #else
;;;795        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
;;;796    #endif /* RCC_BDCR_LSESYSDIS */
;;;797    
;;;798        /* Check the LSE State */
;;;799        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
;;;800        {
;;;801          /* Get Start Tick*/
;;;802          tickstart = HAL_GetTick();
;;;803    
;;;804          /* Wait till LSE is ready */
;;;805          while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
;;;806          {
;;;807            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;808            {
;;;809              return HAL_TIMEOUT;
;;;810            }
;;;811          }
;;;812        }
;;;813        else
;;;814        {
;;;815          /* Get Start Tick*/
;;;816          tickstart = HAL_GetTick();
;;;817    
;;;818          /* Wait till LSE is disabled */
;;;819          while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
;;;820          {
;;;821            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;822            {
;;;823              return HAL_TIMEOUT;
;;;824            }
;;;825          }
;;;826    
;;;827    #if defined(RCC_BDCR_LSESYSDIS)
;;;828          /* By default, stop disabling LSE propagation */
;;;829          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
;;;830    #endif /* RCC_BDCR_LSESYSDIS */
;;;831        }
;;;832    
;;;833        /* Restore clock configuration if changed */
;;;834        if(pwrclkchanged == SET)
;;;835        {
;;;836          __HAL_RCC_PWR_CLK_DISABLE();
;;;837        }
;;;838      }
;;;839    #if defined(RCC_HSI48_SUPPORT)
;;;840      /*------------------------------ HSI48 Configuration -----------------------*/
;;;841      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
;;;842      {
;;;843        /* Check the parameters */
;;;844        assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
;;;845    
;;;846        /* Check the LSI State */
;;;847        if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
;;;848        {
;;;849          /* Enable the Internal Low Speed oscillator (HSI48). */
;;;850          __HAL_RCC_HSI48_ENABLE();
;;;851    
;;;852          /* Get Start Tick*/
;;;853          tickstart = HAL_GetTick();
;;;854    
;;;855          /* Wait till HSI48 is ready */
;;;856          while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
;;;857          {
;;;858            if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
;;;859            {
;;;860              return HAL_TIMEOUT;
;;;861            }
;;;862          }
;;;863        }
;;;864        else
;;;865        {
;;;866          /* Disable the Internal Low Speed oscillator (HSI48). */
;;;867          __HAL_RCC_HSI48_DISABLE();
;;;868    
;;;869          /* Get Start Tick*/
;;;870          tickstart = HAL_GetTick();
;;;871    
;;;872          /* Wait till HSI48 is disabled */
;;;873          while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
;;;874          {
;;;875            if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
;;;876            {
;;;877              return HAL_TIMEOUT;
;;;878            }
;;;879          }
;;;880        }
;;;881      }
;;;882    #endif /* RCC_HSI48_SUPPORT */
;;;883      /*-------------------------------- PLL Configuration -----------------------*/
;;;884      /* Check the parameters */
;;;885      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;886    
;;;887      if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
;;;888      {
;;;889        /* Check if the PLL is used as system clock or not */
;;;890        if(sysclk_source != RCC_CFGR_SWS_PLL)
;;;891        {
;;;892          if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
;;;893          {
;;;894            /* Check the parameters */
;;;895            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;896            assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
;;;897            assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
;;;898    #if defined(RCC_PLLP_SUPPORT)
;;;899            assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
;;;900    #endif /* RCC_PLLP_SUPPORT */
;;;901            assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
;;;902            assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
;;;903    
;;;904            /* Disable the main PLL. */
;;;905            __HAL_RCC_PLL_DISABLE();
;;;906    
;;;907            /* Get Start Tick*/
;;;908            tickstart = HAL_GetTick();
;;;909    
;;;910            /* Wait till PLL is ready */
;;;911            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
;;;912            {
;;;913              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;914              {
;;;915                return HAL_TIMEOUT;
;;;916              }
;;;917            }
;;;918    
;;;919            /* Configure the main PLL clock source, multiplication and division factors. */
;;;920            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;921                                 RCC_OscInitStruct->PLL.PLLM,
;;;922                                 RCC_OscInitStruct->PLL.PLLN,
;;;923    #if defined(RCC_PLLP_SUPPORT)
;;;924                                 RCC_OscInitStruct->PLL.PLLP,
;;;925    #endif
;;;926                                 RCC_OscInitStruct->PLL.PLLQ,
;;;927                                 RCC_OscInitStruct->PLL.PLLR);
;;;928    
;;;929            /* Enable the main PLL. */
;;;930            __HAL_RCC_PLL_ENABLE();
;;;931    
;;;932            /* Enable PLL System Clock output. */
;;;933             __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
;;;934    
;;;935            /* Get Start Tick*/
;;;936            tickstart = HAL_GetTick();
;;;937    
;;;938            /* Wait till PLL is ready */
;;;939            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;940            {
;;;941              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;942              {
;;;943                return HAL_TIMEOUT;
;;;944              }
;;;945            }
;;;946          }
;;;947          else
;;;948          {
;;;949            /* Disable the main PLL. */
;;;950            __HAL_RCC_PLL_DISABLE();
;;;951    
;;;952            /* Disable all PLL outputs to save power if no PLLs on */
;;;953    #if defined(RCC_PLLSAI1_SUPPORT) && defined(RCC_CR_PLLSAI2RDY)
;;;954            if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
;;;955            {
;;;956              MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;957            }
;;;958    #elif defined(RCC_PLLSAI1_SUPPORT)
;;;959            if(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
;;;960            {
;;;961              MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;962            }
;;;963    #else
;;;964            MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;965    #endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */
;;;966    
;;;967    #if defined(RCC_PLLSAI2_SUPPORT)
;;;968            __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
;;;969    #elif defined(RCC_PLLSAI1_SUPPORT)
;;;970            __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
;;;971    #else
;;;972            __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
;;;973    #endif /* RCC_PLLSAI2_SUPPORT */
;;;974    
;;;975            /* Get Start Tick*/
;;;976            tickstart = HAL_GetTick();
;;;977    
;;;978            /* Wait till PLL is disabled */
;;;979            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
;;;980            {
;;;981              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;982              {
;;;983                return HAL_TIMEOUT;
;;;984              }
;;;985            }
;;;986          }
;;;987        }
;;;988        else
;;;989        {
;;;990          return HAL_ERROR;
;;;991        }
;;;992      }
;;;993      return HAL_OK;
;;;994    }
00005c  22f0              MOVS     r2,#0xf0
00005e  ea021010          AND      r0,r2,r0,LSR #4
                  |L13.98|
000062  4281              CMP      r1,r0                 ;457
000064  d916              BLS      |L13.148|
000066  4608              MOV      r0,r1                 ;457
000068  f7fffffe          BL       RCC_SetFlashLatencyFromMSIRange
00006c  2800              CMP      r0,#0                 ;460
                  |L13.110|
00006e  d148              BNE      |L13.258|
000070  6828              LDR      r0,[r5,#0]            ;466
000072  f0400008          ORR      r0,r0,#8              ;466
000076  6028              STR      r0,[r5,#0]            ;466
000078  6828              LDR      r0,[r5,#0]            ;466
00007a  6a21              LDR      r1,[r4,#0x20]         ;466
00007c  f02000f0          BIC      r0,r0,#0xf0           ;466
000080  4308              ORRS     r0,r0,r1              ;466
000082  6028              STR      r0,[r5,#0]            ;466
000084  6868              LDR      r0,[r5,#4]            ;468
000086  69e1              LDR      r1,[r4,#0x1c]         ;468
000088  f420407f          BIC      r0,r0,#0xff00         ;468
00008c  ea402001          ORR      r0,r0,r1,LSL #8       ;468
000090  6068              STR      r0,[r5,#4]            ;468
000092  e015              B        |L13.192|
                  |L13.148|
000094  6828              LDR      r0,[r5,#0]            ;474
000096  f0400008          ORR      r0,r0,#8              ;474
00009a  6028              STR      r0,[r5,#0]            ;474
00009c  6828              LDR      r0,[r5,#0]            ;474
00009e  6a21              LDR      r1,[r4,#0x20]         ;474
0000a0  f02000f0          BIC      r0,r0,#0xf0           ;474
0000a4  4308              ORRS     r0,r0,r1              ;474
0000a6  6028              STR      r0,[r5,#0]            ;474
0000a8  6868              LDR      r0,[r5,#4]            ;476
0000aa  69e1              LDR      r1,[r4,#0x1c]         ;476
0000ac  f420407f          BIC      r0,r0,#0xff00         ;476
0000b0  ea402001          ORR      r0,r0,r1,LSL #8       ;476
0000b4  6068              STR      r0,[r5,#4]            ;476
0000b6  6a20              LDR      r0,[r4,#0x20]         ;479
0000b8  f7fffffe          BL       RCC_SetFlashLatencyFromMSIRange
0000bc  2800              CMP      r0,#0                 ;479
0000be  d1d6              BNE      |L13.110|
                  |L13.192|
0000c0  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0000c4  68a9              LDR      r1,[r5,#8]            ;486
0000c6  4acc              LDR      r2,|L13.1016|
0000c8  f3c11103          UBFX     r1,r1,#4,#4           ;486
0000cc  5c51              LDRB     r1,[r2,r1]            ;486
0000ce  f001011f          AND      r1,r1,#0x1f           ;486
0000d2  40c8              LSRS     r0,r0,r1              ;486
0000d4  49c9              LDR      r1,|L13.1020|
0000d6  6008              STR      r0,[r1,#0]            ;489  ; SystemCoreClock
0000d8  2000              MOVS     r0,#0                 ;489
0000da  f7fffffe          BL       HAL_InitTick
0000de  2800              CMP      r0,#0                 ;490
0000e0  d17e              BNE      |L13.480|
                  |L13.226|
0000e2  e02d              B        |L13.320|
                  |L13.228|
0000e4  f7fffffe          BL       HAL_GetTick
0000e8  eba00008          SUB      r0,r0,r8              ;510
0000ec  2802              CMP      r0,#2                 ;510
                  |L13.238|
0000ee  d878              BHI      |L13.482|
                  |L13.240|
0000f0  6828              LDR      r0,[r5,#0]            ;508
0000f2  0780              LSLS     r0,r0,#30             ;508
0000f4  d5f6              BPL      |L13.228|
0000f6  6828              LDR      r0,[r5,#0]            ;516
0000f8  f0400008          ORR      r0,r0,#8              ;516
0000fc  6028              STR      r0,[r5,#0]            ;516
0000fe  6828              LDR      r0,[r5,#0]            ;516
000100  e001              B        |L13.262|
                  |L13.258|
000102  e0b8              B        |L13.630|
000104  e00c              B        |L13.288|
                  |L13.262|
000106  6a21              LDR      r1,[r4,#0x20]         ;516
000108  f02000f0          BIC      r0,r0,#0xf0           ;516
00010c  4308              ORRS     r0,r0,r1              ;516
00010e  6028              STR      r0,[r5,#0]            ;516
000110  6868              LDR      r0,[r5,#4]            ;518
000112  69e1              LDR      r1,[r4,#0x1c]         ;518
000114  f420407f          BIC      r0,r0,#0xff00         ;518
000118  ea402001          ORR      r0,r0,r1,LSL #8       ;518
00011c  6068              STR      r0,[r5,#4]            ;518
00011e  e00f              B        |L13.320|
                  |L13.288|
000120  f0200001          BIC      r0,r0,#1              ;524
000124  6028              STR      r0,[r5,#0]            ;524
000126  f7fffffe          BL       HAL_GetTick
00012a  4680              MOV      r8,r0                 ;527
00012c  e005              B        |L13.314|
                  |L13.302|
00012e  f7fffffe          BL       HAL_GetTick
000132  eba00008          SUB      r0,r0,r8              ;532
000136  2802              CMP      r0,#2                 ;532
                  |L13.312|
000138  d8d9              BHI      |L13.238|
                  |L13.314|
00013a  6828              LDR      r0,[r5,#0]            ;530
00013c  0780              LSLS     r0,r0,#30             ;530
00013e  d4f6              BMI      |L13.302|
                  |L13.320|
000140  7820              LDRB     r0,[r4,#0]            ;541
000142  07c0              LSLS     r0,r0,#31             ;541
000144  d040              BEQ      |L13.456|
000146  2e08              CMP      r6,#8                 ;547
000148  d018              BEQ      |L13.380|
00014a  2e0c              CMP      r6,#0xc               ;548
00014c  d101              BNE      |L13.338|
00014e  2f03              CMP      r7,#3                 ;548
000150  d014              BEQ      |L13.380|
                  |L13.338|
000152  6860              LDR      r0,[r4,#4]            ;558
000154  f5b03f80          CMP      r0,#0x10000           ;558
000158  d017              BEQ      |L13.394|
00015a  f5b02fa0          CMP      r0,#0x50000           ;558
00015e  6828              LDR      r0,[r5,#0]            ;558
000160  d017              BEQ      |L13.402|
000162  f4203080          BIC      r0,r0,#0x10000        ;558
000166  6028              STR      r0,[r5,#0]            ;558
000168  6828              LDR      r0,[r5,#0]            ;558
00016a  f4202080          BIC      r0,r0,#0x40000        ;558
                  |L13.366|
00016e  6028              STR      r0,[r5,#0]            ;558
000170  6860              LDR      r0,[r4,#4]            ;561
000172  b1e0              CBZ      r0,|L13.430|
000174  f7fffffe          BL       HAL_GetTick
000178  4680              MOV      r8,r0                 ;564
00017a  e014              B        |L13.422|
                  |L13.380|
00017c  6828              LDR      r0,[r5,#0]            ;550
00017e  0380              LSLS     r0,r0,#14             ;550
000180  d522              BPL      |L13.456|
000182  6860              LDR      r0,[r4,#4]            ;550
000184  2800              CMP      r0,#0                 ;550
                  |L13.390|
000186  d076              BEQ      |L13.630|
000188  e01e              B        |L13.456|
                  |L13.394|
00018a  6828              LDR      r0,[r5,#0]            ;558
00018c  f4403080          ORR      r0,r0,#0x10000        ;558
000190  e7ed              B        |L13.366|
                  |L13.402|
000192  f4402080          ORR      r0,r0,#0x40000        ;558
000196  6028              STR      r0,[r5,#0]            ;558
000198  e7f7              B        |L13.394|
                  |L13.410|
00019a  f7fffffe          BL       HAL_GetTick
00019e  eba00008          SUB      r0,r0,r8              ;569
0001a2  2864              CMP      r0,#0x64              ;569
0001a4  d8a3              BHI      |L13.238|
                  |L13.422|
0001a6  6828              LDR      r0,[r5,#0]            ;567
0001a8  0380              LSLS     r0,r0,#14             ;567
0001aa  d5f6              BPL      |L13.410|
0001ac  e00c              B        |L13.456|
                  |L13.430|
0001ae  f7fffffe          BL       HAL_GetTick
0001b2  4680              MOV      r8,r0                 ;578
0001b4  e005              B        |L13.450|
                  |L13.438|
0001b6  f7fffffe          BL       HAL_GetTick
0001ba  eba00008          SUB      r0,r0,r8              ;583
0001be  2864              CMP      r0,#0x64              ;583
0001c0  d895              BHI      |L13.238|
                  |L13.450|
0001c2  6828              LDR      r0,[r5,#0]            ;581
0001c4  0380              LSLS     r0,r0,#14             ;581
0001c6  d4f6              BMI      |L13.438|
                  |L13.456|
0001c8  7820              LDRB     r0,[r4,#0]            ;592
0001ca  0780              LSLS     r0,r0,#30             ;592
0001cc  d539              BPL      |L13.578|
0001ce  2e04              CMP      r6,#4                 ;599
0001d0  d011              BEQ      |L13.502|
0001d2  2e0c              CMP      r6,#0xc               ;600
0001d4  d101              BNE      |L13.474|
0001d6  2f02              CMP      r7,#2                 ;600
0001d8  d00d              BEQ      |L13.502|
                  |L13.474|
0001da  68e0              LDR      r0,[r4,#0xc]          ;617
0001dc  2800              CMP      r0,#0                 ;617
0001de  e001              B        |L13.484|
                  |L13.480|
0001e0  e12d              B        |L13.1086|
                  |L13.482|
0001e2  e09b              B        |L13.796|
                  |L13.484|
0001e4  6828              LDR      r0,[r5,#0]            ;640
0001e6  d01d              BEQ      |L13.548|
0001e8  f4407080          ORR      r0,r0,#0x100          ;620
0001ec  6028              STR      r0,[r5,#0]            ;620
0001ee  f7fffffe          BL       HAL_GetTick
0001f2  4607              MOV      r7,r0                 ;623
0001f4  e00b              B        |L13.526|
                  |L13.502|
0001f6  6828              LDR      r0,[r5,#0]            ;603
0001f8  0540              LSLS     r0,r0,#21             ;603
0001fa  d50b              BPL      |L13.532|
0001fc  68e0              LDR      r0,[r4,#0xc]          ;603
0001fe  2800              CMP      r0,#0                 ;603
000200  d0c1              BEQ      |L13.390|
000202  e007              B        |L13.532|
                  |L13.516|
000204  f7fffffe          BL       HAL_GetTick
000208  1bc0              SUBS     r0,r0,r7              ;628
00020a  2802              CMP      r0,#2                 ;628
00020c  d894              BHI      |L13.312|
                  |L13.526|
00020e  6828              LDR      r0,[r5,#0]            ;626
000210  0540              LSLS     r0,r0,#21             ;626
000212  d5f7              BPL      |L13.516|
                  |L13.532|
000214  6868              LDR      r0,[r5,#4]            ;635
000216  7c21              LDRB     r1,[r4,#0x10]         ;635
000218  f02050f8          BIC      r0,r0,#0x1f000000     ;635
00021c  ea406001          ORR      r0,r0,r1,LSL #24      ;635
000220  6068              STR      r0,[r5,#4]            ;635
000222  e00e              B        |L13.578|
                  |L13.548|
000224  f4207080          BIC      r0,r0,#0x100          ;640
000228  6028              STR      r0,[r5,#0]            ;640
00022a  f7fffffe          BL       HAL_GetTick
00022e  4607              MOV      r7,r0                 ;643
000230  e004              B        |L13.572|
                  |L13.562|
000232  f7fffffe          BL       HAL_GetTick
000236  1bc0              SUBS     r0,r0,r7              ;648
000238  2802              CMP      r0,#2                 ;648
00023a  d86f              BHI      |L13.796|
                  |L13.572|
00023c  6828              LDR      r0,[r5,#0]            ;646
00023e  0540              LSLS     r0,r0,#21             ;646
000240  d4f7              BMI      |L13.562|
                  |L13.578|
000242  7820              LDRB     r0,[r4,#0]            ;657
000244  0700              LSLS     r0,r0,#28             ;657
000246  d528              BPL      |L13.666|
000248  6960              LDR      r0,[r4,#0x14]         ;663
00024a  2800              CMP      r0,#0                 ;663
00024c  f8d50094          LDR      r0,[r5,#0x94]         ;722
000250  d012              BEQ      |L13.632|
000252  f0400001          ORR      r0,r0,#1              ;705
000256  f8c50094          STR      r0,[r5,#0x94]         ;705
00025a  f7fffffe          BL       HAL_GetTick
00025e  4607              MOV      r7,r0                 ;708
000260  e004              B        |L13.620|
                  |L13.610|
000262  f7fffffe          BL       HAL_GetTick
000266  1bc0              SUBS     r0,r0,r7              ;713
000268  2802              CMP      r0,#2                 ;713
00026a  d857              BHI      |L13.796|
                  |L13.620|
00026c  f8d50094          LDR      r0,[r5,#0x94]         ;711
000270  0780              LSLS     r0,r0,#30             ;711
000272  d5f6              BPL      |L13.610|
000274  e011              B        |L13.666|
                  |L13.630|
000276  e0e9              B        |L13.1100|
                  |L13.632|
000278  f0200001          BIC      r0,r0,#1              ;722
00027c  f8c50094          STR      r0,[r5,#0x94]         ;722
000280  f7fffffe          BL       HAL_GetTick
000284  4607              MOV      r7,r0                 ;725
000286  e004              B        |L13.658|
                  |L13.648|
000288  f7fffffe          BL       HAL_GetTick
00028c  1bc0              SUBS     r0,r0,r7              ;730
00028e  2802              CMP      r0,#2                 ;730
000290  d844              BHI      |L13.796|
                  |L13.658|
000292  f8d50094          LDR      r0,[r5,#0x94]         ;728
000296  0780              LSLS     r0,r0,#30             ;728
000298  d4f6              BMI      |L13.648|
                  |L13.666|
00029a  7820              LDRB     r0,[r4,#0]            ;738
00029c  0740              LSLS     r0,r0,#29             ;738
00029e  d566              BPL      |L13.878|
0002a0  6da8              LDR      r0,[r5,#0x58]         ;747
0002a2  f04f0800          MOV      r8,#0                 ;740
0002a6  00c0              LSLS     r0,r0,#3              ;747
0002a8  d409              BMI      |L13.702|
0002aa  6da8              LDR      r0,[r5,#0x58]         ;749
0002ac  f0405080          ORR      r0,r0,#0x10000000     ;749
0002b0  65a8              STR      r0,[r5,#0x58]         ;749
0002b2  6da8              LDR      r0,[r5,#0x58]         ;749
0002b4  f04f0801          MOV      r8,#1                 ;750
0002b8  f0005080          AND      r0,r0,#0x10000000     ;749
0002bc  9000              STR      r0,[sp,#0]            ;750
                  |L13.702|
0002be  4850              LDR      r0,|L13.1024|
0002c0  6801              LDR      r1,[r0,#0]            ;753
0002c2  05c9              LSLS     r1,r1,#23             ;753
0002c4  d411              BMI      |L13.746|
0002c6  6801              LDR      r1,[r0,#0]            ;756
0002c8  4681              MOV      r9,r0                 ;756
0002ca  f4417180          ORR      r1,r1,#0x100          ;756
0002ce  6001              STR      r1,[r0,#0]            ;756
0002d0  f7fffffe          BL       HAL_GetTick
0002d4  4607              MOV      r7,r0                 ;759
0002d6  e004              B        |L13.738|
                  |L13.728|
0002d8  f7fffffe          BL       HAL_GetTick
0002dc  1bc0              SUBS     r0,r0,r7              ;763
0002de  2802              CMP      r0,#2                 ;763
0002e0  d81c              BHI      |L13.796|
                  |L13.738|
0002e2  f8d90000          LDR      r0,[r9,#0]            ;761
0002e6  05c0              LSLS     r0,r0,#23             ;761
0002e8  d5f6              BPL      |L13.728|
                  |L13.746|
0002ea  68a0              LDR      r0,[r4,#8]            ;795
0002ec  2801              CMP      r0,#1                 ;795
0002ee  d016              BEQ      |L13.798|
0002f0  2805              CMP      r0,#5                 ;795
0002f2  f8d50090          LDR      r0,[r5,#0x90]         ;795
0002f6  d017              BEQ      |L13.808|
0002f8  f0200001          BIC      r0,r0,#1              ;795
0002fc  f8c50090          STR      r0,[r5,#0x90]         ;795
000300  f8d50090          LDR      r0,[r5,#0x90]         ;795
000304  f0200004          BIC      r0,r0,#4              ;795
                  |L13.776|
000308  f8c50090          STR      r0,[r5,#0x90]         ;795
00030c  68a0              LDR      r0,[r4,#8]            ;807
00030e  f2413988          MOV      r9,#0x1388            ;807
000312  b1c0              CBZ      r0,|L13.838|
000314  f7fffffe          BL       HAL_GetTick
000318  4607              MOV      r7,r0                 ;802
00031a  e00f              B        |L13.828|
                  |L13.796|
00031c  e069              B        |L13.1010|
                  |L13.798|
00031e  f8d50090          LDR      r0,[r5,#0x90]         ;795
000322  f0400001          ORR      r0,r0,#1              ;795
000326  e7ef              B        |L13.776|
                  |L13.808|
000328  f0400004          ORR      r0,r0,#4              ;795
00032c  f8c50090          STR      r0,[r5,#0x90]         ;795
000330  e7f5              B        |L13.798|
                  |L13.818|
000332  f7fffffe          BL       HAL_GetTick
000336  1bc1              SUBS     r1,r0,r7              ;807
000338  4549              CMP      r1,r9                 ;807
00033a  d87f              BHI      |L13.1084|
                  |L13.828|
00033c  f8d50090          LDR      r0,[r5,#0x90]         ;805
000340  0780              LSLS     r0,r0,#30             ;805
000342  d5f6              BPL      |L13.818|
000344  e00c              B        |L13.864|
                  |L13.838|
000346  f7fffffe          BL       HAL_GetTick
00034a  4607              MOV      r7,r0                 ;816
00034c  e004              B        |L13.856|
                  |L13.846|
00034e  f7fffffe          BL       HAL_GetTick
000352  1bc1              SUBS     r1,r0,r7              ;821
000354  4549              CMP      r1,r9                 ;821
000356  d871              BHI      |L13.1084|
                  |L13.856|
000358  f8d50090          LDR      r0,[r5,#0x90]         ;819
00035c  0780              LSLS     r0,r0,#30             ;819
00035e  d4f6              BMI      |L13.846|
                  |L13.864|
000360  f1b80f00          CMP      r8,#0                 ;834
000364  d003              BEQ      |L13.878|
000366  6da8              LDR      r0,[r5,#0x58]         ;836
000368  f0205080          BIC      r0,r0,#0x10000000     ;836
00036c  65a8              STR      r0,[r5,#0x58]         ;836
                  |L13.878|
00036e  6aa0              LDR      r0,[r4,#0x28]         ;887
000370  b3f0              CBZ      r0,|L13.1008|
000372  2e0c              CMP      r6,#0xc               ;890
000374  d06a              BEQ      |L13.1100|
000376  2802              CMP      r0,#2                 ;892
000378  6828              LDR      r0,[r5,#0]            ;950
00037a  f0207080          BIC      r0,r0,#0x1000000      ;950
00037e  6028              STR      r0,[r5,#0]            ;950
000380  d004              BEQ      |L13.908|
000382  6828              LDR      r0,[r5,#0]            ;954
000384  f0105f20          TST      r0,#0x28000000        ;954
000388  d047              BEQ      |L13.1050|
00038a  e04a              B        |L13.1058|
                  |L13.908|
00038c  f7fffffe          BL       HAL_GetTick
000390  4606              MOV      r6,r0                 ;908
000392  e004              B        |L13.926|
                  |L13.916|
000394  f7fffffe          BL       HAL_GetTick
000398  1b80              SUBS     r0,r0,r6              ;913
00039a  2802              CMP      r0,#2                 ;913
00039c  d84e              BHI      |L13.1084|
                  |L13.926|
00039e  6828              LDR      r0,[r5,#0]            ;911
0003a0  0180              LSLS     r0,r0,#6              ;911
0003a2  d4f7              BMI      |L13.916|
0003a4  6b20              LDR      r0,[r4,#0x30]         ;920
0003a6  6ae1              LDR      r1,[r4,#0x2c]         ;920
0003a8  0100              LSLS     r0,r0,#4              ;920
0003aa  3810              SUBS     r0,r0,#0x10           ;920
0003ac  4308              ORRS     r0,r0,r1              ;920
0003ae  6b61              LDR      r1,[r4,#0x34]         ;920
0003b0  6ba2              LDR      r2,[r4,#0x38]         ;920
0003b2  0209              LSLS     r1,r1,#8              ;920
0003b4  0912              LSRS     r2,r2,#4              ;920
0003b6  ea414142          ORR      r1,r1,r2,LSL #17      ;920
0003ba  4308              ORRS     r0,r0,r1              ;920
0003bc  8fa1              LDRH     r1,[r4,#0x3c]         ;920
0003be  4a11              LDR      r2,|L13.1028|
0003c0  0849              LSRS     r1,r1,#1              ;920
0003c2  eb025141          ADD      r1,r2,r1,LSL #21      ;920
0003c6  4308              ORRS     r0,r0,r1              ;920
0003c8  f8941040          LDRB     r1,[r4,#0x40]         ;920
0003cc  0849              LSRS     r1,r1,#1              ;920
0003ce  0112              LSLS     r2,r2,#4              ;920
0003d0  eb026141          ADD      r1,r2,r1,LSL #25      ;920
0003d4  4308              ORRS     r0,r0,r1              ;920
0003d6  60e8              STR      r0,[r5,#0xc]          ;920
0003d8  6828              LDR      r0,[r5,#0]            ;930
0003da  f0407080          ORR      r0,r0,#0x1000000      ;930
0003de  6028              STR      r0,[r5,#0]            ;930
0003e0  68e8              LDR      r0,[r5,#0xc]          ;933
0003e2  f0407080          ORR      r0,r0,#0x1000000      ;933
0003e6  60e8              STR      r0,[r5,#0xc]          ;933
0003e8  f7fffffe          BL       HAL_GetTick
0003ec  4604              MOV      r4,r0                 ;936
0003ee  e010              B        |L13.1042|
                  |L13.1008|
0003f0  e02a              B        |L13.1096|
                  |L13.1010|
0003f2  e023              B        |L13.1084|
                  |L13.1012|
                          DCD      0x40021000
                  |L13.1016|
                          DCD      AHBPrescTable
                  |L13.1020|
                          DCD      SystemCoreClock
                  |L13.1024|
                          DCD      0x40007000
                  |L13.1028|
                          DCD      0xffe00000
                  |L13.1032|
000408  f7fffffe          BL       HAL_GetTick
00040c  1b00              SUBS     r0,r0,r4              ;941
00040e  2802              CMP      r0,#2                 ;941
000410  d814              BHI      |L13.1084|
                  |L13.1042|
000412  6828              LDR      r0,[r5,#0]            ;939
000414  0180              LSLS     r0,r0,#6              ;939
000416  d5f7              BPL      |L13.1032|
000418  e016              B        |L13.1096|
                  |L13.1050|
00041a  68e8              LDR      r0,[r5,#0xc]          ;956
00041c  f0200003          BIC      r0,r0,#3              ;956
000420  60e8              STR      r0,[r5,#0xc]          ;956
                  |L13.1058|
000422  68e8              LDR      r0,[r5,#0xc]          ;968
000424  490a              LDR      r1,|L13.1104|
000426  4008              ANDS     r0,r0,r1              ;968
000428  60e8              STR      r0,[r5,#0xc]          ;968
00042a  f7fffffe          BL       HAL_GetTick
00042e  4604              MOV      r4,r0                 ;976
000430  e007              B        |L13.1090|
                  |L13.1074|
000432  f7fffffe          BL       HAL_GetTick
000436  1b00              SUBS     r0,r0,r4              ;981
000438  2802              CMP      r0,#2                 ;981
00043a  d902              BLS      |L13.1090|
                  |L13.1084|
00043c  2003              MOVS     r0,#3                 ;983
                  |L13.1086|
00043e  e8bd83f8          POP      {r3-r9,pc}
                  |L13.1090|
000442  6828              LDR      r0,[r5,#0]            ;979
000444  0180              LSLS     r0,r0,#6              ;979
000446  d4f4              BMI      |L13.1074|
                  |L13.1096|
000448  2000              MOVS     r0,#0                 ;993
00044a  e7f8              B        |L13.1086|
                  |L13.1100|
00044c  2001              MOVS     r0,#1                 ;990
00044e  e7f6              B        |L13.1086|
;;;995    
                          ENDP

                  |L13.1104|
                          DCD      0xfeeeffff

                          AREA ||i.RCC_SetFlashLatencyFromMSIRange||, CODE, READONLY, ALIGN=2

                  RCC_SetFlashLatencyFromMSIRange PROC
;;;1705     */
;;;1706   static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1707   {
;;;1708     uint32_t vos;
;;;1709     uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
;;;1710   
;;;1711     if(__HAL_RCC_PWR_IS_CLK_ENABLED())
000002  4e1c              LDR      r6,|L14.116|
000004  4605              MOV      r5,r0                 ;1707
000006  2400              MOVS     r4,#0                 ;1709
000008  6db0              LDR      r0,[r6,#0x58]
00000a  00c0              LSLS     r0,r0,#3
00000c  d502              BPL      |L14.20|
;;;1712     {
;;;1713       vos = HAL_PWREx_GetVoltageRange();
00000e  f7fffffe          BL       HAL_PWREx_GetVoltageRange
000012  e00d              B        |L14.48|
                  |L14.20|
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       __HAL_RCC_PWR_CLK_ENABLE();
000014  6db0              LDR      r0,[r6,#0x58]
000016  f0405080          ORR      r0,r0,#0x10000000
00001a  65b0              STR      r0,[r6,#0x58]
00001c  6db0              LDR      r0,[r6,#0x58]
00001e  f0005080          AND      r0,r0,#0x10000000
;;;1718       vos = HAL_PWREx_GetVoltageRange();
000022  9000              STR      r0,[sp,#0]
000024  f7fffffe          BL       HAL_PWREx_GetVoltageRange
;;;1719       __HAL_RCC_PWR_CLK_DISABLE();
000028  6db1              LDR      r1,[r6,#0x58]
00002a  f0215180          BIC      r1,r1,#0x10000000
00002e  65b1              STR      r1,[r6,#0x58]
                  |L14.48|
;;;1720     }
;;;1721   
;;;1722     if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
000030  f5b07f00          CMP      r0,#0x200
000034  d004              BEQ      |L14.64|
;;;1723     {
;;;1724       if(msirange > RCC_MSIRANGE_8)
;;;1725       {
;;;1726         /* MSI > 16Mhz */
;;;1727         if(msirange > RCC_MSIRANGE_10)
;;;1728         {
;;;1729           /* MSI 48Mhz */
;;;1730           latency = FLASH_LATENCY_2; /* 2WS */
;;;1731         }
;;;1732         else
;;;1733         {
;;;1734           /* MSI 24Mhz or 32Mhz */
;;;1735           latency = FLASH_LATENCY_1; /* 1WS */
;;;1736         }
;;;1737       }
;;;1738       /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
;;;1739     }
;;;1740     else
;;;1741     {
;;;1742   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1743       if(msirange >= RCC_MSIRANGE_8)
;;;1744       {
;;;1745         /* MSI >= 16Mhz */
;;;1746         latency = FLASH_LATENCY_2; /* 2WS */
;;;1747       }
;;;1748       else
;;;1749       {
;;;1750         if(msirange == RCC_MSIRANGE_7)
;;;1751         {
;;;1752           /* MSI 8Mhz */
;;;1753           latency = FLASH_LATENCY_1; /* 1WS */
;;;1754         }
;;;1755         /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
;;;1756       }
;;;1757   #else
;;;1758       if(msirange > RCC_MSIRANGE_8)
000036  2d80              CMP      r5,#0x80
000038  d907              BLS      |L14.74|
;;;1759       {
;;;1760         /* MSI > 16Mhz */
;;;1761         latency = FLASH_LATENCY_3; /* 3WS */
00003a  f04f0403          MOV      r4,#3
00003e  e00a              B        |L14.86|
                  |L14.64|
000040  2d80              CMP      r5,#0x80              ;1724
000042  d908              BLS      |L14.86|
000044  2da0              CMP      r5,#0xa0              ;1727
000046  d801              BHI      |L14.76|
000048  e004              B        |L14.84|
                  |L14.74|
;;;1762       }
;;;1763       else
;;;1764       {
;;;1765         if(msirange == RCC_MSIRANGE_8)
00004a  d101              BNE      |L14.80|
                  |L14.76|
;;;1766         {
;;;1767           /* MSI 16Mhz */
;;;1768           latency = FLASH_LATENCY_2; /* 2WS */
00004c  2402              MOVS     r4,#2
00004e  e002              B        |L14.86|
                  |L14.80|
;;;1769         }
;;;1770         else if(msirange == RCC_MSIRANGE_7)
000050  2d70              CMP      r5,#0x70
000052  d100              BNE      |L14.86|
                  |L14.84|
;;;1771         {
;;;1772           /* MSI 8Mhz */
;;;1773           latency = FLASH_LATENCY_1; /* 1WS */
000054  2401              MOVS     r4,#1
                  |L14.86|
;;;1774         }
;;;1775         /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
;;;1776       }
;;;1777   #endif
;;;1778     }
;;;1779   
;;;1780     __HAL_FLASH_SET_LATENCY(latency);
000056  4808              LDR      r0,|L14.120|
000058  6801              LDR      r1,[r0,#0]
00005a  f0210107          BIC      r1,r1,#7
00005e  4321              ORRS     r1,r1,r4
000060  6001              STR      r1,[r0,#0]
;;;1781   
;;;1782     /* Check that the new number of wait states is taken into account to access the Flash
;;;1783        memory by reading the FLASH_ACR register */
;;;1784     if(__HAL_FLASH_GET_LATENCY() != latency)
000062  6800              LDR      r0,[r0,#0]
000064  f0000007          AND      r0,r0,#7
000068  42a0              CMP      r0,r4
00006a  d001              BEQ      |L14.112|
;;;1785     {
;;;1786       return HAL_ERROR;
00006c  2001              MOVS     r0,#1
;;;1787     }
;;;1788   
;;;1789     return HAL_OK;
;;;1790   }
00006e  bdf8              POP      {r3-r7,pc}
                  |L14.112|
000070  2000              MOVS     r0,#0                 ;1789
000072  bdf8              POP      {r3-r7,pc}
;;;1791   
                          ENDP

                  |L14.116|
                          DCD      0x40021000
                  |L14.120|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____RRX|
#line 587
|__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
