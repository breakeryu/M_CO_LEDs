; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal_usart.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal_usart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal_usart.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_USART_Abort PROC
;;;1890   */
;;;1891   HAL_StatusTypeDef HAL_USART_Abort(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1892   {
000002  4604              MOV      r4,r0
;;;1893   #if defined(USART_CR1_FIFOEN)
;;;1894     /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1895     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
;;;1896     CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
;;;1897   #else
;;;1898     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  6001              STR      r1,[r0,#0]
;;;1899     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;1900   #endif
;;;1901   
;;;1902     /* Disable the USART DMA Tx request if enabled */
;;;1903     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6881              LDR      r1,[r0,#8]
;;;1904     {
;;;1905       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1906   
;;;1907       /* Abort the USART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1908       if (husart->hdmatx != NULL)
;;;1909       {
;;;1910         /* Set the USART DMA Abort callback to Null.
;;;1911            No call back execution at end of DMA abort procedure */
;;;1912         husart->hdmatx->XferAbortCallback = NULL;
;;;1913   
;;;1914         if (HAL_DMA_Abort(husart->hdmatx) != HAL_OK)
;;;1915         {
;;;1916           if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
;;;1917           {
;;;1918             /* Set error code to DMA */
;;;1919             husart->ErrorCode = HAL_USART_ERROR_DMA;
00001c  f04f0610          MOV      r6,#0x10
000020  0609              LSLS     r1,r1,#24             ;1903
000022  f04f0500          MOV      r5,#0
000026  d50f              BPL      |L1.72|
000028  6881              LDR      r1,[r0,#8]            ;1905
00002a  f0210180          BIC      r1,r1,#0x80           ;1905
00002e  6081              STR      r1,[r0,#8]            ;1905
000030  6c20              LDR      r0,[r4,#0x40]         ;1908
000032  b148              CBZ      r0,|L1.72|
000034  6385              STR      r5,[r0,#0x38]         ;1914
000036  6c20              LDR      r0,[r4,#0x40]         ;1914
000038  f7fffffe          BL       HAL_DMA_Abort
00003c  b120              CBZ      r0,|L1.72|
00003e  6c20              LDR      r0,[r4,#0x40]         ;1916
000040  f7fffffe          BL       HAL_DMA_GetError
000044  2820              CMP      r0,#0x20              ;1916
000046  d023              BEQ      |L1.144|
                  |L1.72|
;;;1920   
;;;1921             /* Process Unlocked */
;;;1922             __HAL_UNLOCK(husart);
;;;1923   
;;;1924             return HAL_TIMEOUT;
;;;1925           }
;;;1926         }
;;;1927       }
;;;1928     }
;;;1929   
;;;1930     /* Disable the USART DMA Rx request if enabled */
;;;1931     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000048  6820              LDR      r0,[r4,#0]
00004a  6881              LDR      r1,[r0,#8]
00004c  0649              LSLS     r1,r1,#25
00004e  d50f              BPL      |L1.112|
;;;1932     {
;;;1933       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000050  6881              LDR      r1,[r0,#8]
000052  f0210140          BIC      r1,r1,#0x40
000056  6081              STR      r1,[r0,#8]
;;;1934   
;;;1935       /* Abort the USART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1936       if (husart->hdmarx != NULL)
000058  6c60              LDR      r0,[r4,#0x44]
00005a  b148              CBZ      r0,|L1.112|
;;;1937       {
;;;1938         /* Set the USART DMA Abort callback to Null.
;;;1939            No call back execution at end of DMA abort procedure */
;;;1940         husart->hdmarx->XferAbortCallback = NULL;
;;;1941   
;;;1942         if (HAL_DMA_Abort(husart->hdmarx) != HAL_OK)
00005c  6385              STR      r5,[r0,#0x38]
00005e  6c60              LDR      r0,[r4,#0x44]
000060  f7fffffe          BL       HAL_DMA_Abort
000064  b120              CBZ      r0,|L1.112|
;;;1943         {
;;;1944           if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
000066  6c60              LDR      r0,[r4,#0x44]
000068  f7fffffe          BL       HAL_DMA_GetError
00006c  2820              CMP      r0,#0x20
00006e  d00f              BEQ      |L1.144|
                  |L1.112|
;;;1945           {
;;;1946             /* Set error code to DMA */
;;;1947             husart->ErrorCode = HAL_USART_ERROR_DMA;
;;;1948   
;;;1949             /* Process Unlocked */
;;;1950             __HAL_UNLOCK(husart);
;;;1951   
;;;1952             return HAL_TIMEOUT;
;;;1953           }
;;;1954         }
;;;1955       }
;;;1956     }
;;;1957   
;;;1958     /* Reset Tx and Rx transfer counters */
;;;1959     husart->TxXferCount = 0U;
000070  8565              STRH     r5,[r4,#0x2a]
;;;1960     husart->RxXferCount = 0U;
000072  8665              STRH     r5,[r4,#0x32]
;;;1961   
;;;1962     /* Clear the Error flags in the ICR register */
;;;1963     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
000074  6821              LDR      r1,[r4,#0]
000076  200f              MOVS     r0,#0xf
000078  6208              STR      r0,[r1,#0x20]
;;;1964   
;;;1965   #if defined(USART_CR1_FIFOEN)
;;;1966     /* Flush the whole TX FIFO (if needed) */
;;;1967     if (husart->FifoMode == USART_FIFOMODE_ENABLE)
;;;1968     {
;;;1969       __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
;;;1970     }
;;;1971   #endif
;;;1972   
;;;1973     /* Discard the received data */
;;;1974     __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
00007a  6820              LDR      r0,[r4,#0]
00007c  8b01              LDRH     r1,[r0,#0x18]
00007e  f0410108          ORR      r1,r1,#8
000082  8301              STRH     r1,[r0,#0x18]
;;;1975   
;;;1976     /* Restore husart->State to Ready */
;;;1977     husart->State  = HAL_USART_STATE_READY;
000084  2001              MOVS     r0,#1
000086  f8840049          STRB     r0,[r4,#0x49]
;;;1978   
;;;1979     /* Reset Handle ErrorCode to No Error */
;;;1980     husart->ErrorCode = HAL_USART_ERROR_NONE;
00008a  64e5              STR      r5,[r4,#0x4c]
;;;1981   
;;;1982     return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;1983   }
00008e  bd70              POP      {r4-r6,pc}
                  |L1.144|
000090  64e6              STR      r6,[r4,#0x4c]         ;1947
000092  f8845048          STRB     r5,[r4,#0x48]         ;1950
000096  2003              MOVS     r0,#3                 ;1952
000098  bd70              POP      {r4-r6,pc}
;;;1984   
                          ENDP


                          AREA ||i.HAL_USART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_AbortCpltCallback PROC
;;;2493     */
;;;2494   __weak void HAL_USART_AbortCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2495   {
;;;2496     /* Prevent unused argument(s) compilation warning */
;;;2497     UNUSED(husart);
;;;2498   
;;;2499     /* NOTE : This function should not be modified, when the callback is needed,
;;;2500               the HAL_USART_AbortCpltCallback can be implemented in the user file.
;;;2501      */
;;;2502   }
;;;2503   
                          ENDP


                          AREA ||i.HAL_USART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Abort_IT PROC
;;;1998   */
;;;1999   HAL_StatusTypeDef HAL_USART_Abort_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;2000   {
000002  4604              MOV      r4,r0
;;;2001     uint32_t abortcplt = 1U;
;;;2002   
;;;2003   #if defined(USART_CR1_FIFOEN)
;;;2004     /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2005     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
;;;2006     CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
;;;2007   #else
;;;2008     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;2001
000008  6801              LDR      r1,[r0,#0]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  6001              STR      r1,[r0,#0]
;;;2009     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  f0210101          BIC      r1,r1,#1
000018  6081              STR      r1,[r0,#8]
00001a  6c20              LDR      r0,[r4,#0x40]         ;2000
;;;2010   #endif
;;;2011   
;;;2012     /* If DMA Tx and/or DMA Rx Handles are associated to USART Handle, DMA Abort complete callbacks should be initialised
;;;2013        before any call to DMA Abort functions */
;;;2014     /* DMA Tx Handle is valid */
;;;2015     if (husart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L3.48|
;;;2016     {
;;;2017       /* Set DMA Abort Complete callback if USART DMA Tx request if enabled.
;;;2018          Otherwise, set it to NULL */
;;;2019       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6889              LDR      r1,[r1,#8]
000024  0609              LSLS     r1,r1,#24
000026  d502              BPL      |L3.46|
;;;2020       {
;;;2021         husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
000028  4921              LDR      r1,|L3.176|
00002a  6381              STR      r1,[r0,#0x38]
00002c  e000              B        |L3.48|
                  |L3.46|
;;;2022       }
;;;2023       else
;;;2024       {
;;;2025         husart->hdmatx->XferAbortCallback = NULL;
00002e  6385              STR      r5,[r0,#0x38]
                  |L3.48|
;;;2026       }
;;;2027     }
;;;2028     /* DMA Rx Handle is valid */
;;;2029     if (husart->hdmarx != NULL)
000030  6c60              LDR      r0,[r4,#0x44]
000032  b138              CBZ      r0,|L3.68|
;;;2030     {
;;;2031       /* Set DMA Abort Complete callback if USART DMA Rx request if enabled.
;;;2032          Otherwise, set it to NULL */
;;;2033       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6889              LDR      r1,[r1,#8]
000038  0649              LSLS     r1,r1,#25
00003a  d502              BPL      |L3.66|
;;;2034       {
;;;2035         husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
00003c  491d              LDR      r1,|L3.180|
00003e  6381              STR      r1,[r0,#0x38]
000040  e000              B        |L3.68|
                  |L3.66|
;;;2036       }
;;;2037       else
;;;2038       {
;;;2039         husart->hdmarx->XferAbortCallback = NULL;
000042  6385              STR      r5,[r0,#0x38]
                  |L3.68|
;;;2040       }
;;;2041     }
;;;2042   
;;;2043     /* Disable the USART DMA Tx request if enabled */
;;;2044     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6881              LDR      r1,[r0,#8]
000048  0609              LSLS     r1,r1,#24
00004a  d50c              BPL      |L3.102|
;;;2045     {
;;;2046       /* Disable DMA Tx at USART level */
;;;2047       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00004c  6881              LDR      r1,[r0,#8]
00004e  f0210180          BIC      r1,r1,#0x80
000052  6081              STR      r1,[r0,#8]
;;;2048   
;;;2049       /* Abort the USART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;2050       if (husart->hdmatx != NULL)
000054  6c20              LDR      r0,[r4,#0x40]
000056  b130              CBZ      r0,|L3.102|
;;;2051       {
;;;2052         /* USART Tx DMA Abort callback has already been initialised :
;;;2053            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;2054   
;;;2055         /* Abort DMA TX */
;;;2056         if (HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  b110              CBZ      r0,|L3.100|
;;;2057         {
;;;2058           husart->hdmatx->XferAbortCallback = NULL;
00005e  6c20              LDR      r0,[r4,#0x40]
000060  6385              STR      r5,[r0,#0x38]
000062  e000              B        |L3.102|
                  |L3.100|
;;;2059         }
;;;2060         else
;;;2061         {
;;;2062           abortcplt = 0U;
000064  2600              MOVS     r6,#0
                  |L3.102|
;;;2063         }
;;;2064       }
;;;2065     }
;;;2066   
;;;2067     /* Disable the USART DMA Rx request if enabled */
;;;2068     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000066  6820              LDR      r0,[r4,#0]
000068  6881              LDR      r1,[r0,#8]
00006a  0649              LSLS     r1,r1,#25
00006c  d50b              BPL      |L3.134|
;;;2069     {
;;;2070       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00006e  6881              LDR      r1,[r0,#8]
000070  f0210140          BIC      r1,r1,#0x40
000074  6081              STR      r1,[r0,#8]
;;;2071   
;;;2072       /* Abort the USART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;2073       if (husart->hdmarx != NULL)
000076  6c60              LDR      r0,[r4,#0x44]
000078  b128              CBZ      r0,|L3.134|
;;;2074       {
;;;2075         /* USART Rx DMA Abort callback has already been initialised :
;;;2076            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;2077   
;;;2078         /* Abort DMA RX */
;;;2079         if (HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
00007a  f7fffffe          BL       HAL_DMA_Abort_IT
00007e  b1a0              CBZ      r0,|L3.170|
;;;2080         {
;;;2081           husart->hdmarx->XferAbortCallback = NULL;
000080  6c60              LDR      r0,[r4,#0x44]
;;;2082           abortcplt = 1U;
000082  6385              STR      r5,[r0,#0x38]
000084  e000              B        |L3.136|
                  |L3.134|
;;;2083         }
;;;2084         else
;;;2085         {
;;;2086           abortcplt = 0U;
;;;2087         }
;;;2088       }
;;;2089     }
;;;2090   
;;;2091     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;2092     if (abortcplt == 1U)
000086  b186              CBZ      r6,|L3.170|
                  |L3.136|
;;;2093     {
;;;2094       /* Reset Tx and Rx transfer counters */
;;;2095       husart->TxXferCount = 0U;
000088  8565              STRH     r5,[r4,#0x2a]
;;;2096       husart->RxXferCount = 0U;
00008a  8665              STRH     r5,[r4,#0x32]
;;;2097   
;;;2098       /* Reset errorCode */
;;;2099       husart->ErrorCode = HAL_USART_ERROR_NONE;
00008c  64e5              STR      r5,[r4,#0x4c]
;;;2100   
;;;2101       /* Clear the Error flags in the ICR register */
;;;2102       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
00008e  6821              LDR      r1,[r4,#0]
000090  200f              MOVS     r0,#0xf
000092  6208              STR      r0,[r1,#0x20]
;;;2103   
;;;2104   #if defined(USART_CR1_FIFOEN)
;;;2105       /* Flush the whole TX FIFO (if needed) */
;;;2106       if (husart->FifoMode == USART_FIFOMODE_ENABLE)
;;;2107       {
;;;2108         __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
;;;2109       }
;;;2110   #endif
;;;2111   
;;;2112       /* Discard the received data */
;;;2113       __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
000094  6820              LDR      r0,[r4,#0]
000096  8b01              LDRH     r1,[r0,#0x18]
000098  f0410108          ORR      r1,r1,#8
00009c  8301              STRH     r1,[r0,#0x18]
;;;2114   
;;;2115       /* Restore husart->State to Ready */
;;;2116       husart->State  = HAL_USART_STATE_READY;
00009e  2001              MOVS     r0,#1
0000a0  f8840049          STRB     r0,[r4,#0x49]
;;;2117   
;;;2118       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2119   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2120       /* Call registered Abort Complete Callback */
;;;2121       husart->AbortCpltCallback(husart);
;;;2122   #else
;;;2123       /* Call legacy weak Abort Complete Callback */
;;;2124       HAL_USART_AbortCpltCallback(husart);
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L3.170|
;;;2125   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2126     }
;;;2127   
;;;2128     return HAL_OK;
0000aa  2000              MOVS     r0,#0
;;;2129   }
0000ac  bd70              POP      {r4-r6,pc}
;;;2130   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L3.176|
                          DCD      USART_DMATxAbortCallback
                  |L3.180|
                          DCD      USART_DMARxAbortCallback

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1733     */
;;;1734   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  f8902049          LDRB     r2,[r0,#0x49]
;;;1735   {
;;;1736     const HAL_USART_StateTypeDef state = husart->State;
;;;1737   
;;;1738     /* Process Locked */
;;;1739     __HAL_LOCK(husart);
000004  f8901048          LDRB     r1,[r0,#0x48]
000008  2901              CMP      r1,#1
00000a  d00d              BEQ      |L4.40|
00000c  2101              MOVS     r1,#1
00000e  f8801048          STRB     r1,[r0,#0x48]
;;;1740   
;;;1741     if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)) &&
000012  6801              LDR      r1,[r0,#0]
000014  688b              LDR      r3,[r1,#8]
000016  061b              LSLS     r3,r3,#24
000018  d501              BPL      |L4.30|
;;;1742         (state == HAL_USART_STATE_BUSY_TX))
00001a  2a12              CMP      r2,#0x12
00001c  d006              BEQ      |L4.44|
                  |L4.30|
;;;1743     {
;;;1744       /* Disable the USART DMA Tx request */
;;;1745       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1746     }
;;;1747     else if ((state == HAL_USART_STATE_BUSY_RX) ||
00001e  2a22              CMP      r2,#0x22
000020  d008              BEQ      |L4.52|
;;;1748              (state == HAL_USART_STATE_BUSY_TX_RX))
000022  2a32              CMP      r2,#0x32
000024  d006              BEQ      |L4.52|
000026  e01e              B        |L4.102|
                  |L4.40|
000028  2002              MOVS     r0,#2                 ;1739
;;;1749     {
;;;1750       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
;;;1751       {
;;;1752         /* Disable the USART DMA Tx request */
;;;1753         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1754       }
;;;1755       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1756       {
;;;1757         /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1758         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1759         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1760   
;;;1761         /* Disable the USART DMA Rx request */
;;;1762         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1763       }
;;;1764     }
;;;1765     else
;;;1766     {
;;;1767       /* Nothing to do */
;;;1768     }
;;;1769   
;;;1770     /* Process Unlocked */
;;;1771     __HAL_UNLOCK(husart);
;;;1772   
;;;1773     return HAL_OK;
;;;1774   }
00002a  4770              BX       lr
                  |L4.44|
00002c  688a              LDR      r2,[r1,#8]            ;1745
00002e  f0220280          BIC      r2,r2,#0x80           ;1745
000032  e017              B        |L4.100|
                  |L4.52|
000034  688a              LDR      r2,[r1,#8]            ;1750
000036  0612              LSLS     r2,r2,#24             ;1750
000038  d503              BPL      |L4.66|
00003a  688a              LDR      r2,[r1,#8]            ;1753
00003c  f0220280          BIC      r2,r2,#0x80           ;1753
000040  608a              STR      r2,[r1,#8]            ;1753
                  |L4.66|
000042  6801              LDR      r1,[r0,#0]            ;1755
000044  688a              LDR      r2,[r1,#8]            ;1755
000046  0652              LSLS     r2,r2,#25             ;1755
000048  d50d              BPL      |L4.102|
00004a  680a              LDR      r2,[r1,#0]            ;1758
00004c  f4227280          BIC      r2,r2,#0x100          ;1758
000050  600a              STR      r2,[r1,#0]            ;1758
000052  6801              LDR      r1,[r0,#0]            ;1759
000054  688a              LDR      r2,[r1,#8]            ;1759
000056  f0220201          BIC      r2,r2,#1              ;1759
00005a  608a              STR      r2,[r1,#8]            ;1759
00005c  6801              LDR      r1,[r0,#0]            ;1762
00005e  688a              LDR      r2,[r1,#8]            ;1762
000060  f0220240          BIC      r2,r2,#0x40           ;1762
                  |L4.100|
000064  608a              STR      r2,[r1,#8]            ;1762
                  |L4.102|
000066  2100              MOVS     r1,#0                 ;1771
000068  f8801048          STRB     r1,[r0,#0x48]         ;1771
00006c  4608              MOV      r0,r1                 ;1773
00006e  4770              BX       lr
;;;1775   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1780     */
;;;1781   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  f8901049          LDRB     r1,[r0,#0x49]
;;;1782   {
;;;1783     const HAL_USART_StateTypeDef state = husart->State;
;;;1784   
;;;1785     /* Process Locked */
;;;1786     __HAL_LOCK(husart);
000004  f8902048          LDRB     r2,[r0,#0x48]
000008  2a01              CMP      r2,#1
00000a  d009              BEQ      |L5.32|
00000c  2201              MOVS     r2,#1
00000e  f8802048          STRB     r2,[r0,#0x48]
;;;1787   
;;;1788     if (state == HAL_USART_STATE_BUSY_TX)
000012  2912              CMP      r1,#0x12
000014  d006              BEQ      |L5.36|
;;;1789     {
;;;1790       /* Enable the USART DMA Tx request */
;;;1791       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1792     }
;;;1793     else if ((state == HAL_USART_STATE_BUSY_RX) ||
000016  2922              CMP      r1,#0x22
000018  d00e              BEQ      |L5.56|
;;;1794              (state == HAL_USART_STATE_BUSY_TX_RX))
00001a  2932              CMP      r1,#0x32
00001c  d00c              BEQ      |L5.56|
00001e  e006              B        |L5.46|
                  |L5.32|
000020  2002              MOVS     r0,#2                 ;1786
;;;1795     {
;;;1796       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1797       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF);
;;;1798   
;;;1799       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1800       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1801       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1802   
;;;1803       /* Enable the USART DMA Rx request  before the DMA Tx request */
;;;1804       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1805   
;;;1806       /* Enable the USART DMA Tx request */
;;;1807       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1808     }
;;;1809     else
;;;1810     {
;;;1811       /* Nothing to do */
;;;1812     }
;;;1813   
;;;1814     /* Process Unlocked */
;;;1815     __HAL_UNLOCK(husart);
;;;1816   
;;;1817     return HAL_OK;
;;;1818   }
000022  4770              BX       lr
                  |L5.36|
000024  6801              LDR      r1,[r0,#0]            ;1791
000026  688a              LDR      r2,[r1,#8]            ;1791
000028  f0420280          ORR      r2,r2,#0x80           ;1791
00002c  608a              STR      r2,[r1,#8]            ;1791
                  |L5.46|
00002e  2100              MOVS     r1,#0                 ;1815
000030  f8801048          STRB     r1,[r0,#0x48]         ;1815
000034  4608              MOV      r0,r1                 ;1817
000036  4770              BX       lr
                  |L5.56|
000038  6802              LDR      r2,[r0,#0]            ;1797
00003a  2108              MOVS     r1,#8                 ;1797
00003c  6211              STR      r1,[r2,#0x20]         ;1797
00003e  6801              LDR      r1,[r0,#0]            ;1800
000040  680a              LDR      r2,[r1,#0]            ;1800
000042  f4427280          ORR      r2,r2,#0x100          ;1800
000046  600a              STR      r2,[r1,#0]            ;1800
000048  6801              LDR      r1,[r0,#0]            ;1801
00004a  688a              LDR      r2,[r1,#8]            ;1801
00004c  f0420201          ORR      r2,r2,#1              ;1801
000050  608a              STR      r2,[r1,#8]            ;1801
000052  6801              LDR      r1,[r0,#0]            ;1804
000054  688a              LDR      r2,[r1,#8]            ;1804
000056  f0420240          ORR      r2,r2,#0x40           ;1804
00005a  608a              STR      r2,[r1,#8]            ;1804
00005c  e7e2              B        |L5.36|
;;;1819   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1824     */
;;;1825   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1826   {
000002  4604              MOV      r4,r0
;;;1827     /* The Lock is not implemented on this API to allow the user application
;;;1828        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback() /
;;;1829        HAL_USART_TxHalfCpltCallback / HAL_USART_RxHalfCpltCallback:
;;;1830        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1831        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1832        the stream and the corresponding call back is executed. */
;;;1833   
;;;1834     /* Disable the USART Tx/Rx DMA requests */
;;;1835     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000004  6800              LDR      r0,[r0,#0]
000006  6881              LDR      r1,[r0,#8]
000008  f0210180          BIC      r1,r1,#0x80
00000c  6081              STR      r1,[r0,#8]
;;;1836     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210140          BIC      r1,r1,#0x40
000016  6081              STR      r1,[r0,#8]
;;;1837   
;;;1838     /* Abort the USART DMA tx channel */
;;;1839     if (husart->hdmatx != NULL)
000018  2500              MOVS     r5,#0
00001a  6c20              LDR      r0,[r4,#0x40]         ;1826
;;;1840     {
;;;1841       if (HAL_DMA_Abort(husart->hdmatx) != HAL_OK)
;;;1842       {
;;;1843         if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
;;;1844         {
;;;1845           /* Set error code to DMA */
;;;1846           husart->ErrorCode = HAL_USART_ERROR_DMA;
00001c  2610              MOVS     r6,#0x10
00001e  b138              CBZ      r0,|L6.48|
000020  f7fffffe          BL       HAL_DMA_Abort
000024  b120              CBZ      r0,|L6.48|
000026  6c20              LDR      r0,[r4,#0x40]         ;1843
000028  f7fffffe          BL       HAL_DMA_GetError
00002c  2820              CMP      r0,#0x20              ;1843
00002e  d011              BEQ      |L6.84|
                  |L6.48|
;;;1847   
;;;1848           /* Process Unlocked */
;;;1849           __HAL_UNLOCK(husart);
;;;1850   
;;;1851           return HAL_TIMEOUT;
;;;1852         }
;;;1853       }
;;;1854     }
;;;1855     /* Abort the USART DMA rx channel */
;;;1856     if (husart->hdmarx != NULL)
000030  6c60              LDR      r0,[r4,#0x44]
000032  b138              CBZ      r0,|L6.68|
;;;1857     {
;;;1858       if (HAL_DMA_Abort(husart->hdmarx) != HAL_OK)
000034  f7fffffe          BL       HAL_DMA_Abort
000038  b120              CBZ      r0,|L6.68|
;;;1859       {
;;;1860         if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
00003a  6c60              LDR      r0,[r4,#0x44]
00003c  f7fffffe          BL       HAL_DMA_GetError
000040  2820              CMP      r0,#0x20
000042  d007              BEQ      |L6.84|
                  |L6.68|
;;;1861         {
;;;1862           /* Set error code to DMA */
;;;1863           husart->ErrorCode = HAL_USART_ERROR_DMA;
;;;1864   
;;;1865           /* Process Unlocked */
;;;1866           __HAL_UNLOCK(husart);
;;;1867   
;;;1868           return HAL_TIMEOUT;
;;;1869         }
;;;1870       }
;;;1871     }
;;;1872   
;;;1873     USART_EndTransfer(husart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       USART_EndTransfer
;;;1874     husart->State = HAL_USART_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f8840049          STRB     r0,[r4,#0x49]
;;;1875   
;;;1876     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1877   }
000052  bd70              POP      {r4-r6,pc}
                  |L6.84|
000054  64e6              STR      r6,[r4,#0x4c]         ;1863
000056  f8845048          STRB     r5,[r4,#0x48]         ;1866
00005a  2003              MOVS     r0,#3                 ;1868
00005c  bd70              POP      {r4-r6,pc}
;;;1878   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;361      */
;;;362    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;363    {
000002  0004              MOVS     r4,r0
000004  d013              BEQ      |L7.46|
;;;364      /* Check the USART handle allocation */
;;;365      if (husart == NULL)
;;;366      {
;;;367        return HAL_ERROR;
;;;368      }
;;;369    
;;;370      /* Check the parameters */
;;;371      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;372    
;;;373      husart->State = HAL_USART_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  f8840049          STRB     r0,[r4,#0x49]
;;;374    
;;;375      husart->Instance->CR1 = 0x0U;
00000c  6820              LDR      r0,[r4,#0]
00000e  2500              MOVS     r5,#0
000010  6005              STR      r5,[r0,#0]
;;;376      husart->Instance->CR2 = 0x0U;
000012  6820              LDR      r0,[r4,#0]
000014  6045              STR      r5,[r0,#4]
;;;377      husart->Instance->CR3 = 0x0U;
000016  6820              LDR      r0,[r4,#0]
000018  6085              STR      r5,[r0,#8]
;;;378    
;;;379    #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;380      if (husart->MspDeInitCallback == NULL)
;;;381      {
;;;382        husart->MspDeInitCallback = HAL_USART_MspDeInit;
;;;383      }
;;;384      /* DeInit the low level hardware */
;;;385      husart->MspDeInitCallback(husart);
;;;386    #else
;;;387      /* DeInit the low level hardware */
;;;388      HAL_USART_MspDeInit(husart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       HAL_USART_MspDeInit
;;;389    #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;390    
;;;391      husart->ErrorCode = HAL_USART_ERROR_NONE;
000020  64e5              STR      r5,[r4,#0x4c]
;;;392      husart->State = HAL_USART_STATE_RESET;
000022  f8845049          STRB     r5,[r4,#0x49]
;;;393    
;;;394      /* Process Unlock */
;;;395      __HAL_UNLOCK(husart);
000026  f8845048          STRB     r5,[r4,#0x48]
;;;396    
;;;397      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;398    }
00002c  bd70              POP      {r4-r6,pc}
                  |L7.46|
00002e  2001              MOVS     r0,#1                 ;367
000030  bd70              POP      {r4-r6,pc}
;;;399    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;2478     */
;;;2479   __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2480   {
;;;2481     /* Prevent unused argument(s) compilation warning */
;;;2482     UNUSED(husart);
;;;2483   
;;;2484     /* NOTE : This function should not be modified, when the callback is needed,
;;;2485               the HAL_USART_ErrorCallback can be implemented in the user file.
;;;2486      */
;;;2487   }
;;;2488   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;2541     */
;;;2542   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  6cc0              LDR      r0,[r0,#0x4c]
;;;2543   {
;;;2544     return husart->ErrorCode;
;;;2545   }
000002  4770              BX       lr
;;;2546   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;2530     */
;;;2531   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  f8900049          LDRB     r0,[r0,#0x49]
;;;2532   {
;;;2533     return husart->State;
;;;2534   }
000004  4770              BX       lr
;;;2535   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_USART_IRQHandler PROC
;;;2135     */
;;;2136   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2137   {
;;;2138     uint32_t isrflags   = READ_REG(husart->Instance->ISR);
000004  6802              LDR      r2,[r0,#0]
000006  4604              MOV      r4,r0                 ;2137
000008  69d0              LDR      r0,[r2,#0x1c]
;;;2139     uint32_t cr1its     = READ_REG(husart->Instance->CR1);
00000a  6811              LDR      r1,[r2,#0]
;;;2140     uint32_t cr3its     = READ_REG(husart->Instance->CR3);
00000c  6893              LDR      r3,[r2,#8]
;;;2141   
;;;2142     uint32_t errorflags;
;;;2143     uint32_t errorcode;
;;;2144   
;;;2145     /* If no error occurs */
;;;2146   #if defined(USART_CR2_SLVEN)
;;;2147     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_UDR));
;;;2148   #else
;;;2149     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000e  f0100f0f          TST      r0,#0xf
000012  f04f0500          MOV      r5,#0
;;;2150   #endif
;;;2151     if (errorflags == 0U)
;;;2152     {
;;;2153       /* USART in mode Receiver ---------------------------------------------------*/
;;;2154   #if defined(USART_CR1_FIFOEN)
;;;2155       if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
;;;2156           && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
;;;2157               || ((cr3its & USART_CR3_RXFTIE) != 0U)))
;;;2158   #else
;;;2159       if (((isrflags & USART_ISR_RXNE) != 0U)
;;;2160           && ((cr1its & USART_CR1_RXNEIE) != 0U))
;;;2161   #endif
;;;2162       {
;;;2163         if (husart->RxISR != NULL)
;;;2164         {
;;;2165           husart->RxISR(husart);
;;;2166         }
;;;2167         return;
;;;2168       }
;;;2169     }
;;;2170   
;;;2171     /* If some errors occur */
;;;2172   #if defined(USART_CR1_FIFOEN)
;;;2173     if ((errorflags != 0U)
;;;2174         && (((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
;;;2175             || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE)) != 0U)))
;;;2176   #else
;;;2177     if ((errorflags != 0U)
;;;2178         && (((cr3its & USART_CR3_EIE) != 0U)
;;;2179             || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
;;;2180   #endif
;;;2181     {
;;;2182       /* USART parity error interrupt occurred -------------------------------------*/
;;;2183       if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
;;;2184       {
;;;2185         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_PEF);
000016  f04f0701          MOV      r7,#1
;;;2186   
;;;2187         husart->ErrorCode |= HAL_USART_ERROR_PE;
;;;2188       }
;;;2189   
;;;2190       /* USART frame error interrupt occurred --------------------------------------*/
;;;2191       if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
;;;2192       {
;;;2193         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_FEF);
;;;2194   
;;;2195         husart->ErrorCode |= HAL_USART_ERROR_FE;
;;;2196       }
;;;2197   
;;;2198       /* USART noise error interrupt occurred --------------------------------------*/
;;;2199       if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
;;;2200       {
;;;2201         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_NEF);
;;;2202   
;;;2203         husart->ErrorCode |= HAL_USART_ERROR_NE;
;;;2204       }
;;;2205   
;;;2206       /* USART Over-Run interrupt occurred -----------------------------------------*/
;;;2207   #if defined(USART_CR1_FIFOEN)
;;;2208       if (((isrflags & USART_ISR_ORE) != 0U)
;;;2209           && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
;;;2210               ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))
;;;2211   #else
;;;2212       if (((isrflags & USART_ISR_ORE) != 0U)
;;;2213           && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
;;;2214               ((cr3its & USART_CR3_EIE) != 0U)))
;;;2215   #endif
;;;2216       {
;;;2217         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
00001a  f04f0c08          MOV      r12,#8
00001e  d064              BEQ      |L11.234|
000020  f0030601          AND      r6,r3,#1              ;2178
000024  f4017e90          AND      lr,r1,#0x120          ;2178
000028  ea560e0e          ORRS     lr,r6,lr              ;2178
00002c  d072              BEQ      |L11.276|
00002e  ea5f7ec0          LSLS     lr,r0,#31             ;2183
000032  d007              BEQ      |L11.68|
000034  ea5f5ec1          LSLS     lr,r1,#23             ;2183
000038  d504              BPL      |L11.68|
00003a  6217              STR      r7,[r2,#0x20]         ;2185
00003c  6ce2              LDR      r2,[r4,#0x4c]         ;2187
00003e  f0420201          ORR      r2,r2,#1              ;2187
000042  64e2              STR      r2,[r4,#0x4c]         ;2187
                  |L11.68|
000044  0782              LSLS     r2,r0,#30             ;2191
000046  d508              BPL      |L11.90|
000048  07da              LSLS     r2,r3,#31             ;2191
00004a  d006              BEQ      |L11.90|
00004c  6827              LDR      r7,[r4,#0]            ;2193
00004e  2202              MOVS     r2,#2                 ;2193
000050  623a              STR      r2,[r7,#0x20]         ;2193
000052  6ce2              LDR      r2,[r4,#0x4c]         ;2195
000054  f0420204          ORR      r2,r2,#4              ;2195
000058  64e2              STR      r2,[r4,#0x4c]         ;2195
                  |L11.90|
00005a  0742              LSLS     r2,r0,#29             ;2199
00005c  d508              BPL      |L11.112|
00005e  07da              LSLS     r2,r3,#31             ;2199
000060  d006              BEQ      |L11.112|
000062  6823              LDR      r3,[r4,#0]            ;2201
000064  2204              MOVS     r2,#4                 ;2201
000066  621a              STR      r2,[r3,#0x20]         ;2201
000068  6ce2              LDR      r2,[r4,#0x4c]         ;2203
00006a  f0420202          ORR      r2,r2,#2              ;2203
00006e  64e2              STR      r2,[r4,#0x4c]         ;2203
                  |L11.112|
000070  0702              LSLS     r2,r0,#28             ;2212
000072  d50a              BPL      |L11.138|
000074  f0010220          AND      r2,r1,#0x20           ;2213
000078  4332              ORRS     r2,r2,r6              ;2213
00007a  d006              BEQ      |L11.138|
00007c  6822              LDR      r2,[r4,#0]
00007e  f8c2c020          STR      r12,[r2,#0x20]
;;;2218   
;;;2219         husart->ErrorCode |= HAL_USART_ERROR_ORE;
000082  6ce2              LDR      r2,[r4,#0x4c]
000084  f0420208          ORR      r2,r2,#8
000088  64e2              STR      r2,[r4,#0x4c]
                  |L11.138|
;;;2220       }
;;;2221   
;;;2222   #if defined(USART_CR2_SLVEN)
;;;2223       /* USART SPI slave underrun error interrupt occurred -------------------------*/
;;;2224       if (((isrflags & USART_ISR_UDR) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
;;;2225       {
;;;2226         /* Ignore SPI slave underrun errors when reception is going on */
;;;2227         if (husart->State == HAL_USART_STATE_BUSY_RX)
;;;2228         {
;;;2229           __HAL_USART_CLEAR_UDRFLAG(husart);
;;;2230           return;
;;;2231         }
;;;2232         else
;;;2233         {
;;;2234           __HAL_USART_CLEAR_UDRFLAG(husart);
;;;2235           husart->ErrorCode |= HAL_USART_ERROR_UDR;
;;;2236         }
;;;2237       }
;;;2238   #endif
;;;2239   
;;;2240       /* Call USART Error Call back function if need be --------------------------*/
;;;2241       if (husart->ErrorCode != HAL_USART_ERROR_NONE)
00008a  6ce2              LDR      r2,[r4,#0x4c]
00008c  2a00              CMP      r2,#0
00008e  d039              BEQ      |L11.260|
;;;2242       {
;;;2243         /* USART in mode Receiver ---------------------------------------------------*/
;;;2244   #if defined(USART_CR1_FIFOEN)
;;;2245         if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
;;;2246             && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
;;;2247                 || ((cr3its & USART_CR3_RXFTIE) != 0U)))
;;;2248   #else
;;;2249         if (((isrflags & USART_ISR_RXNE) != 0U)
000090  0680              LSLS     r0,r0,#26
000092  d505              BPL      |L11.160|
;;;2250             && ((cr1its & USART_CR1_RXNEIE) != 0U))
000094  0688              LSLS     r0,r1,#26
000096  d503              BPL      |L11.160|
;;;2251   #endif
;;;2252         {
;;;2253           if (husart->RxISR != NULL)
000098  6ba1              LDR      r1,[r4,#0x38]
00009a  b109              CBZ      r1,|L11.160|
;;;2254           {
;;;2255             husart->RxISR(husart);
00009c  4620              MOV      r0,r4
00009e  4788              BLX      r1
                  |L11.160|
;;;2256           }
;;;2257         }
;;;2258   
;;;2259         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2260            consider error as blocking */
;;;2261         errorcode = husart->ErrorCode & HAL_USART_ERROR_ORE;
0000a0  6ce0              LDR      r0,[r4,#0x4c]
;;;2262         if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)) ||
0000a2  6821              LDR      r1,[r4,#0]
0000a4  f0000008          AND      r0,r0,#8              ;2261
0000a8  6889              LDR      r1,[r1,#8]
0000aa  0649              LSLS     r1,r1,#25
0000ac  d400              BMI      |L11.176|
;;;2263             (errorcode != 0U))
0000ae  b358              CBZ      r0,|L11.264|
                  |L11.176|
;;;2264         {
;;;2265           /* Blocking error : transfer is aborted
;;;2266              Set the USART state ready to be able to start again the process,
;;;2267              Disable Interrupts, and disable DMA requests, if ongoing */
;;;2268           USART_EndTransfer(husart);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       USART_EndTransfer
;;;2269   
;;;2270           /* Disable the USART DMA Rx request if enabled */
;;;2271           if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6881              LDR      r1,[r0,#8]
0000ba  0649              LSLS     r1,r1,#25
0000bc  d51f              BPL      |L11.254|
;;;2272           {
;;;2273             CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR | USART_CR3_DMAR);
0000be  6881              LDR      r1,[r0,#8]
0000c0  f0210140          BIC      r1,r1,#0x40
0000c4  6081              STR      r1,[r0,#8]
;;;2274   
;;;2275             /* Abort the USART DMA Tx channel */
;;;2276             if (husart->hdmatx != NULL)
0000c6  6c20              LDR      r0,[r4,#0x40]
0000c8  b118              CBZ      r0,|L11.210|
;;;2277             {
;;;2278               /* Set the USART Tx DMA Abort callback to NULL : no callback
;;;2279                  executed at end of DMA abort procedure */
;;;2280               husart->hdmatx->XferAbortCallback = NULL;
;;;2281   
;;;2282               /* Abort DMA TX */
;;;2283               if (HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
0000ca  6385              STR      r5,[r0,#0x38]
0000cc  6c20              LDR      r0,[r4,#0x40]
0000ce  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L11.210|
;;;2284               {
;;;2285                 /* Nothing to do */
;;;2286               }
;;;2287             }
;;;2288   
;;;2289             /* Abort the USART DMA Rx channel */
;;;2290             if (husart->hdmarx != NULL)
0000d2  6c60              LDR      r0,[r4,#0x44]
0000d4  b198              CBZ      r0,|L11.254|
;;;2291             {
;;;2292               /* Set the USART Rx DMA Abort callback :
;;;2293                  will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
;;;2294               husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
0000d6  4927              LDR      r1,|L11.372|
;;;2295   
;;;2296               /* Abort DMA RX */
;;;2297               if (HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
0000d8  6381              STR      r1,[r0,#0x38]
0000da  6c60              LDR      r0,[r4,#0x44]
0000dc  f7fffffe          BL       HAL_DMA_Abort_IT
0000e0  2800              CMP      r0,#0
0000e2  d00f              BEQ      |L11.260|
;;;2298               {
;;;2299                 /* Call Directly husart->hdmarx->XferAbortCallback function in case of error */
;;;2300                 husart->hdmarx->XferAbortCallback(husart->hdmarx);
0000e4  6c60              LDR      r0,[r4,#0x44]
0000e6  6b81              LDR      r1,[r0,#0x38]
0000e8  e006              B        |L11.248|
                  |L11.234|
0000ea  0683              LSLS     r3,r0,#26             ;2159
0000ec  d512              BPL      |L11.276|
0000ee  068b              LSLS     r3,r1,#26             ;2160
0000f0  d510              BPL      |L11.276|
0000f2  6ba1              LDR      r1,[r4,#0x38]         ;2163
0000f4  e013              B        |L11.286|
                  |L11.246|
0000f6  4620              MOV      r0,r4                 ;2165
                  |L11.248|
;;;2301               }
;;;2302             }
;;;2303             else
;;;2304             {
;;;2305               /* Call user error callback */
;;;2306   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2307               /* Call registered Error Callback */
;;;2308               husart->ErrorCallback(husart);
;;;2309   #else
;;;2310               /* Call legacy weak Error Callback */
;;;2311               HAL_USART_ErrorCallback(husart);
;;;2312   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2313             }
;;;2314           }
;;;2315           else
;;;2316           {
;;;2317             /* Call user error callback */
;;;2318   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2319             /* Call registered Error Callback */
;;;2320             husart->ErrorCallback(husart);
;;;2321   #else
;;;2322             /* Call legacy weak Error Callback */
;;;2323             HAL_USART_ErrorCallback(husart);
;;;2324   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2325           }
;;;2326         }
;;;2327         else
;;;2328         {
;;;2329           /* Non Blocking error : transfer could go on.
;;;2330              Error is notified to user through user error callback */
;;;2331   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2332           /* Call registered Error Callback */
;;;2333           husart->ErrorCallback(husart);
;;;2334   #else
;;;2335           /* Call legacy weak Error Callback */
;;;2336           HAL_USART_ErrorCallback(husart);
;;;2337   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2338           husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;2339         }
;;;2340       }
;;;2341       return;
;;;2342   
;;;2343     } /* End if some error occurs */
;;;2344   
;;;2345   
;;;2346     /* USART in mode Transmitter ------------------------------------------------*/
;;;2347   #if defined(USART_CR1_FIFOEN)
;;;2348     if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
;;;2349         && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
;;;2350             || ((cr3its & USART_CR3_TXFTIE) != 0U)))
;;;2351   #else
;;;2352     if (((isrflags & USART_ISR_TXE) != 0U)
;;;2353         && ((cr1its & USART_CR1_TXEIE) != 0U))
;;;2354   #endif
;;;2355     {
;;;2356       if (husart->TxISR != NULL)
;;;2357       {
;;;2358         husart->TxISR(husart);
0000f8  e8bd41f0          POP      {r4-r8,lr}
0000fc  4708              BX       r1
                  |L11.254|
0000fe  4620              MOV      r0,r4                 ;2323
000100  f7fffffe          BL       HAL_USART_ErrorCallback
                  |L11.260|
;;;2359       }
;;;2360       return;
;;;2361     }
;;;2362   
;;;2363     /* USART in mode Transmitter (transmission end) -----------------------------*/
;;;2364     if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
;;;2365     {
;;;2366       USART_EndTransmit_IT(husart);
;;;2367       return;
;;;2368     }
;;;2369   
;;;2370   #if defined(USART_CR1_FIFOEN)
;;;2371     /* USART TX Fifo Empty occurred ----------------------------------------------*/
;;;2372     if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
;;;2373     {
;;;2374   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2375       /* Call registered Tx Fifo Empty Callback */
;;;2376       husart->TxFifoEmptyCallback(husart);
;;;2377   #else
;;;2378       /* Call legacy weak Tx Fifo Empty Callback */
;;;2379       HAL_USARTEx_TxFifoEmptyCallback(husart);
;;;2380   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2381       return;
;;;2382     }
;;;2383   
;;;2384     /* USART RX Fifo Full occurred ----------------------------------------------*/
;;;2385     if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
;;;2386     {
;;;2387   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2388       /* Call registered Rx Fifo Full Callback */
;;;2389       husart->RxFifoFullCallback(husart);
;;;2390   #else
;;;2391       /* Call legacy weak Rx Fifo Full Callback */
;;;2392       HAL_USARTEx_RxFifoFullCallback(husart);
;;;2393   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2394       return;
;;;2395     }
;;;2396   #endif
;;;2397   }
000104  e8bd81f0          POP      {r4-r8,pc}
                  |L11.264|
000108  4620              MOV      r0,r4                 ;2336
00010a  f7fffffe          BL       HAL_USART_ErrorCallback
00010e  64e5              STR      r5,[r4,#0x4c]         ;2338
000110  e7f8              B        |L11.260|
000112  e7ff              B        |L11.276|
                  |L11.276|
000114  0603              LSLS     r3,r0,#24             ;2352
000116  d505              BPL      |L11.292|
000118  060b              LSLS     r3,r1,#24             ;2353
00011a  d503              BPL      |L11.292|
00011c  6be1              LDR      r1,[r4,#0x3c]         ;2356
                  |L11.286|
00011e  2900              CMP      r1,#0                 ;2356
000120  d1e9              BNE      |L11.246|
000122  e7ef              B        |L11.260|
                  |L11.292|
000124  0640              LSLS     r0,r0,#25             ;2364
000126  d5ed              BPL      |L11.260|
000128  0648              LSLS     r0,r1,#25             ;2364
00012a  d5eb              BPL      |L11.260|
00012c  6811              LDR      r1,[r2,#0]            ;2364
00012e  4620              MOV      r0,r4                 ;2366
000130  f0210140          BIC      r1,r1,#0x40           ;2366
000134  6011              STR      r1,[r2,#0]            ;2366
000136  6821              LDR      r1,[r4,#0]            ;2366
000138  688a              LDR      r2,[r1,#8]            ;2366
00013a  f0220201          BIC      r2,r2,#1              ;2366
00013e  608a              STR      r2,[r1,#8]            ;2366
000140  63e5              STR      r5,[r4,#0x3c]         ;2366
000142  f8941049          LDRB     r1,[r4,#0x49]         ;2366
000146  2912              CMP      r1,#0x12              ;2366
000148  d007              BEQ      |L11.346|
00014a  8e41              LDRH     r1,[r0,#0x32]         ;2366
00014c  2900              CMP      r1,#0                 ;2366
00014e  d1d9              BNE      |L11.260|
000150  f8807049          STRB     r7,[r0,#0x49]         ;2366
000154  f7fffffe          BL       HAL_USART_TxRxCpltCallback
000158  e7d4              B        |L11.260|
                  |L11.346|
00015a  6801              LDR      r1,[r0,#0]
00015c  f8c1c020          STR      r12,[r1,#0x20]
000160  6801              LDR      r1,[r0,#0]
000162  8b0a              LDRH     r2,[r1,#0x18]
000164  f0420208          ORR      r2,r2,#8
000168  830a              STRH     r2,[r1,#0x18]
00016a  f8807049          STRB     r7,[r0,#0x49]
00016e  f7fffffe          BL       HAL_USART_TxCpltCallback
000172  e7c7              B        |L11.260|
;;;2398   
                          ENDP

                  |L11.372|
                          DCD      USART_DMAAbortOnError

                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=1

                  HAL_USART_Init PROC
;;;300      */
;;;301    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;302    {
000004  0004              MOVS     r4,r0
000006  d004              BEQ      |L12.18|
;;;303      /* Check the USART handle allocation */
;;;304      if (husart == NULL)
;;;305      {
;;;306        return HAL_ERROR;
;;;307      }
;;;308    
;;;309      /* Check the parameters */
;;;310      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;311    
;;;312      if (husart->State == HAL_USART_STATE_RESET)
000008  f8940049          LDRB     r0,[r4,#0x49]
00000c  2500              MOVS     r5,#0
00000e  b118              CBZ      r0,|L12.24|
000010  e007              B        |L12.34|
                  |L12.18|
000012  2001              MOVS     r0,#1                 ;306
                  |L12.20|
;;;313      {
;;;314        /* Allocate lock resource and initialize it */
;;;315        husart->Lock = HAL_UNLOCKED;
;;;316    
;;;317    #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;318        USART_InitCallbacksToDefault(husart);
;;;319    
;;;320        if (husart->MspInitCallback == NULL)
;;;321        {
;;;322          husart->MspInitCallback = HAL_USART_MspInit;
;;;323        }
;;;324    
;;;325        /* Init the low level hardware */
;;;326        husart->MspInitCallback(husart);
;;;327    #else
;;;328        /* Init the low level hardware : GPIO, CLOCK */
;;;329        HAL_USART_MspInit(husart);
;;;330    #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;331      }
;;;332    
;;;333      husart->State = HAL_USART_STATE_BUSY;
;;;334    
;;;335      /* Disable the Peripheral */
;;;336      __HAL_USART_DISABLE(husart);
;;;337    
;;;338      /* Set the Usart Communication parameters */
;;;339      if (USART_SetConfig(husart) == HAL_ERROR)
;;;340      {
;;;341        return HAL_ERROR;
;;;342      }
;;;343    
;;;344      /* In Synchronous mode, the following bits must be kept cleared:
;;;345      - LINEN bit in the USART_CR2 register
;;;346      - HDSEL, SCEN and IREN bits in the USART_CR3 register.*/
;;;347      husart->Instance->CR2 &= ~USART_CR2_LINEN;
;;;348      husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
;;;349    
;;;350      /* Enable the Peripheral */
;;;351      __HAL_USART_ENABLE(husart);
;;;352    
;;;353      /* TEACK and/or REACK to check before moving husart->State to Ready */
;;;354      return (USART_CheckIdleState(husart));
;;;355    }
000014  e8bd83f8          POP      {r3-r9,pc}
                  |L12.24|
000018  f8845048          STRB     r5,[r4,#0x48]         ;315
00001c  4620              MOV      r0,r4                 ;329
00001e  f7fffffe          BL       HAL_USART_MspInit
                  |L12.34|
000022  2002              MOVS     r0,#2                 ;333
000024  f8840049          STRB     r0,[r4,#0x49]         ;333
000028  6820              LDR      r0,[r4,#0]            ;336
00002a  6801              LDR      r1,[r0,#0]            ;336
00002c  f0210101          BIC      r1,r1,#1              ;336
000030  6001              STR      r1,[r0,#0]            ;336
000032  4620              MOV      r0,r4                 ;339
000034  f7fffffe          BL       USART_SetConfig
000038  2801              CMP      r0,#1                 ;339
00003a  d0eb              BEQ      |L12.20|
00003c  6820              LDR      r0,[r4,#0]            ;347
00003e  6841              LDR      r1,[r0,#4]            ;347
000040  f4214180          BIC      r1,r1,#0x4000         ;347
000044  6041              STR      r1,[r0,#4]            ;347
000046  6820              LDR      r0,[r4,#0]            ;348
000048  6881              LDR      r1,[r0,#8]            ;348
00004a  f021012a          BIC      r1,r1,#0x2a           ;348
00004e  6081              STR      r1,[r0,#8]            ;348
000050  6820              LDR      r0,[r4,#0]            ;351
000052  6801              LDR      r1,[r0,#0]            ;351
000054  f0410101          ORR      r1,r1,#1              ;351
000058  6001              STR      r1,[r0,#0]            ;351
00005a  64e5              STR      r5,[r4,#0x4c]         ;351
00005c  f7fffffe          BL       HAL_GetTick
000060  4680              MOV      r8,r0                 ;351
000062  6820              LDR      r0,[r4,#0]            ;351
000064  6800              LDR      r0,[r0,#0]            ;351
000066  f04f0703          MOV      r7,#3                 ;351
00006a  0700              LSLS     r0,r0,#28             ;351
00006c  f44f767a          MOV      r6,#0x3e8             ;351
000070  d50a              BPL      |L12.136|
000072  4643              MOV      r3,r8                 ;351
000074  2200              MOVS     r2,#0                 ;351
000076  f44f1100          MOV      r1,#0x200000          ;351
00007a  4620              MOV      r0,r4                 ;351
00007c  9600              STR      r6,[sp,#0]            ;351
00007e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L12.136|
                  |L12.132|
000084  4638              MOV      r0,r7                 ;351
000086  e7c5              B        |L12.20|
                  |L12.136|
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  0740              LSLS     r0,r0,#29
00008e  d509              BPL      |L12.164|
000090  4643              MOV      r3,r8
000092  2200              MOVS     r2,#0
000094  f44f0180          MOV      r1,#0x400000
000098  4620              MOV      r0,r4
00009a  9600              STR      r6,[sp,#0]
00009c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000a0  2800              CMP      r0,#0
0000a2  d1ef              BNE      |L12.132|
                  |L12.164|
0000a4  2001              MOVS     r0,#1
0000a6  f8840049          STRB     r0,[r4,#0x49]
0000aa  f8845048          STRB     r5,[r4,#0x48]
0000ae  4628              MOV      r0,r5
0000b0  e7b0              B        |L12.20|
;;;356    
                          ENDP


                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;419      */
;;;420    __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;421    {
;;;422      /* Prevent unused argument(s) compilation warning */
;;;423      UNUSED(husart);
;;;424    
;;;425      /* NOTE : This function should not be modified, when the callback is needed,
;;;426                the HAL_USART_MspDeInit can be implemented in the user file
;;;427       */
;;;428    }
;;;429    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;404      */
;;;405    __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;406    {
;;;407      /* Prevent unused argument(s) compilation warning */
;;;408      UNUSED(husart);
;;;409    
;;;410      /* NOTE : This function should not be modified, when the callback is needed,
;;;411                the HAL_USART_MspInit can be implemented in the user file
;;;412       */
;;;413    }
;;;414    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive PROC
;;;865      */
;;;866    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;867    {
000004  4604              MOV      r4,r0
;;;868      uint8_t  *prxdata8bits;
;;;869      uint16_t *prxdata16bits;
;;;870      uint16_t uhMask;
;;;871      uint32_t tickstart;
;;;872    
;;;873      if (husart->State == HAL_USART_STATE_READY)
000006  f8900049          LDRB     r0,[r0,#0x49]
00000a  4698              MOV      r8,r3                 ;867
00000c  4615              MOV      r5,r2                 ;867
00000e  460e              MOV      r6,r1                 ;867
000010  2801              CMP      r0,#1
000012  d16f              BNE      |L15.244|
;;;874      {
;;;875        if ((pRxData == NULL) || (Size == 0U))
000014  b1f6              CBZ      r6,|L15.84|
000016  b1ed              CBZ      r5,|L15.84|
;;;876        {
;;;877          return  HAL_ERROR;
;;;878        }
;;;879    
;;;880        /* Process Locked */
;;;881        __HAL_LOCK(husart);
000018  f8940048          LDRB     r0,[r4,#0x48]
00001c  2801              CMP      r0,#1
00001e  d069              BEQ      |L15.244|
000020  f04f0b01          MOV      r11,#1
000024  f884b048          STRB     r11,[r4,#0x48]
;;;882    
;;;883        husart->ErrorCode = HAL_USART_ERROR_NONE;
000028  f04f0a00          MOV      r10,#0
00002c  f8c4a04c          STR      r10,[r4,#0x4c]
;;;884        husart->State = HAL_USART_STATE_BUSY_RX;
000030  2022              MOVS     r0,#0x22
000032  f8840049          STRB     r0,[r4,#0x49]
;;;885    
;;;886        /* Init tickstart for timeout managment*/
;;;887        tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
;;;888    
;;;889        husart->RxXferSize = Size;
00003a  9001              STR      r0,[sp,#4]
00003c  8625              STRH     r5,[r4,#0x30]
;;;890        husart->RxXferCount = Size;
00003e  8665              STRH     r5,[r4,#0x32]
;;;891    
;;;892        /* Computation of USART mask to apply to RDR register */
;;;893        USART_MASK_COMPUTATION(husart);
000040  68a0              LDR      r0,[r4,#8]
000042  f44f5280          MOV      r2,#0x1000
000046  f04f09ff          MOV      r9,#0xff
00004a  4290              CMP      r0,r2
00004c  d108              BNE      |L15.96|
00004e  6921              LDR      r1,[r4,#0x10]
000050  b119              CBZ      r1,|L15.90|
000052  e017              B        |L15.132|
                  |L15.84|
000054  2001              MOVS     r0,#1                 ;877
                  |L15.86|
;;;894        uhMask = husart->Mask;
;;;895    
;;;896        /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;897        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;898        {
;;;899          prxdata8bits  = NULL;
;;;900          prxdata16bits = (uint16_t *) pRxData;
;;;901        }
;;;902        else
;;;903        {
;;;904          prxdata8bits  = pRxData;
;;;905          prxdata16bits = NULL;
;;;906        }
;;;907    
;;;908        /* as long as data have to be received */
;;;909        while (husart->RxXferCount > 0U)
;;;910        {
;;;911    #if defined(USART_CR2_SLVEN)
;;;912          if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
;;;913    #endif
;;;914          {
;;;915            /* Wait until TXE flag is set to send dummy byte in order to generate the
;;;916            * clock for the slave to send data.
;;;917            * Whatever the frame length (7, 8 or 9-bit long), the same dummy value
;;;918            * can be written for all the cases. */
;;;919            if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;920            {
;;;921              return HAL_TIMEOUT;
;;;922            }
;;;923            husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x0FF);
;;;924          }
;;;925    
;;;926          /* Wait for RXNE Flag */
;;;927          if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;928          {
;;;929            return HAL_TIMEOUT;
;;;930          }
;;;931    
;;;932          if (prxdata8bits == NULL)
;;;933          {
;;;934            *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
;;;935            prxdata16bits++;
;;;936          }
;;;937          else
;;;938          {
;;;939            *prxdata8bits = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;940            prxdata8bits++;
;;;941          }
;;;942    
;;;943          husart->RxXferCount--;
;;;944    
;;;945        }
;;;946    
;;;947    #if defined(USART_CR2_SLVEN)
;;;948        /* Clear SPI slave underrun flag and discard transmit data */
;;;949        if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
;;;950        {
;;;951          __HAL_USART_CLEAR_UDRFLAG(husart);
;;;952          __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
;;;953        }
;;;954    #endif
;;;955    
;;;956        /* At end of Rx process, restore husart->State to Ready */
;;;957        husart->State = HAL_USART_STATE_READY;
;;;958    
;;;959        /* Process Unlocked */
;;;960        __HAL_UNLOCK(husart);
;;;961    
;;;962        return HAL_OK;
;;;963      }
;;;964      else
;;;965      {
;;;966        return HAL_BUSY;
;;;967      }
;;;968    }
000056  e8bd9ffc          POP      {r2-r12,pc}
                  |L15.90|
00005a  f24011ff          MOV      r1,#0x1ff             ;893
00005e  e018              B        |L15.146|
                  |L15.96|
000060  217f              MOVS     r1,#0x7f              ;893
000062  b168              CBZ      r0,|L15.128|
000064  f1b05f80          CMP      r0,#0x10000000        ;893
000068  d010              BEQ      |L15.140|
00006a  4651              MOV      r1,r10                ;893
00006c  f8a4a034          STRH     r10,[r4,#0x34]        ;893
                  |L15.112|
000070  b28f              UXTH     r7,r1                 ;894
000072  4290              CMP      r0,r2                 ;897
000074  d101              BNE      |L15.122|
000076  6920              LDR      r0,[r4,#0x10]         ;897
000078  b168              CBZ      r0,|L15.150|
                  |L15.122|
00007a  4635              MOV      r5,r6                 ;904
00007c  2600              MOVS     r6,#0                 ;905
00007e  e02d              B        |L15.220|
                  |L15.128|
000080  6923              LDR      r3,[r4,#0x10]         ;893
000082  b933              CBNZ     r3,|L15.146|
                  |L15.132|
000084  4649              MOV      r1,r9                 ;893
000086  f8a49034          STRH     r9,[r4,#0x34]         ;893
00008a  e7f1              B        |L15.112|
                  |L15.140|
00008c  6923              LDR      r3,[r4,#0x10]         ;893
00008e  b103              CBZ      r3,|L15.146|
000090  213f              MOVS     r1,#0x3f              ;893
                  |L15.146|
000092  86a1              STRH     r1,[r4,#0x34]         ;893
000094  e7ec              B        |L15.112|
                  |L15.150|
000096  2500              MOVS     r5,#0                 ;899
000098  e020              B        |L15.220|
                  |L15.154|
00009a  f8cd8000          STR      r8,[sp,#0]            ;919
00009e  2200              MOVS     r2,#0                 ;919
0000a0  2180              MOVS     r1,#0x80              ;919
0000a2  4620              MOV      r0,r4                 ;919
0000a4  9b01              LDR      r3,[sp,#4]            ;919
0000a6  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000aa  b958              CBNZ     r0,|L15.196|
0000ac  6821              LDR      r1,[r4,#0]            ;923
0000ae  f8a19028          STRH     r9,[r1,#0x28]         ;923
0000b2  f8cd8000          STR      r8,[sp,#0]            ;927
0000b6  2200              MOVS     r2,#0                 ;927
0000b8  2120              MOVS     r1,#0x20              ;927
0000ba  4620              MOV      r0,r4                 ;927
0000bc  9b01              LDR      r3,[sp,#4]            ;927
0000be  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000c2  b108              CBZ      r0,|L15.200|
                  |L15.196|
0000c4  2003              MOVS     r0,#3                 ;929
0000c6  e7c6              B        |L15.86|
                  |L15.200|
0000c8  6820              LDR      r0,[r4,#0]            ;939
0000ca  8c80              LDRH     r0,[r0,#0x24]         ;939
0000cc  ea000007          AND      r0,r0,r7              ;939
0000d0  b165              CBZ      r5,|L15.236|
0000d2  f8050b01          STRB     r0,[r5],#1            ;939
                  |L15.214|
0000d6  8e60              LDRH     r0,[r4,#0x32]         ;943
0000d8  1e40              SUBS     r0,r0,#1              ;943
0000da  8660              STRH     r0,[r4,#0x32]         ;943
                  |L15.220|
0000dc  8e60              LDRH     r0,[r4,#0x32]         ;909
0000de  2800              CMP      r0,#0                 ;909
0000e0  d1db              BNE      |L15.154|
0000e2  f884b049          STRB     r11,[r4,#0x49]        ;957
0000e6  f884a048          STRB     r10,[r4,#0x48]        ;960
0000ea  e7b4              B        |L15.86|
                  |L15.236|
0000ec  f8260b02          STRH     r0,[r6],#2            ;934
0000f0  e7f1              B        |L15.214|
0000f2  e7ff              B        |L15.244|
                  |L15.244|
0000f4  2002              MOVS     r0,#2                 ;966
0000f6  e7ae              B        |L15.86|
;;;969    
                          ENDP


                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;1506     */
;;;1507   HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1508   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1509     HAL_StatusTypeDef status = HAL_OK;
;;;1510     uint32_t *tmp = (uint32_t *)&pRxData;
;;;1511   
;;;1512     /* Check that a Rx process is not already ongoing */
;;;1513     if (husart->State == HAL_USART_STATE_READY)
000006  f8941049          LDRB     r1,[r4,#0x49]
00000a  2000              MOVS     r0,#0                 ;1509
00000c  2901              CMP      r1,#1
00000e  d154              BNE      |L16.186|
;;;1514     {
;;;1515       if ((pRxData == NULL) || (Size == 0U))
000010  9a01              LDR      r2,[sp,#4]
000012  b3c2              CBZ      r2,|L16.134|
000014  b3bd              CBZ      r5,|L16.134|
;;;1516       {
;;;1517         return HAL_ERROR;
;;;1518       }
;;;1519   
;;;1520       /* Process Locked */
;;;1521       __HAL_LOCK(husart);
000016  f8941048          LDRB     r1,[r4,#0x48]
00001a  2901              CMP      r1,#1
00001c  d04d              BEQ      |L16.186|
00001e  2701              MOVS     r7,#1
000020  f8847048          STRB     r7,[r4,#0x48]
;;;1522   
;;;1523       husart->pRxBuffPtr = pRxData;
;;;1524       husart->RxXferSize = Size;
000024  62e2              STR      r2,[r4,#0x2c]
000026  8625              STRH     r5,[r4,#0x30]
;;;1525       husart->pTxBuffPtr = pRxData;
;;;1526       husart->TxXferSize = Size;
000028  6262              STR      r2,[r4,#0x24]
00002a  8525              STRH     r5,[r4,#0x28]
;;;1527   
;;;1528       husart->ErrorCode = HAL_USART_ERROR_NONE;
00002c  2600              MOVS     r6,#0
00002e  64e6              STR      r6,[r4,#0x4c]
;;;1529       husart->State = HAL_USART_STATE_BUSY_RX;
000030  2122              MOVS     r1,#0x22
000032  f8841049          STRB     r1,[r4,#0x49]
000036  6c61              LDR      r1,[r4,#0x44]         ;1521
000038  b169              CBZ      r1,|L16.86|
;;;1530   
;;;1531       if (husart->hdmarx != NULL)
;;;1532       {
;;;1533         /* Set the USART DMA Rx transfer complete callback */
;;;1534         husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
00003a  4821              LDR      r0,|L16.192|
;;;1535   
;;;1536         /* Set the USART DMA Half transfer complete callback */
;;;1537         husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
00003c  62c8              STR      r0,[r1,#0x2c]
00003e  6c61              LDR      r1,[r4,#0x44]
000040  4820              LDR      r0,|L16.196|
;;;1538   
;;;1539         /* Set the USART DMA Rx transfer error callback */
;;;1540         husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1541   
;;;1542         /* Enable the USART receive DMA channel */
;;;1543         status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t *)tmp, Size);
000042  462b              MOV      r3,r5
000044  6308              STR      r0,[r1,#0x30]         ;1540
000046  6c61              LDR      r1,[r4,#0x44]         ;1540
000048  481f              LDR      r0,|L16.200|
00004a  6348              STR      r0,[r1,#0x34]
00004c  6821              LDR      r1,[r4,#0]
00004e  6c60              LDR      r0,[r4,#0x44]
000050  3124              ADDS     r1,r1,#0x24
000052  f7fffffe          BL       HAL_DMA_Start_IT
                  |L16.86|
;;;1544       }
;;;1545   
;;;1546   #if defined(USART_CR2_SLVEN)
;;;1547       if ((status == HAL_OK) &&
;;;1548           (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
;;;1549   #endif
;;;1550       {
;;;1551         /* Enable the USART transmit DMA channel: the transmit channel is used in order
;;;1552            to generate in the non-blocking mode the clock to the slave device,
;;;1553            this mode isn't a simplex receive mode but a full-duplex receive mode */
;;;1554   
;;;1555         /* Set the USART DMA Tx Complete and Error callback to Null */
;;;1556         if (husart->hdmatx != NULL)
000056  6c21              LDR      r1,[r4,#0x40]
000058  b159              CBZ      r1,|L16.114|
;;;1557         {
;;;1558           husart->hdmatx->XferErrorCallback = NULL;
;;;1559           husart->hdmatx->XferHalfCpltCallback = NULL;
00005a  634e              STR      r6,[r1,#0x34]
00005c  6c20              LDR      r0,[r4,#0x40]
;;;1560           husart->hdmatx->XferCpltCallback = NULL;
;;;1561           status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
00005e  462b              MOV      r3,r5
000060  6306              STR      r6,[r0,#0x30]         ;1560
000062  6c20              LDR      r0,[r4,#0x40]         ;1560
000064  62c6              STR      r6,[r0,#0x2c]
000066  6822              LDR      r2,[r4,#0]
000068  9901              LDR      r1,[sp,#4]
00006a  3228              ADDS     r2,r2,#0x28
00006c  6c20              LDR      r0,[r4,#0x40]
00006e  f7fffffe          BL       HAL_DMA_Start_IT
                  |L16.114|
;;;1562         }
;;;1563       }
;;;1564   
;;;1565       if(status == HAL_OK)
000072  b150              CBZ      r0,|L16.138|
;;;1566       {
;;;1567         /* Process Unlocked */
;;;1568         __HAL_UNLOCK(husart);
;;;1569   
;;;1570         /* Enable the USART Parity Error Interrupt */
;;;1571         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1572   
;;;1573         /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1574         SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1575   
;;;1576         /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1577            in the USART CR3 register */
;;;1578         SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1579   
;;;1580         /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1581            in the USART CR3 register */
;;;1582         SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1583   
;;;1584         return HAL_OK;
;;;1585       }
;;;1586       else
;;;1587       {
;;;1588         if(husart->hdmarx != NULL)
000074  6c60              LDR      r0,[r4,#0x44]
000076  b108              CBZ      r0,|L16.124|
;;;1589         {
;;;1590           status = HAL_DMA_Abort(husart->hdmarx);
000078  f7fffffe          BL       HAL_DMA_Abort
                  |L16.124|
;;;1591         }
;;;1592    
;;;1593         /* No need to check on error code */
;;;1594         UNUSED(status);
;;;1595   
;;;1596         /* Set error code to DMA */
;;;1597         husart->ErrorCode = HAL_USART_ERROR_DMA;
00007c  2010              MOVS     r0,#0x10
00007e  64e0              STR      r0,[r4,#0x4c]
;;;1598   
;;;1599         /* Process Unlocked */
;;;1600         __HAL_UNLOCK(husart);
000080  f8046f48          STRB     r6,[r4,#0x48]!
;;;1601   
;;;1602         /* Restore husart->State to ready */
;;;1603         husart->State = HAL_USART_STATE_READY;
000084  7067              STRB     r7,[r4,#1]
                  |L16.134|
000086  2001              MOVS     r0,#1                 ;1517
;;;1604   
;;;1605         return HAL_ERROR;
;;;1606       }
;;;1607     }
;;;1608     else
;;;1609     {
;;;1610       return HAL_BUSY;
;;;1611     }
;;;1612   }
000088  bdfe              POP      {r1-r7,pc}
                  |L16.138|
00008a  f8846048          STRB     r6,[r4,#0x48]         ;1568
00008e  6820              LDR      r0,[r4,#0]            ;1571
000090  6801              LDR      r1,[r0,#0]            ;1571
000092  f4417180          ORR      r1,r1,#0x100          ;1571
000096  6001              STR      r1,[r0,#0]            ;1571
000098  6820              LDR      r0,[r4,#0]            ;1574
00009a  6881              LDR      r1,[r0,#8]            ;1574
00009c  f0410101          ORR      r1,r1,#1              ;1574
0000a0  6081              STR      r1,[r0,#8]            ;1574
0000a2  6820              LDR      r0,[r4,#0]            ;1578
0000a4  6881              LDR      r1,[r0,#8]            ;1578
0000a6  f0410140          ORR      r1,r1,#0x40           ;1578
0000aa  6081              STR      r1,[r0,#8]            ;1578
0000ac  6820              LDR      r0,[r4,#0]            ;1582
0000ae  6881              LDR      r1,[r0,#8]            ;1582
0000b0  f0410180          ORR      r1,r1,#0x80           ;1582
0000b4  6081              STR      r1,[r0,#8]            ;1582
0000b6  2000              MOVS     r0,#0                 ;1584
0000b8  bdfe              POP      {r1-r7,pc}
                  |L16.186|
0000ba  2002              MOVS     r0,#2                 ;1610
0000bc  bdfe              POP      {r1-r7,pc}
;;;1613   
                          ENDP

0000be  0000              DCW      0x0000
                  |L16.192|
                          DCD      USART_DMAReceiveCplt
                  |L16.196|
                          DCD      USART_DMARxHalfCplt
                  |L16.200|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_IT PROC
;;;1207     */
;;;1208   HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;1209   {
;;;1210   #if defined(USART_CR1_FIFOEN)
;;;1211     uint16_t nb_dummy_data;
;;;1212   #endif
;;;1213   
;;;1214     if (husart->State == HAL_USART_STATE_READY)
000002  f8903049          LDRB     r3,[r0,#0x49]
000006  2b01              CMP      r3,#1
000008  d148              BNE      |L17.156|
;;;1215     {
;;;1216       if ((pRxData == NULL) || (Size == 0U))
00000a  b1a1              CBZ      r1,|L17.54|
00000c  b19a              CBZ      r2,|L17.54|
;;;1217       {
;;;1218         return HAL_ERROR;
;;;1219       }
;;;1220   
;;;1221       /* Process Locked */
;;;1222       __HAL_LOCK(husart);
00000e  f8903048          LDRB     r3,[r0,#0x48]
000012  2b01              CMP      r3,#1
000014  d042              BEQ      |L17.156|
000016  2301              MOVS     r3,#1
000018  f8803048          STRB     r3,[r0,#0x48]
;;;1223   
;;;1224       husart->pRxBuffPtr  = pRxData;
;;;1225       husart->RxXferSize  = Size;
00001c  62c1              STR      r1,[r0,#0x2c]
00001e  8602              STRH     r2,[r0,#0x30]
;;;1226       husart->RxXferCount = Size;
000020  8642              STRH     r2,[r0,#0x32]
;;;1227       husart->RxISR       = NULL;
000022  2200              MOVS     r2,#0
;;;1228   
;;;1229       USART_MASK_COMPUTATION(husart);
000024  6382              STR      r2,[r0,#0x38]
000026  031d              LSLS     r5,r3,#12
000028  6881              LDR      r1,[r0,#8]
00002a  23ff              MOVS     r3,#0xff
00002c  42a9              CMP      r1,r5
00002e  d107              BNE      |L17.64|
000030  6901              LDR      r1,[r0,#0x10]
000032  b111              CBZ      r1,|L17.58|
000034  e027              B        |L17.134|
                  |L17.54|
000036  2001              MOVS     r0,#1                 ;1218
;;;1230   
;;;1231       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1232       husart->State = HAL_USART_STATE_BUSY_RX;
;;;1233   
;;;1234       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1235       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1236   
;;;1237   #if defined(USART_CR1_FIFOEN)
;;;1238       /* Configure Rx interrupt processing */
;;;1239       if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
;;;1240       {
;;;1241         /* Set the Rx ISR function pointer according to the data word length */
;;;1242         if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1243         {
;;;1244           husart->RxISR = USART_RxISR_16BIT_FIFOEN;
;;;1245         }
;;;1246         else
;;;1247         {
;;;1248           husart->RxISR = USART_RxISR_8BIT_FIFOEN;
;;;1249         }
;;;1250   
;;;1251         /* Process Unlocked */
;;;1252         __HAL_UNLOCK(husart);
;;;1253   
;;;1254         /* Enable the USART Parity Error interrupt and RX FIFO Threshold interrupt */
;;;1255         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1256         SET_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
;;;1257       }
;;;1258       else
;;;1259   #endif
;;;1260       {
;;;1261         /* Set the Rx ISR function pointer according to the data word length */
;;;1262         if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1263         {
;;;1264           husart->RxISR = USART_RxISR_16BIT;
;;;1265         }
;;;1266         else
;;;1267         {
;;;1268           husart->RxISR = USART_RxISR_8BIT;
;;;1269         }
;;;1270   
;;;1271         /* Process Unlocked */
;;;1272         __HAL_UNLOCK(husart);
;;;1273   
;;;1274         /* Enable the USART Parity Error and Data Register not empty Interrupts */
;;;1275   #if defined(USART_CR1_FIFOEN)
;;;1276         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
;;;1277   #else
;;;1278         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;1279   #endif
;;;1280       }
;;;1281   
;;;1282   #if defined(USART_CR2_SLVEN)
;;;1283       if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
;;;1284   #endif
;;;1285       {
;;;1286         /* Send dummy data in order to generate the clock for the Slave to send the next data.
;;;1287            When FIFO mode is disabled only one data must be transferred.
;;;1288            When FIFO mode is enabled data must be transmitted until the RX FIFO reaches its threshold.
;;;1289         */
;;;1290   #if defined(USART_CR1_FIFOEN)
;;;1291         if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
;;;1292         {
;;;1293           for (nb_dummy_data = husart->NbRxDataToProcess ; nb_dummy_data > 0U ; nb_dummy_data--)
;;;1294           {
;;;1295             husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
;;;1296           }
;;;1297         }
;;;1298         else
;;;1299   #endif
;;;1300         {
;;;1301           husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
;;;1302         }
;;;1303       }
;;;1304   
;;;1305       return HAL_OK;
;;;1306     }
;;;1307     else
;;;1308     {
;;;1309       return HAL_BUSY;
;;;1310     }
;;;1311   }
000038  bd30              POP      {r4,r5,pc}
                  |L17.58|
00003a  f24011ff          MOV      r1,#0x1ff             ;1229
00003e  e027              B        |L17.144|
                  |L17.64|
000040  247f              MOVS     r4,#0x7f              ;1229
000042  b1f1              CBZ      r1,|L17.130|
000044  f1b15f80          CMP      r1,#0x10000000        ;1229
000048  d01f              BEQ      |L17.138|
00004a  8682              STRH     r2,[r0,#0x34]         ;1229
                  |L17.76|
00004c  64c2              STR      r2,[r0,#0x4c]         ;1231
00004e  2122              MOVS     r1,#0x22              ;1232
000050  f8801049          STRB     r1,[r0,#0x49]         ;1232
000054  6801              LDR      r1,[r0,#0]            ;1235
000056  688c              LDR      r4,[r1,#8]            ;1235
000058  f0440401          ORR      r4,r4,#1              ;1235
00005c  608c              STR      r4,[r1,#8]            ;1235
00005e  6881              LDR      r1,[r0,#8]            ;1262
000060  42a9              CMP      r1,r5                 ;1262
000062  d101              BNE      |L17.104|
000064  6901              LDR      r1,[r0,#0x10]         ;1262
000066  b1b9              CBZ      r1,|L17.152|
                  |L17.104|
000068  490d              LDR      r1,|L17.160|
                  |L17.106|
00006a  6381              STR      r1,[r0,#0x38]         ;1272
00006c  f8802048          STRB     r2,[r0,#0x48]         ;1272
000070  6801              LDR      r1,[r0,#0]            ;1278
000072  680a              LDR      r2,[r1,#0]            ;1278
000074  f4427290          ORR      r2,r2,#0x120          ;1278
000078  600a              STR      r2,[r1,#0]            ;1278
00007a  6800              LDR      r0,[r0,#0]            ;1301
00007c  8503              STRH     r3,[r0,#0x28]         ;1301
00007e  2000              MOVS     r0,#0                 ;1305
000080  bd30              POP      {r4,r5,pc}
                  |L17.130|
000082  6901              LDR      r1,[r0,#0x10]         ;1229
000084  b931              CBNZ     r1,|L17.148|
                  |L17.134|
000086  8683              STRH     r3,[r0,#0x34]         ;1229
000088  e7e0              B        |L17.76|
                  |L17.138|
00008a  6901              LDR      r1,[r0,#0x10]         ;1229
00008c  b111              CBZ      r1,|L17.148|
00008e  213f              MOVS     r1,#0x3f              ;1229
                  |L17.144|
000090  8681              STRH     r1,[r0,#0x34]         ;1229
000092  e7db              B        |L17.76|
                  |L17.148|
000094  8684              STRH     r4,[r0,#0x34]         ;1229
000096  e7d9              B        |L17.76|
                  |L17.152|
000098  4902              LDR      r1,|L17.164|
00009a  e7e6              B        |L17.106|
                  |L17.156|
00009c  2002              MOVS     r0,#2                 ;1309
00009e  bd30              POP      {r4,r5,pc}
;;;1312   
                          ENDP

                  |L17.160|
                          DCD      USART_RxISR_8BIT
                  |L17.164|
                          DCD      USART_RxISR_16BIT

                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;2433     */
;;;2434   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2435   {
;;;2436     /* Prevent unused argument(s) compilation warning */
;;;2437     UNUSED(husart);
;;;2438   
;;;2439     /* NOTE: This function should not be modified, when the callback is needed,
;;;2440              the HAL_USART_RxCpltCallback can be implemented in the user file.
;;;2441      */
;;;2442   }
;;;2443   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;2448     */
;;;2449   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2450   {
;;;2451     /* Prevent unused argument(s) compilation warning */
;;;2452     UNUSED(husart);
;;;2453   
;;;2454     /* NOTE : This function should not be modified, when the callback is needed,
;;;2455               the HAL_USART_RxHalfCpltCallback can be implemented in the user file
;;;2456      */
;;;2457   }
;;;2458   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;771      */
;;;772    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;773    {
000004  4604              MOV      r4,r0
;;;774      uint8_t  *ptxdata8bits;
;;;775      uint16_t *ptxdata16bits;
;;;776      uint32_t tickstart;
;;;777    
;;;778      if (husart->State == HAL_USART_STATE_READY)
000006  f8900049          LDRB     r0,[r0,#0x49]
00000a  461f              MOV      r7,r3                 ;773
00000c  4615              MOV      r5,r2                 ;773
00000e  460e              MOV      r6,r1                 ;773
000010  2801              CMP      r0,#1
000012  d15b              BNE      |L20.204|
;;;779      {
;;;780        if ((pTxData == NULL) || (Size == 0U))
000014  b1ce              CBZ      r6,|L20.74|
000016  b1c5              CBZ      r5,|L20.74|
;;;781        {
;;;782          return  HAL_ERROR;
;;;783        }
;;;784    
;;;785        /* Process Locked */
;;;786        __HAL_LOCK(husart);
000018  f8940048          LDRB     r0,[r4,#0x48]
00001c  2801              CMP      r0,#1
00001e  d055              BEQ      |L20.204|
000020  f04f0801          MOV      r8,#1
000024  f8848048          STRB     r8,[r4,#0x48]
;;;787    
;;;788        husart->ErrorCode = HAL_USART_ERROR_NONE;
000028  f04f0900          MOV      r9,#0
00002c  f8c4904c          STR      r9,[r4,#0x4c]
;;;789        husart->State = HAL_USART_STATE_BUSY_TX;
000030  2012              MOVS     r0,#0x12
000032  f8840049          STRB     r0,[r4,#0x49]
;;;790    
;;;791        /* Init tickstart for timeout managment*/
;;;792        tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
;;;793    
;;;794        husart->TxXferSize = Size;
00003a  8525              STRH     r5,[r4,#0x28]
00003c  4682              MOV      r10,r0                ;792
;;;795        husart->TxXferCount = Size;
00003e  8565              STRH     r5,[r4,#0x2a]
;;;796    
;;;797        /* In case of 9bits/No Parity transfer, pTxData needs to be handled as a uint16_t pointer */
;;;798        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
000040  68a0              LDR      r0,[r4,#8]
000042  f5b05f80          CMP      r0,#0x1000
000046  d003              BEQ      |L20.80|
000048  e004              B        |L20.84|
                  |L20.74|
00004a  2001              MOVS     r0,#1                 ;782
                  |L20.76|
;;;799        {
;;;800          ptxdata8bits  = NULL;
;;;801          ptxdata16bits = (uint16_t *) pTxData;
;;;802        }
;;;803        else
;;;804        {
;;;805          ptxdata8bits  = pTxData;
;;;806          ptxdata16bits = NULL;
;;;807        }
;;;808    
;;;809        /* Check the remaining data to be sent */
;;;810        while (husart->TxXferCount > 0U)
;;;811        {
;;;812          if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;813          {
;;;814            return HAL_TIMEOUT;
;;;815          }
;;;816          if (ptxdata8bits == NULL)
;;;817          {
;;;818            husart->Instance->TDR = (uint16_t)(*ptxdata16bits & 0x01FFU);
;;;819            ptxdata16bits++;
;;;820          }
;;;821          else
;;;822          {
;;;823            husart->Instance->TDR = (uint8_t)(*ptxdata8bits & 0xFFU);
;;;824            ptxdata8bits++;
;;;825          }
;;;826    
;;;827          husart->TxXferCount--;
;;;828        }
;;;829    
;;;830        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;831        {
;;;832          return HAL_TIMEOUT;
;;;833        }
;;;834    
;;;835        /* Clear Transmission Complete Flag */
;;;836        __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;837    
;;;838        /* Clear overrun flag and discard the received data */
;;;839        __HAL_USART_CLEAR_OREFLAG(husart);
;;;840        __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
;;;841        __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
;;;842    
;;;843        /* At end of Tx process, restore husart->State to Ready */
;;;844        husart->State = HAL_USART_STATE_READY;
;;;845    
;;;846        /* Process Unlocked */
;;;847        __HAL_UNLOCK(husart);
;;;848    
;;;849        return HAL_OK;
;;;850      }
;;;851      else
;;;852      {
;;;853        return HAL_BUSY;
;;;854      }
;;;855    }
00004c  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.80|
000050  6920              LDR      r0,[r4,#0x10]         ;798
000052  b110              CBZ      r0,|L20.90|
                  |L20.84|
000054  4635              MOV      r5,r6                 ;805
000056  2600              MOVS     r6,#0                 ;806
000058  e00e              B        |L20.120|
                  |L20.90|
00005a  2500              MOVS     r5,#0                 ;800
00005c  e00c              B        |L20.120|
                  |L20.94|
00005e  2180              MOVS     r1,#0x80              ;812
000060  4620              MOV      r0,r4                 ;812
000062  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000066  b9a0              CBNZ     r0,|L20.146|
000068  b1ad              CBZ      r5,|L20.150|
00006a  f8150b01          LDRB     r0,[r5],#1            ;823
                  |L20.110|
00006e  6821              LDR      r1,[r4,#0]            ;823
000070  8508              STRH     r0,[r1,#0x28]         ;823
000072  8d60              LDRH     r0,[r4,#0x2a]         ;827
000074  1e40              SUBS     r0,r0,#1              ;827
000076  8560              STRH     r0,[r4,#0x2a]         ;827
                  |L20.120|
000078  8d60              LDRH     r0,[r4,#0x2a]         ;810
00007a  4653              MOV      r3,r10                ;830
00007c  f04f0200          MOV      r2,#0                 ;830
000080  9700              STR      r7,[sp,#0]            ;810
000082  2800              CMP      r0,#0                 ;810
000084  d1eb              BNE      |L20.94|
000086  f04f0140          MOV      r1,#0x40              ;830
00008a  4620              MOV      r0,r4                 ;830
00008c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000090  b130              CBZ      r0,|L20.160|
                  |L20.146|
000092  2003              MOVS     r0,#3                 ;832
000094  e7da              B        |L20.76|
                  |L20.150|
000096  f8360b02          LDRH     r0,[r6],#2            ;818
00009a  f3c00008          UBFX     r0,r0,#0,#9           ;818
00009e  e7e6              B        |L20.110|
                  |L20.160|
0000a0  6821              LDR      r1,[r4,#0]            ;836
0000a2  2040              MOVS     r0,#0x40              ;836
0000a4  6208              STR      r0,[r1,#0x20]         ;836
0000a6  6821              LDR      r1,[r4,#0]            ;839
0000a8  2008              MOVS     r0,#8                 ;839
0000aa  6208              STR      r0,[r1,#0x20]         ;839
0000ac  6820              LDR      r0,[r4,#0]            ;840
0000ae  8b01              LDRH     r1,[r0,#0x18]         ;840
0000b0  f0410108          ORR      r1,r1,#8              ;840
0000b4  8301              STRH     r1,[r0,#0x18]         ;840
0000b6  6820              LDR      r0,[r4,#0]            ;841
0000b8  8b01              LDRH     r1,[r0,#0x18]         ;841
0000ba  f0410110          ORR      r1,r1,#0x10           ;841
0000be  8301              STRH     r1,[r0,#0x18]         ;841
0000c0  f8848049          STRB     r8,[r4,#0x49]         ;844
0000c4  f8849048          STRB     r9,[r4,#0x48]         ;847
0000c8  2000              MOVS     r0,#0                 ;849
0000ca  e7bf              B        |L20.76|
                  |L20.204|
0000cc  2002              MOVS     r0,#2                 ;853
0000ce  e7bd              B        |L20.76|
;;;856    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive PROC
;;;978      */
;;;979    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;980    {
000004  4604              MOV      r4,r0
;;;981      uint8_t  *prxdata8bits;
;;;982      uint16_t *prxdata16bits;
;;;983      uint8_t  *ptxdata8bits;
;;;984      uint16_t *ptxdata16bits;
;;;985      uint16_t uhMask;
;;;986      uint16_t rxdatacount;
;;;987      uint32_t tickstart;
;;;988    
;;;989      if (husart->State == HAL_USART_STATE_READY)
000006  f8900049          LDRB     r0,[r0,#0x49]
00000a  f8dda030          LDR      r10,[sp,#0x30]
00000e  461d              MOV      r5,r3                 ;980
000010  4691              MOV      r9,r2                 ;980
000012  460e              MOV      r6,r1                 ;980
000014  2801              CMP      r0,#1
000016  d16e              BNE      |L21.246|
;;;990      {
;;;991        if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
000018  b30e              CBZ      r6,|L21.94|
00001a  f1b90f00          CMP      r9,#0
00001e  d01e              BEQ      |L21.94|
000020  b1ed              CBZ      r5,|L21.94|
;;;992        {
;;;993          return  HAL_ERROR;
;;;994        }
;;;995    
;;;996        /* Process Locked */
;;;997        __HAL_LOCK(husart);
000022  f8940048          LDRB     r0,[r4,#0x48]
000026  2801              CMP      r0,#1
000028  d065              BEQ      |L21.246|
00002a  2001              MOVS     r0,#1
00002c  f8840048          STRB     r0,[r4,#0x48]
;;;998    
;;;999        husart->ErrorCode = HAL_USART_ERROR_NONE;
000030  f04f0b00          MOV      r11,#0
000034  f8c4b04c          STR      r11,[r4,#0x4c]
;;;1000       husart->State = HAL_USART_STATE_BUSY_RX;
000038  2022              MOVS     r0,#0x22
00003a  f8840049          STRB     r0,[r4,#0x49]
;;;1001   
;;;1002       /* Init tickstart for timeout managment*/
;;;1003       tickstart = HAL_GetTick();
00003e  f7fffffe          BL       HAL_GetTick
;;;1004   
;;;1005       husart->RxXferSize = Size;
000042  9001              STR      r0,[sp,#4]
000044  8625              STRH     r5,[r4,#0x30]
;;;1006       husart->TxXferSize = Size;
000046  8525              STRH     r5,[r4,#0x28]
;;;1007       husart->TxXferCount = Size;
000048  8565              STRH     r5,[r4,#0x2a]
;;;1008       husart->RxXferCount = Size;
00004a  8665              STRH     r5,[r4,#0x32]
;;;1009   
;;;1010       /* Computation of USART mask to apply to RDR register */
;;;1011       USART_MASK_COMPUTATION(husart);
00004c  68a0              LDR      r0,[r4,#8]
00004e  f44f5280          MOV      r2,#0x1000
000052  21ff              MOVS     r1,#0xff
000054  4290              CMP      r0,r2
000056  d108              BNE      |L21.106|
000058  6923              LDR      r3,[r4,#0x10]
00005a  b11b              CBZ      r3,|L21.100|
00005c  e01b              B        |L21.150|
                  |L21.94|
00005e  2001              MOVS     r0,#1                 ;993
                  |L21.96|
;;;1012       uhMask = husart->Mask;
;;;1013   
;;;1014       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1015       if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1016       {
;;;1017         prxdata8bits  = NULL;
;;;1018         ptxdata8bits  = NULL;
;;;1019         ptxdata16bits = (uint16_t *) pTxData;
;;;1020         prxdata16bits = (uint16_t *) pRxData;
;;;1021       }
;;;1022       else
;;;1023       {
;;;1024         prxdata8bits  = pRxData;
;;;1025         ptxdata8bits  = pTxData;
;;;1026         ptxdata16bits = NULL;
;;;1027         prxdata16bits = NULL;
;;;1028       }
;;;1029   
;;;1030   #if defined(USART_CR2_SLVEN)
;;;1031       if ((husart->TxXferCount == 0x01U) || (husart->SlaveMode == USART_SLAVEMODE_ENABLE))
;;;1032   #else
;;;1033       if (husart->TxXferCount == 0x01U)
;;;1034   #endif
;;;1035       {
;;;1036         /* Wait until TXE flag is set to send data */
;;;1037         if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1038         {
;;;1039           return HAL_TIMEOUT;
;;;1040         }
;;;1041         if (ptxdata8bits == NULL)
;;;1042         {
;;;1043           husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
;;;1044           ptxdata16bits++;
;;;1045         }
;;;1046         else
;;;1047         {
;;;1048           husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)uhMask);
;;;1049           ptxdata8bits++;
;;;1050         }
;;;1051   
;;;1052         husart->TxXferCount--;
;;;1053       }
;;;1054   
;;;1055       /* Check the remain data to be sent */
;;;1056       /* rxdatacount is a temporary variable for MISRAC2012-Rule-13.5 */
;;;1057       rxdatacount = husart->RxXferCount;
;;;1058       while ((husart->TxXferCount > 0U) || (rxdatacount > 0U))
;;;1059       {
;;;1060         if (husart->TxXferCount > 0U)
;;;1061         {
;;;1062           /* Wait until TXE flag is set to send data */
;;;1063           if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1064           {
;;;1065             return HAL_TIMEOUT;
;;;1066           }
;;;1067           if (ptxdata8bits == NULL)
;;;1068           {
;;;1069             husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
;;;1070             ptxdata16bits++;
;;;1071           }
;;;1072           else
;;;1073           {
;;;1074             husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)uhMask);
;;;1075             ptxdata8bits++;
;;;1076           }
;;;1077   
;;;1078           husart->TxXferCount--;
;;;1079         }
;;;1080   
;;;1081         if (husart->RxXferCount > 0U)
;;;1082         {
;;;1083           /* Wait for RXNE Flag */
;;;1084           if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1085           {
;;;1086             return HAL_TIMEOUT;
;;;1087           }
;;;1088   
;;;1089           if (prxdata8bits == NULL)
;;;1090           {
;;;1091             *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
;;;1092             prxdata16bits++;
;;;1093           }
;;;1094           else
;;;1095           {
;;;1096             *prxdata8bits = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;1097             prxdata8bits++;
;;;1098           }
;;;1099   
;;;1100           husart->RxXferCount--;
;;;1101         }
;;;1102         rxdatacount = husart->RxXferCount;
;;;1103       }
;;;1104   
;;;1105       /* At end of TxRx process, restore husart->State to Ready */
;;;1106       husart->State = HAL_USART_STATE_READY;
;;;1107   
;;;1108       /* Process Unlocked */
;;;1109       __HAL_UNLOCK(husart);
;;;1110   
;;;1111       return HAL_OK;
;;;1112     }
;;;1113     else
;;;1114     {
;;;1115       return HAL_BUSY;
;;;1116     }
;;;1117   }
000060  e8bd9ffc          POP      {r2-r12,pc}
                  |L21.100|
000064  f24011ff          MOV      r1,#0x1ff             ;1011
000068  e015              B        |L21.150|
                  |L21.106|
00006a  237f              MOVS     r3,#0x7f              ;1011
00006c  b188              CBZ      r0,|L21.146|
00006e  f1b05f80          CMP      r0,#0x10000000        ;1011
000072  d012              BEQ      |L21.154|
000074  f8a4b034          STRH     r11,[r4,#0x34]        ;1011
                  |L21.120|
000078  8ea7              LDRH     r7,[r4,#0x34]         ;1012
00007a  4290              CMP      r0,r2                 ;1015
00007c  d101              BNE      |L21.130|
00007e  6920              LDR      r0,[r4,#0x10]         ;1015
000080  b188              CBZ      r0,|L21.166|
                  |L21.130|
000082  4635              MOV      r5,r6                 ;1025
000084  46c8              MOV      r8,r9                 ;1024
000086  2600              MOVS     r6,#0                 ;1026
000088  46b1              MOV      r9,r6                 ;1027
                  |L21.138|
00008a  8d60              LDRH     r0,[r4,#0x2a]         ;1033
00008c  2801              CMP      r0,#1                 ;1033
00008e  d00e              BEQ      |L21.174|
000090  e01f              B        |L21.210|
                  |L21.146|
000092  6925              LDR      r5,[r4,#0x10]         ;1011
000094  b92d              CBNZ     r5,|L21.162|
                  |L21.150|
000096  86a1              STRH     r1,[r4,#0x34]         ;1011
000098  e7ee              B        |L21.120|
                  |L21.154|
00009a  6921              LDR      r1,[r4,#0x10]         ;1011
00009c  b109              CBZ      r1,|L21.162|
00009e  213f              MOVS     r1,#0x3f              ;1011
0000a0  e7f9              B        |L21.150|
                  |L21.162|
0000a2  86a3              STRH     r3,[r4,#0x34]         ;1011
0000a4  e7e8              B        |L21.120|
                  |L21.166|
0000a6  f04f0800          MOV      r8,#0                 ;1017
0000aa  4645              MOV      r5,r8                 ;1018
0000ac  e7ed              B        |L21.138|
                  |L21.174|
0000ae  f8cda000          STR      r10,[sp,#0]           ;1037
0000b2  2200              MOVS     r2,#0                 ;1037
0000b4  2180              MOVS     r1,#0x80              ;1037
0000b6  4620              MOV      r0,r4                 ;1037
0000b8  9b01              LDR      r3,[sp,#4]            ;1037
0000ba  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000be  bb80              CBNZ     r0,|L21.290|
0000c0  b1b5              CBZ      r5,|L21.240|
0000c2  f8150b01          LDRB     r0,[r5],#1            ;1048
                  |L21.198|
0000c6  6821              LDR      r1,[r4,#0]            ;1048
0000c8  4038              ANDS     r0,r0,r7              ;1048
0000ca  8508              STRH     r0,[r1,#0x28]         ;1048
0000cc  8d60              LDRH     r0,[r4,#0x2a]         ;1052
0000ce  1e40              SUBS     r0,r0,#1              ;1052
0000d0  8560              STRH     r0,[r4,#0x2a]         ;1052
                  |L21.210|
0000d2  8e60              LDRH     r0,[r4,#0x32]         ;1057
0000d4  8d61              LDRH     r1,[r4,#0x2a]         ;1058
0000d6  b3b1              CBZ      r1,|L21.326|
                  |L21.216|
0000d8  8d60              LDRH     r0,[r4,#0x2a]         ;1060
0000da  b1b0              CBZ      r0,|L21.266|
0000dc  f8cda000          STR      r10,[sp,#0]           ;1063
0000e0  2200              MOVS     r2,#0                 ;1063
0000e2  2180              MOVS     r1,#0x80              ;1063
0000e4  4620              MOV      r0,r4                 ;1063
0000e6  9b01              LDR      r3,[sp,#4]            ;1063
0000e8  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ec  b9c8              CBNZ     r0,|L21.290|
0000ee  e003              B        |L21.248|
                  |L21.240|
0000f0  f8360b02          LDRH     r0,[r6],#2            ;1043
0000f4  e7e7              B        |L21.198|
                  |L21.246|
0000f6  e033              B        |L21.352|
                  |L21.248|
0000f8  b1ad              CBZ      r5,|L21.294|
0000fa  f8150b01          LDRB     r0,[r5],#1            ;1074
                  |L21.254|
0000fe  6821              LDR      r1,[r4,#0]            ;1074
000100  4038              ANDS     r0,r0,r7              ;1074
000102  8508              STRH     r0,[r1,#0x28]         ;1074
000104  8d60              LDRH     r0,[r4,#0x2a]         ;1078
000106  1e40              SUBS     r0,r0,#1              ;1078
000108  8560              STRH     r0,[r4,#0x2a]         ;1078
                  |L21.266|
00010a  8e60              LDRH     r0,[r4,#0x32]         ;1081
00010c  2800              CMP      r0,#0                 ;1081
00010e  d0e0              BEQ      |L21.210|
000110  f8cda000          STR      r10,[sp,#0]           ;1084
000114  2200              MOVS     r2,#0                 ;1084
000116  2120              MOVS     r1,#0x20              ;1084
000118  4620              MOV      r0,r4                 ;1084
00011a  9b01              LDR      r3,[sp,#4]            ;1084
00011c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000120  b120              CBZ      r0,|L21.300|
                  |L21.290|
000122  2003              MOVS     r0,#3                 ;1086
000124  e79c              B        |L21.96|
                  |L21.294|
000126  f8360b02          LDRH     r0,[r6],#2            ;1069
00012a  e7e8              B        |L21.254|
                  |L21.300|
00012c  6820              LDR      r0,[r4,#0]            ;1096
00012e  f1b80f00          CMP      r8,#0                 ;1089
000132  8c80              LDRH     r0,[r0,#0x24]         ;1096
000134  ea000007          AND      r0,r0,r7              ;1096
000138  d006              BEQ      |L21.328|
00013a  f8080b01          STRB     r0,[r8],#1            ;1096
                  |L21.318|
00013e  8e60              LDRH     r0,[r4,#0x32]         ;1100
000140  1e40              SUBS     r0,r0,#1              ;1100
000142  8660              STRH     r0,[r4,#0x32]         ;1100
000144  e7c5              B        |L21.210|
                  |L21.326|
000146  e002              B        |L21.334|
                  |L21.328|
000148  f8290b02          STRH     r0,[r9],#2            ;1091
00014c  e7f7              B        |L21.318|
                  |L21.334|
00014e  2800              CMP      r0,#0                 ;1058
000150  d1c2              BNE      |L21.216|
000152  2001              MOVS     r0,#1                 ;1106
000154  f8840049          STRB     r0,[r4,#0x49]         ;1106
000158  f884b048          STRB     r11,[r4,#0x48]        ;1109
00015c  2000              MOVS     r0,#0                 ;1111
00015e  e77f              B        |L21.96|
                  |L21.352|
000160  2002              MOVS     r0,#2                 ;1115
000162  e77d              B        |L21.96|
;;;1118   
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;1622     */
;;;1623   HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1624   {
000004  4604              MOV      r4,r0
;;;1625     HAL_StatusTypeDef status = HAL_OK;
;;;1626     uint32_t *tmp;
;;;1627   
;;;1628     if (husart->State == HAL_USART_STATE_READY)
000006  f8900049          LDRB     r0,[r0,#0x49]
00000a  461d              MOV      r5,r3                 ;1624
00000c  2801              CMP      r0,#1
00000e  d163              BNE      |L22.216|
;;;1629     {
;;;1630       if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
000010  9801              LDR      r0,[sp,#4]
000012  b370              CBZ      r0,|L22.114|
000014  9a02              LDR      r2,[sp,#8]
000016  b362              CBZ      r2,|L22.114|
000018  b35d              CBZ      r5,|L22.114|
;;;1631       {
;;;1632         return HAL_ERROR;
;;;1633       }
;;;1634   
;;;1635       /* Process Locked */
;;;1636       __HAL_LOCK(husart);
00001a  f8941048          LDRB     r1,[r4,#0x48]
00001e  2901              CMP      r1,#1
000020  d05a              BEQ      |L22.216|
000022  2701              MOVS     r7,#1
000024  f8847048          STRB     r7,[r4,#0x48]
;;;1637   
;;;1638       husart->pRxBuffPtr = pRxData;
;;;1639       husart->RxXferSize = Size;
000028  62e2              STR      r2,[r4,#0x2c]
00002a  8625              STRH     r5,[r4,#0x30]
;;;1640       husart->pTxBuffPtr = pTxData;
;;;1641       husart->TxXferSize = Size;
00002c  6260              STR      r0,[r4,#0x24]
00002e  8525              STRH     r5,[r4,#0x28]
;;;1642   
;;;1643       husart->ErrorCode = HAL_USART_ERROR_NONE;
000030  2600              MOVS     r6,#0
000032  64e6              STR      r6,[r4,#0x4c]
;;;1644       husart->State = HAL_USART_STATE_BUSY_TX_RX;
000034  2032              MOVS     r0,#0x32
000036  f8840049          STRB     r0,[r4,#0x49]
00003a  6c60              LDR      r0,[r4,#0x44]         ;1636
00003c  b380              CBZ      r0,|L22.160|
;;;1645   
;;;1646       if ((husart->hdmarx != NULL) && (husart->hdmatx != NULL))
00003e  6c21              LDR      r1,[r4,#0x40]
000040  b371              CBZ      r1,|L22.160|
;;;1647       {
;;;1648         /* Set the USART DMA Rx transfer complete callback */
;;;1649         husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
000042  4926              LDR      r1,|L22.220|
;;;1650   
;;;1651         /* Set the USART DMA Half transfer complete callback */
;;;1652         husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
000044  62c1              STR      r1,[r0,#0x2c]
000046  6c61              LDR      r1,[r4,#0x44]
000048  4825              LDR      r0,|L22.224|
;;;1653   
;;;1654         /* Set the USART DMA Tx transfer complete callback */
;;;1655         husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1656   
;;;1657         /* Set the USART DMA Half transfer complete callback */
;;;1658         husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1659   
;;;1660         /* Set the USART DMA Tx transfer error callback */
;;;1661         husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1662   
;;;1663         /* Set the USART DMA Rx transfer error callback */
;;;1664         husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1665   
;;;1666         /* Enable the USART receive DMA channel */
;;;1667         tmp = (uint32_t *)&pRxData;
;;;1668         status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t *)tmp, Size);
00004a  462b              MOV      r3,r5
00004c  6308              STR      r0,[r1,#0x30]         ;1655
00004e  6c21              LDR      r1,[r4,#0x40]         ;1655
000050  4824              LDR      r0,|L22.228|
000052  62c8              STR      r0,[r1,#0x2c]         ;1658
000054  6c21              LDR      r1,[r4,#0x40]         ;1658
000056  4824              LDR      r0,|L22.232|
000058  6308              STR      r0,[r1,#0x30]         ;1661
00005a  6c21              LDR      r1,[r4,#0x40]         ;1661
00005c  4823              LDR      r0,|L22.236|
00005e  6348              STR      r0,[r1,#0x34]         ;1664
000060  6c61              LDR      r1,[r4,#0x44]         ;1664
000062  6348              STR      r0,[r1,#0x34]
000064  6821              LDR      r1,[r4,#0]
000066  6c60              LDR      r0,[r4,#0x44]
000068  3124              ADDS     r1,r1,#0x24
00006a  f7fffffe          BL       HAL_DMA_Start_IT
;;;1669   
;;;1670         /* Enable the USART transmit DMA channel */
;;;1671         if(status == HAL_OK)
00006e  b128              CBZ      r0,|L22.124|
000070  e00c              B        |L22.140|
                  |L22.114|
000072  e7ff              B        |L22.116|
                  |L22.116|
000074  2001              MOVS     r0,#1                 ;1632
                  |L22.118|
;;;1672         {
;;;1673           tmp = (uint32_t *)&pTxData;
;;;1674           status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;1675         }
;;;1676       }
;;;1677       if(status == HAL_OK)
;;;1678       {
;;;1679         /* Process Unlocked */
;;;1680         __HAL_UNLOCK(husart);
;;;1681   
;;;1682         /* Enable the USART Parity Error Interrupt */
;;;1683         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1684   
;;;1685         /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1686         SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1687   
;;;1688         /* Clear the TC flag in the ICR register */
;;;1689         __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;1690   
;;;1691         /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1692            in the USART CR3 register */
;;;1693         SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1694   
;;;1695         /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1696            in the USART CR3 register */
;;;1697         SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1698   
;;;1699         return HAL_OK;
;;;1700       }
;;;1701       else
;;;1702       {
;;;1703         if(husart->hdmarx != NULL)
;;;1704         {
;;;1705           status = HAL_DMA_Abort(husart->hdmarx);
;;;1706         }
;;;1707   
;;;1708         /* No need to check on error code */
;;;1709         UNUSED(status);
;;;1710   
;;;1711         /* Set error code to DMA */
;;;1712         husart->ErrorCode = HAL_USART_ERROR_DMA;
;;;1713   
;;;1714         /* Process Unlocked */
;;;1715         __HAL_UNLOCK(husart);
;;;1716   
;;;1717         /* Restore husart->State to ready */
;;;1718         husart->State = HAL_USART_STATE_READY;
;;;1719   
;;;1720         return HAL_ERROR;
;;;1721       }
;;;1722     }
;;;1723     else
;;;1724     {
;;;1725       return HAL_BUSY;
;;;1726     }
;;;1727   }
000076  b004              ADD      sp,sp,#0x10
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L22.124|
00007c  6822              LDR      r2,[r4,#0]            ;1674
00007e  9901              LDR      r1,[sp,#4]            ;1674
000080  462b              MOV      r3,r5                 ;1674
000082  3228              ADDS     r2,r2,#0x28           ;1674
000084  6c20              LDR      r0,[r4,#0x40]         ;1674
000086  f7fffffe          BL       HAL_DMA_Start_IT
00008a  b148              CBZ      r0,|L22.160|
                  |L22.140|
00008c  6c60              LDR      r0,[r4,#0x44]         ;1703
00008e  b108              CBZ      r0,|L22.148|
000090  f7fffffe          BL       HAL_DMA_Abort
                  |L22.148|
000094  2010              MOVS     r0,#0x10              ;1712
000096  64e0              STR      r0,[r4,#0x4c]         ;1712
000098  f8046f48          STRB     r6,[r4,#0x48]!        ;1715
00009c  7067              STRB     r7,[r4,#1]            ;1718
00009e  e7e9              B        |L22.116|
                  |L22.160|
0000a0  e7ff              B        |L22.162|
                  |L22.162|
0000a2  f8846048          STRB     r6,[r4,#0x48]         ;1680
0000a6  6820              LDR      r0,[r4,#0]            ;1683
0000a8  6801              LDR      r1,[r0,#0]            ;1683
0000aa  f4417180          ORR      r1,r1,#0x100          ;1683
0000ae  6001              STR      r1,[r0,#0]            ;1683
0000b0  6820              LDR      r0,[r4,#0]            ;1686
0000b2  6881              LDR      r1,[r0,#8]            ;1686
0000b4  f0410101          ORR      r1,r1,#1              ;1686
0000b8  6081              STR      r1,[r0,#8]            ;1686
0000ba  6821              LDR      r1,[r4,#0]            ;1689
0000bc  2040              MOVS     r0,#0x40              ;1689
0000be  6208              STR      r0,[r1,#0x20]         ;1689
0000c0  6820              LDR      r0,[r4,#0]            ;1693
0000c2  6881              LDR      r1,[r0,#8]            ;1693
0000c4  f0410140          ORR      r1,r1,#0x40           ;1693
0000c8  6081              STR      r1,[r0,#8]            ;1693
0000ca  6820              LDR      r0,[r4,#0]            ;1697
0000cc  6881              LDR      r1,[r0,#8]            ;1697
0000ce  f0410180          ORR      r1,r1,#0x80           ;1697
0000d2  6081              STR      r1,[r0,#8]            ;1697
0000d4  2000              MOVS     r0,#0                 ;1699
0000d6  e7ce              B        |L22.118|
                  |L22.216|
0000d8  2002              MOVS     r0,#2                 ;1725
0000da  e7cc              B        |L22.118|
;;;1728   
                          ENDP

                  |L22.220|
                          DCD      USART_DMAReceiveCplt
                  |L22.224|
                          DCD      USART_DMARxHalfCplt
                  |L22.228|
                          DCD      USART_DMATransmitCplt
                  |L22.232|
                          DCD      USART_DMATxHalfCplt
                  |L22.236|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_IT PROC
;;;1320     */
;;;1321   HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1322   {
;;;1323   
;;;1324     if (husart->State == HAL_USART_STATE_READY)
000002  f8904049          LDRB     r4,[r0,#0x49]
000006  2c01              CMP      r4,#1
000008  d150              BNE      |L23.172|
;;;1325     {
;;;1326       if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000a  b1b9              CBZ      r1,|L23.60|
00000c  b1b2              CBZ      r2,|L23.60|
00000e  b1ab              CBZ      r3,|L23.60|
;;;1327       {
;;;1328         return HAL_ERROR;
;;;1329       }
;;;1330   
;;;1331       /* Process Locked */
;;;1332       __HAL_LOCK(husart);
000010  f8904048          LDRB     r4,[r0,#0x48]
000014  2c01              CMP      r4,#1
000016  d049              BEQ      |L23.172|
000018  2401              MOVS     r4,#1
00001a  f8804048          STRB     r4,[r0,#0x48]
;;;1333   
;;;1334       husart->pRxBuffPtr = pRxData;
;;;1335       husart->RxXferSize = Size;
00001e  62c2              STR      r2,[r0,#0x2c]
000020  8603              STRH     r3,[r0,#0x30]
;;;1336       husart->RxXferCount = Size;
000022  8643              STRH     r3,[r0,#0x32]
;;;1337       husart->pTxBuffPtr = pTxData;
;;;1338       husart->TxXferSize = Size;
000024  6241              STR      r1,[r0,#0x24]
000026  8503              STRH     r3,[r0,#0x28]
;;;1339       husart->TxXferCount = Size;
000028  8543              STRH     r3,[r0,#0x2a]
;;;1340   
;;;1341       /* Computation of USART mask to apply to RDR register */
;;;1342       USART_MASK_COMPUTATION(husart);
00002a  6881              LDR      r1,[r0,#8]
00002c  0324              LSLS     r4,r4,#12
00002e  23ff              MOVS     r3,#0xff
000030  2200              MOVS     r2,#0
000032  42a1              CMP      r1,r4
000034  d107              BNE      |L23.70|
000036  6905              LDR      r5,[r0,#0x10]
000038  b115              CBZ      r5,|L23.64|
00003a  e02b              B        |L23.148|
                  |L23.60|
00003c  2001              MOVS     r0,#1                 ;1328
;;;1343   
;;;1344       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1345       husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;1346   
;;;1347   #if defined(USART_CR1_FIFOEN)
;;;1348       /* Configure TxRx interrupt processing */
;;;1349       if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
;;;1350       {
;;;1351         /* Set the Rx ISR function pointer according to the data word length */
;;;1352         if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1353         {
;;;1354           husart->TxISR = USART_TxISR_16BIT_FIFOEN;
;;;1355           husart->RxISR = USART_RxISR_16BIT_FIFOEN;
;;;1356         }
;;;1357         else
;;;1358         {
;;;1359           husart->TxISR = USART_TxISR_8BIT_FIFOEN;
;;;1360           husart->RxISR = USART_RxISR_8BIT_FIFOEN;
;;;1361         }
;;;1362   
;;;1363         /* Process Locked */
;;;1364         __HAL_UNLOCK(husart);
;;;1365   
;;;1366         /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1367         SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1368   
;;;1369         /* Enable the USART Parity Error interrupt  */
;;;1370         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1371   
;;;1372         /* Enable the TX and  RX FIFO Threshold interrupts */
;;;1373         SET_BIT(husart->Instance->CR3, (USART_CR3_TXFTIE | USART_CR3_RXFTIE));
;;;1374       }
;;;1375       else
;;;1376   #endif
;;;1377       {
;;;1378         if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1379         {
;;;1380           husart->TxISR = USART_TxISR_16BIT;
;;;1381           husart->RxISR = USART_RxISR_16BIT;
;;;1382         }
;;;1383         else
;;;1384         {
;;;1385           husart->TxISR = USART_TxISR_8BIT;
;;;1386           husart->RxISR = USART_RxISR_8BIT;
;;;1387         }
;;;1388   
;;;1389         /* Process Locked */
;;;1390         __HAL_UNLOCK(husart);
;;;1391   
;;;1392         /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1393         SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1394   
;;;1395         /* Enable the USART Parity Error and USART Data Register not empty Interrupts */
;;;1396   #if defined(USART_CR1_FIFOEN)
;;;1397         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
;;;1398   #else
;;;1399         SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;1400   #endif
;;;1401   
;;;1402         /* Enable the USART Transmit Data Register Empty Interrupt */
;;;1403   #if defined(USART_CR1_FIFOEN)
;;;1404         SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;1405   #else
;;;1406         SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;1407   #endif
;;;1408       }
;;;1409   
;;;1410       return HAL_OK;
;;;1411     }
;;;1412     else
;;;1413     {
;;;1414       return HAL_BUSY;
;;;1415     }
;;;1416   }
00003e  bd70              POP      {r4-r6,pc}
                  |L23.64|
000040  f24013ff          MOV      r3,#0x1ff             ;1342
000044  e026              B        |L23.148|
                  |L23.70|
000046  257f              MOVS     r5,#0x7f              ;1342
000048  b311              CBZ      r1,|L23.144|
00004a  f1b15f80          CMP      r1,#0x10000000        ;1342
00004e  d023              BEQ      |L23.152|
000050  8682              STRH     r2,[r0,#0x34]         ;1342
                  |L23.82|
000052  64c2              STR      r2,[r0,#0x4c]         ;1344
000054  2332              MOVS     r3,#0x32              ;1345
000056  f8803049          STRB     r3,[r0,#0x49]         ;1345
00005a  42a1              CMP      r1,r4                 ;1378
00005c  d101              BNE      |L23.98|
00005e  6901              LDR      r1,[r0,#0x10]         ;1378
000060  b301              CBZ      r1,|L23.164|
                  |L23.98|
000062  4913              LDR      r1,|L23.176|
000064  63c1              STR      r1,[r0,#0x3c]         ;1386
000066  4913              LDR      r1,|L23.180|
                  |L23.104|
000068  6381              STR      r1,[r0,#0x38]         ;1390
00006a  f8802048          STRB     r2,[r0,#0x48]         ;1390
00006e  6801              LDR      r1,[r0,#0]            ;1393
000070  688a              LDR      r2,[r1,#8]            ;1393
000072  f0420201          ORR      r2,r2,#1              ;1393
000076  608a              STR      r2,[r1,#8]            ;1393
000078  6801              LDR      r1,[r0,#0]            ;1399
00007a  680a              LDR      r2,[r1,#0]            ;1399
00007c  f4427290          ORR      r2,r2,#0x120          ;1399
000080  600a              STR      r2,[r1,#0]            ;1399
000082  6800              LDR      r0,[r0,#0]            ;1406
000084  6801              LDR      r1,[r0,#0]            ;1406
000086  f0410180          ORR      r1,r1,#0x80           ;1406
00008a  6001              STR      r1,[r0,#0]            ;1406
00008c  2000              MOVS     r0,#0                 ;1410
00008e  bd70              POP      {r4-r6,pc}
                  |L23.144|
000090  6906              LDR      r6,[r0,#0x10]         ;1342
000092  b92e              CBNZ     r6,|L23.160|
                  |L23.148|
000094  8683              STRH     r3,[r0,#0x34]         ;1342
000096  e7dc              B        |L23.82|
                  |L23.152|
000098  6903              LDR      r3,[r0,#0x10]         ;1342
00009a  b10b              CBZ      r3,|L23.160|
00009c  233f              MOVS     r3,#0x3f              ;1342
00009e  e7f9              B        |L23.148|
                  |L23.160|
0000a0  8685              STRH     r5,[r0,#0x34]         ;1342
0000a2  e7d6              B        |L23.82|
                  |L23.164|
0000a4  4904              LDR      r1,|L23.184|
0000a6  63c1              STR      r1,[r0,#0x3c]         ;1381
0000a8  4904              LDR      r1,|L23.188|
0000aa  e7dd              B        |L23.104|
                  |L23.172|
0000ac  2002              MOVS     r0,#2                 ;1414
0000ae  bd70              POP      {r4-r6,pc}
;;;1417   
                          ENDP

                  |L23.176|
                          DCD      USART_TxISR_8BIT
                  |L23.180|
                          DCD      USART_RxISR_8BIT
                  |L23.184|
                          DCD      USART_TxISR_16BIT
                  |L23.188|
                          DCD      USART_RxISR_16BIT

                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;1424     */
;;;1425   HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1426   {
000002  4604              MOV      r4,r0
;;;1427     HAL_StatusTypeDef status = HAL_OK;
;;;1428     uint32_t *tmp;
;;;1429   
;;;1430     if (husart->State == HAL_USART_STATE_READY)
000004  f8900049          LDRB     r0,[r0,#0x49]
000008  2801              CMP      r0,#1
00000a  d137              BNE      |L24.124|
;;;1431     {
;;;1432       if ((pTxData == NULL) || (Size == 0U))
00000c  9901              LDR      r1,[sp,#4]
00000e  b339              CBZ      r1,|L24.96|
000010  b332              CBZ      r2,|L24.96|
;;;1433       {
;;;1434         return HAL_ERROR;
;;;1435       }
;;;1436   
;;;1437       /* Process Locked */
;;;1438       __HAL_LOCK(husart);
000012  f8940048          LDRB     r0,[r4,#0x48]
000016  2801              CMP      r0,#1
000018  d030              BEQ      |L24.124|
00001a  2601              MOVS     r6,#1
00001c  f8846048          STRB     r6,[r4,#0x48]
;;;1439   
;;;1440       husart->pTxBuffPtr = pTxData;
;;;1441       husart->TxXferSize = Size;
000020  6261              STR      r1,[r4,#0x24]
000022  8522              STRH     r2,[r4,#0x28]
;;;1442       husart->TxXferCount = Size;
000024  8562              STRH     r2,[r4,#0x2a]
;;;1443   
;;;1444       husart->ErrorCode = HAL_USART_ERROR_NONE;
000026  2500              MOVS     r5,#0
000028  64e5              STR      r5,[r4,#0x4c]
;;;1445       husart->State = HAL_USART_STATE_BUSY_TX;
00002a  2012              MOVS     r0,#0x12
00002c  f8840049          STRB     r0,[r4,#0x49]
000030  6c20              LDR      r0,[r4,#0x40]         ;1438
000032  b1b8              CBZ      r0,|L24.100|
;;;1446   
;;;1447       if (husart->hdmatx != NULL)
;;;1448       {
;;;1449         /* Set the USART DMA transfer complete callback */
;;;1450         husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
000034  4b12              LDR      r3,|L24.128|
;;;1451   
;;;1452         /* Set the USART DMA Half transfer complete callback */
;;;1453         husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
000036  62c3              STR      r3,[r0,#0x2c]
000038  6c23              LDR      r3,[r4,#0x40]
00003a  4812              LDR      r0,|L24.132|
;;;1454   
;;;1455         /* Set the DMA error callback */
;;;1456         husart->hdmatx->XferErrorCallback = USART_DMAError;
00003c  6318              STR      r0,[r3,#0x30]
00003e  6c23              LDR      r3,[r4,#0x40]
000040  4811              LDR      r0,|L24.136|
;;;1457   
;;;1458         /* Enable the USART transmit DMA channel */
;;;1459         tmp = (uint32_t *)&pTxData;
;;;1460         status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
000042  6358              STR      r0,[r3,#0x34]
000044  6820              LDR      r0,[r4,#0]
000046  4613              MOV      r3,r2
000048  6c27              LDR      r7,[r4,#0x40]
00004a  f1000228          ADD      r2,r0,#0x28
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  b130              CBZ      r0,|L24.100|
;;;1461       }
;;;1462   
;;;1463       if(status == HAL_OK)
;;;1464       {
;;;1465         /* Clear the TC flag in the ICR register */
;;;1466         __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;1467   
;;;1468         /* Process Unlocked */
;;;1469         __HAL_UNLOCK(husart);
;;;1470   
;;;1471         /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1472            in the USART CR3 register */
;;;1473         SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1474   
;;;1475         return HAL_OK;
;;;1476       }
;;;1477       else
;;;1478       {
;;;1479         /* Set error code to DMA */
;;;1480         husart->ErrorCode = HAL_USART_ERROR_DMA;
000056  2010              MOVS     r0,#0x10
000058  64e0              STR      r0,[r4,#0x4c]
;;;1481   
;;;1482         /* Process Unlocked */
;;;1483         __HAL_UNLOCK(husart);
00005a  f8045f48          STRB     r5,[r4,#0x48]!
;;;1484   
;;;1485         /* Restore husart->State to ready */
;;;1486         husart->State = HAL_USART_STATE_READY;
00005e  7066              STRB     r6,[r4,#1]
                  |L24.96|
000060  2001              MOVS     r0,#1                 ;1434
;;;1487         
;;;1488         return HAL_ERROR;
;;;1489       }
;;;1490     }
;;;1491     else
;;;1492     {
;;;1493       return HAL_BUSY;
;;;1494     }
;;;1495   }
000062  bdfe              POP      {r1-r7,pc}
                  |L24.100|
000064  6821              LDR      r1,[r4,#0]            ;1466
000066  2040              MOVS     r0,#0x40              ;1466
000068  6208              STR      r0,[r1,#0x20]         ;1466
00006a  f8845048          STRB     r5,[r4,#0x48]         ;1469
00006e  6820              LDR      r0,[r4,#0]            ;1473
000070  6881              LDR      r1,[r0,#8]            ;1473
000072  f0410180          ORR      r1,r1,#0x80           ;1473
000076  6081              STR      r1,[r0,#8]            ;1473
000078  2000              MOVS     r0,#0                 ;1475
00007a  bdfe              POP      {r1-r7,pc}
                  |L24.124|
00007c  2002              MOVS     r0,#2                 ;1493
00007e  bdfe              POP      {r1-r7,pc}
;;;1496   
                          ENDP

                  |L24.128|
                          DCD      USART_DMATransmitCplt
                  |L24.132|
                          DCD      USART_DMATxHalfCplt
                  |L24.136|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_IT PROC
;;;1125     */
;;;1126   HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  f8903049          LDRB     r3,[r0,#0x49]
;;;1127   {
;;;1128     if (husart->State == HAL_USART_STATE_READY)
000004  2b01              CMP      r3,#1
000006  d127              BNE      |L25.88|
;;;1129     {
;;;1130       if ((pTxData == NULL) || (Size == 0U))
000008  b1a9              CBZ      r1,|L25.54|
00000a  b1a2              CBZ      r2,|L25.54|
;;;1131       {
;;;1132         return HAL_ERROR;
;;;1133       }
;;;1134   
;;;1135       /* Process Locked */
;;;1136       __HAL_LOCK(husart);
00000c  f8903048          LDRB     r3,[r0,#0x48]
000010  2b01              CMP      r3,#1
000012  d021              BEQ      |L25.88|
000014  2301              MOVS     r3,#1
000016  f8803048          STRB     r3,[r0,#0x48]
;;;1137   
;;;1138       husart->pTxBuffPtr  = pTxData;
;;;1139       husart->TxXferSize  = Size;
00001a  6241              STR      r1,[r0,#0x24]
00001c  8502              STRH     r2,[r0,#0x28]
;;;1140       husart->TxXferCount = Size;
00001e  8542              STRH     r2,[r0,#0x2a]
;;;1141       husart->TxISR       = NULL;
000020  2100              MOVS     r1,#0
;;;1142   
;;;1143       husart->ErrorCode = HAL_USART_ERROR_NONE;
000022  63c1              STR      r1,[r0,#0x3c]
000024  64c1              STR      r1,[r0,#0x4c]
;;;1144       husart->State     = HAL_USART_STATE_BUSY_TX;
000026  2212              MOVS     r2,#0x12
000028  f8802049          STRB     r2,[r0,#0x49]
;;;1145   
;;;1146       /* The USART Error Interrupts: (Frame error, noise error, overrun error)
;;;1147       are not managed by the USART Transmit Process to avoid the overrun interrupt
;;;1148       when the usart mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;1149       to benefit for the frame error and noise interrupts the usart mode should be
;;;1150       configured only for transmit "USART_MODE_TX" */
;;;1151   
;;;1152   #if defined(USART_CR1_FIFOEN)
;;;1153       /* Configure Tx interrupt processing */
;;;1154       if (husart->FifoMode == USART_FIFOMODE_ENABLE)
;;;1155       {
;;;1156         /* Set the Tx ISR function pointer according to the data word length */
;;;1157         if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1158         {
;;;1159           husart->TxISR = USART_TxISR_16BIT_FIFOEN;
;;;1160         }
;;;1161         else
;;;1162         {
;;;1163           husart->TxISR = USART_TxISR_8BIT_FIFOEN;
;;;1164         }
;;;1165   
;;;1166         /* Process Unlocked */
;;;1167         __HAL_UNLOCK(husart);
;;;1168   
;;;1169         /* Enable the TX FIFO threshold interrupt */
;;;1170         __HAL_USART_ENABLE_IT(husart, USART_IT_TXFT);
;;;1171       }
;;;1172       else
;;;1173   #endif
;;;1174       {
;;;1175         /* Set the Tx ISR function pointer according to the data word length */
;;;1176         if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00002c  6882              LDR      r2,[r0,#8]
00002e  f5b25f80          CMP      r2,#0x1000
000032  d002              BEQ      |L25.58|
000034  e003              B        |L25.62|
                  |L25.54|
000036  2001              MOVS     r0,#1                 ;1132
;;;1177         {
;;;1178           husart->TxISR = USART_TxISR_16BIT;
;;;1179         }
;;;1180         else
;;;1181         {
;;;1182           husart->TxISR = USART_TxISR_8BIT;
;;;1183         }
;;;1184   
;;;1185         /* Process Unlocked */
;;;1186         __HAL_UNLOCK(husart);
;;;1187   
;;;1188         /* Enable the USART Transmit Data Register Empty Interrupt */
;;;1189         __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;1190       }
;;;1191   
;;;1192       return HAL_OK;
;;;1193     }
;;;1194     else
;;;1195     {
;;;1196       return HAL_BUSY;
;;;1197     }
;;;1198   }
000038  4770              BX       lr
                  |L25.58|
00003a  6902              LDR      r2,[r0,#0x10]         ;1176
00003c  b152              CBZ      r2,|L25.84|
                  |L25.62|
00003e  4a07              LDR      r2,|L25.92|
                  |L25.64|
000040  63c2              STR      r2,[r0,#0x3c]         ;1186
000042  f8801048          STRB     r1,[r0,#0x48]         ;1186
000046  6800              LDR      r0,[r0,#0]            ;1189
000048  6801              LDR      r1,[r0,#0]            ;1189
00004a  f0410180          ORR      r1,r1,#0x80           ;1189
00004e  6001              STR      r1,[r0,#0]            ;1189
000050  2000              MOVS     r0,#0                 ;1192
000052  4770              BX       lr
                  |L25.84|
000054  4a02              LDR      r2,|L25.96|
000056  e7f3              B        |L25.64|
                  |L25.88|
000058  2002              MOVS     r0,#2                 ;1196
00005a  4770              BX       lr
;;;1199   
                          ENDP

                  |L25.92|
                          DCD      USART_TxISR_8BIT
                  |L25.96|
                          DCD      USART_TxISR_16BIT

                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;2403     */
;;;2404   __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2405   {
;;;2406     /* Prevent unused argument(s) compilation warning */
;;;2407     UNUSED(husart);
;;;2408   
;;;2409     /* NOTE : This function should not be modified, when the callback is needed,
;;;2410               the HAL_USART_TxCpltCallback can be implemented in the user file.
;;;2411      */
;;;2412   }
;;;2413   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;2418     */
;;;2419   __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2420   {
;;;2421     /* Prevent unused argument(s) compilation warning */
;;;2422     UNUSED(husart);
;;;2423   
;;;2424     /* NOTE: This function should not be modified, when the callback is needed,
;;;2425              the HAL_USART_TxHalfCpltCallback can be implemented in the user file.
;;;2426      */
;;;2427   }
;;;2428   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;2463     */
;;;2464   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;2465   {
;;;2466     /* Prevent unused argument(s) compilation warning */
;;;2467     UNUSED(husart);
;;;2468   
;;;2469     /* NOTE : This function should not be modified, when the callback is needed,
;;;2470               the HAL_USART_TxRxCpltCallback can be implemented in the user file
;;;2471      */
;;;2472   }
;;;2473   
                          ENDP


                          AREA ||i.USART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  USART_DMAAbortOnError PROC
;;;2784     */
;;;2785   static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2786   {
;;;2787     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2788     husart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  8641              STRH     r1,[r0,#0x32]
;;;2789     husart->TxXferCount = 0U;
000008  8541              STRH     r1,[r0,#0x2a]
;;;2790   
;;;2791   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2792     /* Call registered Error Callback */
;;;2793     husart->ErrorCallback(husart);
;;;2794   #else
;;;2795     /* Call legacy weak Error Callback */
;;;2796     HAL_USART_ErrorCallback(husart);
00000a  f7fffffe          BL       HAL_USART_ErrorCallback
;;;2797   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2798   }
00000e  bd10              POP      {r4,pc}
;;;2799   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;2758     */
;;;2759   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2760   {
;;;2761     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
;;;2762   
;;;2763     husart->RxXferCount = 0U;
000002  6a84              LDR      r4,[r0,#0x28]
000004  2000              MOVS     r0,#0
000006  8660              STRH     r0,[r4,#0x32]
;;;2764     husart->TxXferCount = 0U;
000008  8560              STRH     r0,[r4,#0x2a]
;;;2765     USART_EndTransfer(husart);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_EndTransfer
;;;2766   
;;;2767     husart->ErrorCode |= HAL_USART_ERROR_DMA;
000010  6ce0              LDR      r0,[r4,#0x4c]
000012  f0400010          ORR      r0,r0,#0x10
000016  64e0              STR      r0,[r4,#0x4c]
;;;2768     husart->State = HAL_USART_STATE_READY;
000018  2001              MOVS     r0,#1
00001a  f8840049          STRB     r0,[r4,#0x49]
;;;2769   
;;;2770   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2771     /* Call registered Error Callback */
;;;2772     husart->ErrorCallback(husart);
;;;2773   #else
;;;2774     /* Call legacy weak Error Callback */
;;;2775     HAL_USART_ErrorCallback(husart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       HAL_USART_ErrorCallback
;;;2776   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2777   }
000024  bd10              POP      {r4,pc}
;;;2778   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;2665     */
;;;2666   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2667   {
;;;2668     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
;;;2669   
;;;2670     /* DMA Normal mode */
;;;2671     if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000002  6a84              LDR      r4,[r0,#0x28]
000004  6800              LDR      r0,[r0,#0]
000006  6800              LDR      r0,[r0,#0]
000008  0680              LSLS     r0,r0,#26
00000a  d423              BMI      |L31.84|
;;;2672     {
;;;2673       husart->RxXferCount = 0U;
00000c  2000              MOVS     r0,#0
00000e  8660              STRH     r0,[r4,#0x32]
;;;2674   
;;;2675       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2676       CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
000010  6820              LDR      r0,[r4,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f4217180          BIC      r1,r1,#0x100
000018  6001              STR      r1,[r0,#0]
;;;2677       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00001a  6820              LDR      r0,[r4,#0]
00001c  6881              LDR      r1,[r0,#8]
00001e  f0210101          BIC      r1,r1,#1
000022  6081              STR      r1,[r0,#8]
;;;2678   
;;;2679       /* Disable the DMA RX transfer for the receiver request by resetting the DMAR bit
;;;2680          in USART CR3 register */
;;;2681       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000024  6820              LDR      r0,[r4,#0]
000026  6881              LDR      r1,[r0,#8]
000028  f0210140          BIC      r1,r1,#0x40
00002c  6081              STR      r1,[r0,#8]
;;;2682       /* similarly, disable the DMA TX transfer that was started to provide the
;;;2683          clock to the slave device */
;;;2684       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00002e  6820              LDR      r0,[r4,#0]
000030  6881              LDR      r1,[r0,#8]
000032  f0210180          BIC      r1,r1,#0x80
000036  6081              STR      r1,[r0,#8]
;;;2685   
;;;2686       if (husart->State == HAL_USART_STATE_BUSY_RX)
000038  f8940049          LDRB     r0,[r4,#0x49]
00003c  2822              CMP      r0,#0x22
;;;2687       {
;;;2688   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2689         /* Call registered Rx Complete Callback */
;;;2690         husart->RxCpltCallback(husart);
;;;2691   #else
;;;2692         /* Call legacy weak Rx Complete Callback */
;;;2693         HAL_USART_RxCpltCallback(husart);
;;;2694   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2695       }
;;;2696       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;2697       else
;;;2698       {
;;;2699   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2700         /* Call registered Tx Rx Complete Callback */
;;;2701         husart->TxRxCpltCallback(husart);
;;;2702   #else
;;;2703         /* Call legacy weak Tx Rx Complete Callback */
;;;2704         HAL_USART_TxRxCpltCallback(husart);
00003e  4620              MOV      r0,r4
000040  d005              BEQ      |L31.78|
000042  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L31.70|
;;;2705   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2706       }
;;;2707       husart->State = HAL_USART_STATE_READY;
000046  2001              MOVS     r0,#1
000048  f8840049          STRB     r0,[r4,#0x49]
;;;2708     }
;;;2709     /* DMA circular mode */
;;;2710     else
;;;2711     {
;;;2712       if (husart->State == HAL_USART_STATE_BUSY_RX)
;;;2713       {
;;;2714   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2715         /* Call registered Rx Complete Callback */
;;;2716         husart->RxCpltCallback(husart);
;;;2717   #else
;;;2718         /* Call legacy weak Rx Complete Callback */
;;;2719         HAL_USART_RxCpltCallback(husart);
;;;2720   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2721       }
;;;2722       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;2723       else
;;;2724       {
;;;2725   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2726         /* Call registered Tx Rx Complete Callback */
;;;2727         husart->TxRxCpltCallback(husart);
;;;2728   #else
;;;2729         /* Call legacy weak Tx Rx Complete Callback */
;;;2730         HAL_USART_TxRxCpltCallback(husart);
;;;2731   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2732       }
;;;2733     }
;;;2734   }
00004c  bd10              POP      {r4,pc}
                  |L31.78|
00004e  f7fffffe          BL       HAL_USART_RxCpltCallback
000052  e7f8              B        |L31.70|
                  |L31.84|
000054  f8940049          LDRB     r0,[r4,#0x49]         ;2712
000058  2822              CMP      r0,#0x22              ;2712
00005a  4620              MOV      r0,r4                 ;2730
00005c  d002              BEQ      |L31.100|
00005e  f7fffffe          BL       HAL_USART_TxRxCpltCallback
000062  bd10              POP      {r4,pc}
                  |L31.100|
000064  f7fffffe          BL       HAL_USART_RxCpltCallback
000068  bd10              POP      {r4,pc}
;;;2735   
                          ENDP


                          AREA ||i.USART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMARxAbortCallback PROC
;;;2855     */
;;;2856   static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2857   {
;;;2858     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2859   
;;;2860     husart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6c41              LDR      r1,[r0,#0x44]
;;;2861   
;;;2862     /* Check if an Abort process is still ongoing */
;;;2863     if (husart->hdmatx != NULL)
000008  638a              STR      r2,[r1,#0x38]
00000a  6c01              LDR      r1,[r0,#0x40]         ;2857
00000c  b111              CBZ      r1,|L32.20|
;;;2864     {
;;;2865       if (husart->hdmatx->XferAbortCallback != NULL)
00000e  6b89              LDR      r1,[r1,#0x38]
000010  2900              CMP      r1,#0
000012  d10a              BNE      |L32.42|
                  |L32.20|
;;;2866       {
;;;2867         return;
;;;2868       }
;;;2869     }
;;;2870   
;;;2871     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2872     husart->TxXferCount = 0U;
000014  8542              STRH     r2,[r0,#0x2a]
;;;2873     husart->RxXferCount = 0U;
000016  8642              STRH     r2,[r0,#0x32]
;;;2874   
;;;2875     /* Reset errorCode */
;;;2876     husart->ErrorCode = HAL_USART_ERROR_NONE;
000018  64c2              STR      r2,[r0,#0x4c]
;;;2877   
;;;2878     /* Clear the Error flags in the ICR register */
;;;2879     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
00001a  6802              LDR      r2,[r0,#0]
00001c  210f              MOVS     r1,#0xf
00001e  6211              STR      r1,[r2,#0x20]
;;;2880   
;;;2881     /* Restore husart->State to Ready */
;;;2882     husart->State  = HAL_USART_STATE_READY;
000020  2101              MOVS     r1,#1
000022  f8801049          STRB     r1,[r0,#0x49]
;;;2883   
;;;2884     /* Call user Abort complete callback */
;;;2885   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2886     /* Call registered Abort Complete Callback */
;;;2887     husart->AbortCpltCallback(husart);
;;;2888   #else
;;;2889     /* Call legacy weak Abort Complete Callback */
;;;2890     HAL_USART_AbortCpltCallback(husart);
000026  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L32.42|
;;;2891   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2892   }
00002a  bd10              POP      {r4,pc}
;;;2893   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;2740     */
;;;2741   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2742   {
;;;2743     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2744   
;;;2745   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2746     /* Call registered Rx Half Complete Callback */
;;;2747     husart->RxHalfCpltCallback(husart);
;;;2748   #else
;;;2749     /* Call legacy weak Rx Half Complete Callback */
;;;2750     HAL_USART_RxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;2751   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2752   }
000008  bd10              POP      {r4,pc}
;;;2753   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;2607     */
;;;2608   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2609   {
000002  4601              MOV      r1,r0
;;;2610     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
000004  6a80              LDR      r0,[r0,#0x28]
;;;2611   
;;;2612     /* DMA Normal mode */
;;;2613     if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d410              BMI      |L34.48|
;;;2614     {
;;;2615       husart->TxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  8541              STRH     r1,[r0,#0x2a]
;;;2616   
;;;2617       if (husart->State == HAL_USART_STATE_BUSY_TX)
000012  f8901049          LDRB     r1,[r0,#0x49]
000016  2912              CMP      r1,#0x12
000018  d109              BNE      |L34.46|
;;;2618       {
;;;2619         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;2620            in the USART CR3 register */
;;;2621         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00001a  6801              LDR      r1,[r0,#0]
00001c  688a              LDR      r2,[r1,#8]
00001e  f0220280          BIC      r2,r2,#0x80
000022  608a              STR      r2,[r1,#8]
;;;2622   
;;;2623         /* Enable the USART Transmit Complete Interrupt */
;;;2624         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000024  6800              LDR      r0,[r0,#0]
000026  6801              LDR      r1,[r0,#0]
000028  f0410140          ORR      r1,r1,#0x40
00002c  6001              STR      r1,[r0,#0]
                  |L34.46|
;;;2625       }
;;;2626     }
;;;2627     /* DMA Circular mode */
;;;2628     else
;;;2629     {
;;;2630       if (husart->State == HAL_USART_STATE_BUSY_TX)
;;;2631       {
;;;2632   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2633         /* Call registered Tx Complete Callback */
;;;2634         husart->TxCpltCallback(husart);
;;;2635   #else
;;;2636         /* Call legacy weak Tx Complete Callback */
;;;2637         HAL_USART_TxCpltCallback(husart);
;;;2638   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2639       }
;;;2640     }
;;;2641   }
00002e  bd10              POP      {r4,pc}
                  |L34.48|
000030  f8901049          LDRB     r1,[r0,#0x49]         ;2630
000034  2912              CMP      r1,#0x12              ;2630
000036  d1fa              BNE      |L34.46|
000038  f7fffffe          BL       HAL_USART_TxCpltCallback
00003c  bd10              POP      {r4,pc}
;;;2642   
                          ENDP


                          AREA ||i.USART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMATxAbortCallback PROC
;;;2807     */
;;;2808   static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2809   {
;;;2810     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2811   
;;;2812     husart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6c01              LDR      r1,[r0,#0x40]
;;;2813   
;;;2814     /* Check if an Abort process is still ongoing */
;;;2815     if (husart->hdmarx != NULL)
000008  638a              STR      r2,[r1,#0x38]
00000a  6c41              LDR      r1,[r0,#0x44]         ;2809
00000c  b111              CBZ      r1,|L35.20|
;;;2816     {
;;;2817       if (husart->hdmarx->XferAbortCallback != NULL)
00000e  6b89              LDR      r1,[r1,#0x38]
000010  2900              CMP      r1,#0
000012  d10a              BNE      |L35.42|
                  |L35.20|
;;;2818       {
;;;2819         return;
;;;2820       }
;;;2821     }
;;;2822   
;;;2823     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2824     husart->TxXferCount = 0U;
000014  8542              STRH     r2,[r0,#0x2a]
;;;2825     husart->RxXferCount = 0U;
000016  8642              STRH     r2,[r0,#0x32]
;;;2826   
;;;2827     /* Reset errorCode */
;;;2828     husart->ErrorCode = HAL_USART_ERROR_NONE;
000018  64c2              STR      r2,[r0,#0x4c]
;;;2829   
;;;2830     /* Clear the Error flags in the ICR register */
;;;2831     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
00001a  6802              LDR      r2,[r0,#0]
00001c  210f              MOVS     r1,#0xf
00001e  6211              STR      r1,[r2,#0x20]
;;;2832   
;;;2833     /* Restore husart->State to Ready */
;;;2834     husart->State = HAL_USART_STATE_READY;
000020  2101              MOVS     r1,#1
000022  f8801049          STRB     r1,[r0,#0x49]
;;;2835   
;;;2836     /* Call user Abort complete callback */
;;;2837   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2838     /* Call registered Abort Complete Callback */
;;;2839     husart->AbortCpltCallback(husart);
;;;2840   #else
;;;2841     /* Call legacy weak Abort Complete Callback */
;;;2842     HAL_USART_AbortCpltCallback(husart);
000026  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L35.42|
;;;2843   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2844   
;;;2845   }
00002a  bd10              POP      {r4,pc}
;;;2846   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;2647     */
;;;2648   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2649   {
;;;2650     USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2651   
;;;2652   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;2653     /* Call registered Tx Half Complete Callback */
;;;2654     husart->TxHalfCpltCallback(husart);
;;;2655   #else
;;;2656     /* Call legacy weak Tx Half Complete Callback */
;;;2657     HAL_USART_TxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;2658   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;2659   }
000008  bd10              POP      {r4,pc}
;;;2660   
                          ENDP


                          AREA ||i.USART_EndTransfer||, CODE, READONLY, ALIGN=1

                  USART_EndTransfer PROC
;;;2586     */
;;;2587   static void USART_EndTransfer(USART_HandleTypeDef *husart)
000000  6801              LDR      r1,[r0,#0]
;;;2588   {
;;;2589   #if defined(USART_CR1_FIFOEN)
;;;2590     /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2591     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
;;;2592     CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
;;;2593   #else
;;;2594     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2595     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000002  680a              LDR      r2,[r1,#0]
000004  f42272f0          BIC      r2,r2,#0x1e0
000008  600a              STR      r2,[r1,#0]
;;;2596     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  688a              LDR      r2,[r1,#8]
00000e  f0220201          BIC      r2,r2,#1
000012  608a              STR      r2,[r1,#8]
;;;2597   #endif
;;;2598   
;;;2599     /* At end of process, restore husart->State to Ready */
;;;2600     husart->State = HAL_USART_STATE_READY;
000014  2101              MOVS     r1,#1
000016  f8801049          STRB     r1,[r0,#0x49]
;;;2601   }
00001a  4770              BX       lr
;;;2602   
                          ENDP


                          AREA ||i.USART_RxISR_16BIT||, CODE, READONLY, ALIGN=1

                  USART_RxISR_16BIT PROC
;;;3422     */
;;;3423   static void USART_RxISR_16BIT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;3424   {
;;;3425     const HAL_USART_StateTypeDef state = husart->State;
000002  f8901049          LDRB     r1,[r0,#0x49]
;;;3426     uint16_t txdatacount;
;;;3427     uint16_t *tmp;
;;;3428     uint16_t uhMask = husart->Mask;
000006  8e82              LDRH     r2,[r0,#0x34]
;;;3429   
;;;3430     if ((state == HAL_USART_STATE_BUSY_RX) ||
000008  2922              CMP      r1,#0x22
00000a  d001              BEQ      |L38.16|
;;;3431         (state == HAL_USART_STATE_BUSY_TX_RX))
00000c  2932              CMP      r1,#0x32
00000e  d111              BNE      |L38.52|
                  |L38.16|
;;;3432     {
;;;3433       tmp = (uint16_t *) husart->pRxBuffPtr;
;;;3434       *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
000010  6804              LDR      r4,[r0,#0]
000012  6ac3              LDR      r3,[r0,#0x2c]
000014  8ca4              LDRH     r4,[r4,#0x24]
000016  4014              ANDS     r4,r4,r2
000018  801c              STRH     r4,[r3,#0]
;;;3435       husart->pRxBuffPtr += 2U;
00001a  6ac2              LDR      r2,[r0,#0x2c]
00001c  1c92              ADDS     r2,r2,#2
;;;3436       husart->RxXferCount--;
00001e  62c2              STR      r2,[r0,#0x2c]
000020  8e42              LDRH     r2,[r0,#0x32]
000022  1e52              SUBS     r2,r2,#1
000024  8642              STRH     r2,[r0,#0x32]
;;;3437   
;;;3438       if (husart->RxXferCount == 0U)
000026  8e42              LDRH     r2,[r0,#0x32]
000028  b12a              CBZ      r2,|L38.54|
;;;3439       {
;;;3440         /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
;;;3441   #if defined(USART_CR1_FIFOEN)
;;;3442         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;3443   #else
;;;3444         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;3445   #endif
;;;3446   
;;;3447         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3448         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;3449   
;;;3450         /* Clear RxISR function pointer */
;;;3451         husart->RxISR = NULL;
;;;3452   
;;;3453         /* txdatacount is a temporary variable for MISRAC2012-Rule-13.5 */
;;;3454         txdatacount = husart->TxXferCount;
;;;3455   
;;;3456         if (state == HAL_USART_STATE_BUSY_RX)
;;;3457         {
;;;3458   #if defined(USART_CR2_SLVEN)
;;;3459           /* Clear SPI slave underrun flag and discard transmit data */
;;;3460           if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
;;;3461           {
;;;3462             __HAL_USART_CLEAR_UDRFLAG(husart);
;;;3463             __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
;;;3464           }
;;;3465   #endif
;;;3466   
;;;3467           /* Rx process is completed, restore husart->State to Ready */
;;;3468           husart->State = HAL_USART_STATE_READY;
;;;3469   
;;;3470   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;3471           /* Call registered Rx Complete Callback */
;;;3472           husart->RxCpltCallback(husart);
;;;3473   #else
;;;3474           /* Call legacy weak Rx Complete Callback */
;;;3475           HAL_USART_RxCpltCallback(husart);
;;;3476   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;3477         }
;;;3478         else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
;;;3479                  (txdatacount == 0U))
;;;3480         {
;;;3481           /* TxRx process is completed, restore husart->State to Ready */
;;;3482           husart->State = HAL_USART_STATE_READY;
;;;3483   
;;;3484   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;3485           /* Call registered Tx Rx Complete Callback */
;;;3486           husart->TxRxCpltCallback(husart);
;;;3487   #else
;;;3488           /* Call legacy weak Tx Rx Complete Callback */
;;;3489           HAL_USART_TxRxCpltCallback(husart);
;;;3490   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;3491         }
;;;3492         else
;;;3493         {
;;;3494           /* Nothing to do */
;;;3495         }
;;;3496       }
;;;3497   #if defined(USART_CR2_SLVEN)
;;;3498       else if ((state == HAL_USART_STATE_BUSY_RX) &&
;;;3499                (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
;;;3500   #else
;;;3501       else if (state == HAL_USART_STATE_BUSY_RX)
00002a  2922              CMP      r1,#0x22
00002c  d102              BNE      |L38.52|
;;;3502   #endif
;;;3503       {
;;;3504         /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
;;;3505         husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
00002e  6800              LDR      r0,[r0,#0]
000030  21ff              MOVS     r1,#0xff
000032  8501              STRH     r1,[r0,#0x28]
                  |L38.52|
;;;3506       }
;;;3507       else
;;;3508       {
;;;3509         /* Nothing to do */
;;;3510       }
;;;3511     }
;;;3512   }
000034  bd10              POP      {r4,pc}
                  |L38.54|
000036  6802              LDR      r2,[r0,#0]            ;3444
000038  6813              LDR      r3,[r2,#0]            ;3444
00003a  f4237390          BIC      r3,r3,#0x120          ;3444
00003e  6013              STR      r3,[r2,#0]            ;3444
000040  6802              LDR      r2,[r0,#0]            ;3448
000042  6893              LDR      r3,[r2,#8]            ;3448
000044  f0230301          BIC      r3,r3,#1              ;3448
000048  6093              STR      r3,[r2,#8]            ;3448
00004a  2200              MOVS     r2,#0                 ;3451
00004c  6382              STR      r2,[r0,#0x38]         ;3454
00004e  8d42              LDRH     r2,[r0,#0x2a]         ;3454
000050  2301              MOVS     r3,#1                 ;3468
000052  2922              CMP      r1,#0x22              ;3456
000054  d00a              BEQ      |L38.108|
000056  6801              LDR      r1,[r0,#0]            ;3478
000058  6809              LDR      r1,[r1,#0]            ;3478
00005a  0649              LSLS     r1,r1,#25             ;3478
00005c  d4ea              BMI      |L38.52|
00005e  2a00              CMP      r2,#0                 ;3479
000060  d1e8              BNE      |L38.52|
000062  f8803049          STRB     r3,[r0,#0x49]         ;3482
000066  f7fffffe          BL       HAL_USART_TxRxCpltCallback
00006a  bd10              POP      {r4,pc}
                  |L38.108|
00006c  f8803049          STRB     r3,[r0,#0x49]         ;3468
000070  f7fffffe          BL       HAL_USART_RxCpltCallback
000074  bd10              POP      {r4,pc}
;;;3513   
                          ENDP


                          AREA ||i.USART_RxISR_8BIT||, CODE, READONLY, ALIGN=1

                  USART_RxISR_8BIT PROC
;;;3324     */
;;;3325   static void USART_RxISR_8BIT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;3326   {
;;;3327     const HAL_USART_StateTypeDef state = husart->State;
000002  f8901049          LDRB     r1,[r0,#0x49]
;;;3328     uint16_t txdatacount;
;;;3329     uint16_t uhMask = husart->Mask;
000006  8e82              LDRH     r2,[r0,#0x34]
;;;3330   
;;;3331     if ((state == HAL_USART_STATE_BUSY_RX) ||
000008  2922              CMP      r1,#0x22
00000a  d001              BEQ      |L39.16|
;;;3332         (state == HAL_USART_STATE_BUSY_TX_RX))
00000c  2932              CMP      r1,#0x32
00000e  d111              BNE      |L39.52|
                  |L39.16|
;;;3333     {
;;;3334       *husart->pRxBuffPtr = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
000010  6803              LDR      r3,[r0,#0]
000012  8c9b              LDRH     r3,[r3,#0x24]
000014  4013              ANDS     r3,r3,r2
000016  6ac2              LDR      r2,[r0,#0x2c]
000018  7013              STRB     r3,[r2,#0]
;;;3335       husart->pRxBuffPtr++;
00001a  6ac2              LDR      r2,[r0,#0x2c]
00001c  1c52              ADDS     r2,r2,#1
;;;3336       husart->RxXferCount--;
00001e  62c2              STR      r2,[r0,#0x2c]
000020  8e42              LDRH     r2,[r0,#0x32]
000022  1e52              SUBS     r2,r2,#1
000024  8642              STRH     r2,[r0,#0x32]
;;;3337   
;;;3338       if (husart->RxXferCount == 0U)
000026  8e42              LDRH     r2,[r0,#0x32]
000028  b12a              CBZ      r2,|L39.54|
;;;3339       {
;;;3340         /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
;;;3341   #if defined(USART_CR1_FIFOEN)
;;;3342         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;3343   #else
;;;3344         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;3345   #endif
;;;3346   
;;;3347         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3348         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;3349   
;;;3350         /* Clear RxISR function pointer */
;;;3351         husart->RxISR = NULL;
;;;3352   
;;;3353         /* txdatacount is a temporary variable for MISRAC2012-Rule-13.5 */
;;;3354         txdatacount = husart->TxXferCount;
;;;3355   
;;;3356         if (state == HAL_USART_STATE_BUSY_RX)
;;;3357         {
;;;3358   #if defined(USART_CR2_SLVEN)
;;;3359           /* Clear SPI slave underrun flag and discard transmit data */
;;;3360           if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
;;;3361           {
;;;3362             __HAL_USART_CLEAR_UDRFLAG(husart);
;;;3363             __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
;;;3364           }
;;;3365   #endif
;;;3366   
;;;3367           /* Rx process is completed, restore husart->State to Ready */
;;;3368           husart->State = HAL_USART_STATE_READY;
;;;3369   
;;;3370   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;3371           /* Call registered Rx Complete Callback */
;;;3372           husart->RxCpltCallback(husart);
;;;3373   #else
;;;3374           /* Call legacy weak Rx Complete Callback */
;;;3375           HAL_USART_RxCpltCallback(husart);
;;;3376   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;3377         }
;;;3378         else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
;;;3379                  (txdatacount == 0U))
;;;3380         {
;;;3381           /* TxRx process is completed, restore husart->State to Ready */
;;;3382           husart->State = HAL_USART_STATE_READY;
;;;3383   
;;;3384   #if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
;;;3385           /* Call registered Tx Rx Complete Callback */
;;;3386           husart->TxRxCpltCallback(husart);
;;;3387   #else
;;;3388           /* Call legacy weak Tx Rx Complete Callback */
;;;3389           HAL_USART_TxRxCpltCallback(husart);
;;;3390   #endif /* USE_HAL_USART_REGISTER_CALLBACKS */
;;;3391         }
;;;3392         else
;;;3393         {
;;;3394           /* Nothing to do */
;;;3395         }
;;;3396       }
;;;3397   #if defined(USART_CR2_SLVEN)
;;;3398       else if ((state == HAL_USART_STATE_BUSY_RX) &&
;;;3399                (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
;;;3400   #else
;;;3401       else if (state == HAL_USART_STATE_BUSY_RX)
00002a  2922              CMP      r1,#0x22
00002c  d102              BNE      |L39.52|
;;;3402   #endif
;;;3403       {
;;;3404         /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
;;;3405         husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
00002e  6800              LDR      r0,[r0,#0]
000030  21ff              MOVS     r1,#0xff
000032  8501              STRH     r1,[r0,#0x28]
                  |L39.52|
;;;3406       }
;;;3407       else
;;;3408       {
;;;3409         /* Nothing to do */
;;;3410       }
;;;3411     }
;;;3412   }
000034  bd10              POP      {r4,pc}
                  |L39.54|
000036  6802              LDR      r2,[r0,#0]            ;3344
000038  6813              LDR      r3,[r2,#0]            ;3344
00003a  f4237390          BIC      r3,r3,#0x120          ;3344
00003e  6013              STR      r3,[r2,#0]            ;3344
000040  6802              LDR      r2,[r0,#0]            ;3348
000042  6893              LDR      r3,[r2,#8]            ;3348
000044  f0230301          BIC      r3,r3,#1              ;3348
000048  6093              STR      r3,[r2,#8]            ;3348
00004a  2200              MOVS     r2,#0                 ;3351
00004c  6382              STR      r2,[r0,#0x38]         ;3354
00004e  8d42              LDRH     r2,[r0,#0x2a]         ;3354
000050  2301              MOVS     r3,#1                 ;3368
000052  2922              CMP      r1,#0x22              ;3356
000054  d00a              BEQ      |L39.108|
000056  6801              LDR      r1,[r0,#0]            ;3378
000058  6809              LDR      r1,[r1,#0]            ;3378
00005a  0649              LSLS     r1,r1,#25             ;3378
00005c  d4ea              BMI      |L39.52|
00005e  2a00              CMP      r2,#0                 ;3379
000060  d1e8              BNE      |L39.52|
000062  f8803049          STRB     r3,[r0,#0x49]         ;3382
000066  f7fffffe          BL       HAL_USART_TxRxCpltCallback
00006a  bd10              POP      {r4,pc}
                  |L39.108|
00006c  f8803049          STRB     r3,[r0,#0x49]         ;3368
000070  f7fffffe          BL       HAL_USART_RxCpltCallback
000074  bd10              POP      {r4,pc}
;;;3413   
                          ENDP


                          AREA ||i.USART_SetConfig||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;2930     */
;;;2931   static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;2932   {
000002  4604              MOV      r4,r0
;;;2933     uint32_t tmpreg;
;;;2934     USART_ClockSourceTypeDef clocksource;
;;;2935     HAL_StatusTypeDef ret                = HAL_OK;
;;;2936     uint16_t brrtemp;
;;;2937     uint32_t usartdiv                    = 0x00000000;
;;;2938   
;;;2939     /* Check the parameters */
;;;2940     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;2941     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;2942     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;2943     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));
;;;2944     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;2945     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;2946     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;2947     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;2948   #if defined(USART_PRESC_PRESCALER)
;;;2949     assert_param(IS_USART_PRESCALER(husart->Init.ClockPrescaler));
;;;2950   #endif
;;;2951   
;;;2952     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2953     /* Clear M, PCE, PS, TE and RE bits and configure
;;;2954     *  the USART Word Length, Parity and Mode:
;;;2955     *  set the M bits according to husart->Init.WordLength value
;;;2956     *  set PCE and PS bits according to husart->Init.Parity value
;;;2957     *  set TE and RE bits according to husart->Init.Mode value
;;;2958     *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
;;;2959     tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
000004  6882              LDR      r2,[r0,#8]
000006  6900              LDR      r0,[r0,#0x10]
000008  2500              MOVS     r5,#0                 ;2935
00000a  4302              ORRS     r2,r2,r0
00000c  6960              LDR      r0,[r4,#0x14]
00000e  4629              MOV      r1,r5                 ;2937
000010  f4404000          ORR      r0,r0,#0x8000
000014  4302              ORRS     r2,r2,r0
;;;2960     MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
000016  6820              LDR      r0,[r4,#0]
000018  6803              LDR      r3,[r0,#0]
00001a  4e3f              LDR      r6,|L40.280|
00001c  4033              ANDS     r3,r3,r6
00001e  4313              ORRS     r3,r3,r2
000020  6003              STR      r3,[r0,#0]
;;;2961   
;;;2962     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;2963     /* Clear and configure the USART Clock, CPOL, CPHA, LBCL STOP and SLVEN bits:
;;;2964      * set CPOL bit according to husart->Init.CLKPolarity value
;;;2965      * set CPHA bit according to husart->Init.CLKPhase value
;;;2966      * set LBCL bit according to husart->Init.CLKLastBit value (used in SPI master mode only)
;;;2967      * set STOP[13:12] bits according to husart->Init.StopBits value */
;;;2968     tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
;;;2969     tmpreg |= (uint32_t)husart->Init.CLKLastBit;
000022  6a20              LDR      r0,[r4,#0x20]
000024  e9d42306          LDRD     r2,r3,[r4,#0x18]
;;;2970     tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
000028  431a              ORRS     r2,r2,r3
00002a  f4406000          ORR      r0,r0,#0x800          ;2969
00002e  4302              ORRS     r2,r2,r0
;;;2971     tmpreg |= (uint32_t)husart->Init.StopBits;
000030  68e3              LDR      r3,[r4,#0xc]
;;;2972     MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
000032  6820              LDR      r0,[r4,#0]
000034  4313              ORRS     r3,r3,r2              ;2971
000036  6842              LDR      r2,[r0,#4]
000038  f422527c          BIC      r2,r2,#0x3f00
00003c  431a              ORRS     r2,r2,r3
00003e  6042              STR      r2,[r0,#4]
;;;2973   
;;;2974   #if defined(USART_PRESC_PRESCALER)
;;;2975     /*-------------------------- USART PRESC Configuration -----------------------*/
;;;2976     /* Configure
;;;2977      * - USART Clock Prescaler : set PRESCALER according to husart->Init.ClockPrescaler value */
;;;2978     MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
;;;2979   #endif
;;;2980   
;;;2981     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2982     /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
;;;2983     USART_GETCLOCKSOURCE(husart, clocksource);
000040  4b36              LDR      r3,|L40.284|
000042  6820              LDR      r0,[r4,#0]
000044  4a36              LDR      r2,|L40.288|
000046  4298              CMP      r0,r3
000048  d10d              BNE      |L40.102|
00004a  f8d20088          LDR      r0,[r2,#0x88]
00004e  f0100003          ANDS     r0,r0,#3
000052  d006              BEQ      |L40.98|
000054  2801              CMP      r0,#1
000056  d02f              BEQ      |L40.184|
000058  2802              CMP      r0,#2
00005a  d022              BEQ      |L40.162|
00005c  2803              CMP      r0,#3
00005e  d11f              BNE      |L40.160|
000060  e02c              B        |L40.188|
                  |L40.98|
000062  2001              MOVS     r0,#1
000064  e01d              B        |L40.162|
                  |L40.102|
000066  4b2f              LDR      r3,|L40.292|
000068  4298              CMP      r0,r3
00006a  d10b              BNE      |L40.132|
00006c  f8d20088          LDR      r0,[r2,#0x88]
000070  f010000c          ANDS     r0,r0,#0xc
000074  d015              BEQ      |L40.162|
000076  2804              CMP      r0,#4
000078  d013              BEQ      |L40.162|
00007a  2808              CMP      r0,#8
00007c  d01a              BEQ      |L40.180|
00007e  280c              CMP      r0,#0xc
000080  d10e              BNE      |L40.160|
000082  e01b              B        |L40.188|
                  |L40.132|
000084  4b28              LDR      r3,|L40.296|
000086  4298              CMP      r0,r3
000088  d10a              BNE      |L40.160|
00008a  f8d20088          LDR      r0,[r2,#0x88]
00008e  f0100030          ANDS     r0,r0,#0x30
000092  d006              BEQ      |L40.162|
000094  2810              CMP      r0,#0x10
000096  d00f              BEQ      |L40.184|
000098  2820              CMP      r0,#0x20
00009a  d00b              BEQ      |L40.180|
00009c  2830              CMP      r0,#0x30
00009e  d00d              BEQ      |L40.188|
                  |L40.160|
0000a0  2010              MOVS     r0,#0x10
                  |L40.162|
;;;2984   
;;;2985     switch (clocksource)
0000a2  2809              CMP      r0,#9
0000a4  d222              BCS      |L40.236|
0000a6  e8dff000          TBB      [pc,r0]
0000aa  0b0e              DCB      0x0b,0x0e
0000ac  17211a21          DCB      0x17,0x21,0x1a,0x21
0000b0  21211d00          DCB      0x21,0x21,0x1d,0x00
                  |L40.180|
0000b4  2002              MOVS     r0,#2                 ;2983
0000b6  e7f4              B        |L40.162|
                  |L40.184|
0000b8  2004              MOVS     r0,#4                 ;2983
0000ba  e7f2              B        |L40.162|
                  |L40.188|
0000bc  2008              MOVS     r0,#8                 ;2983
0000be  e7f0              B        |L40.162|
;;;2986     {
;;;2987       case USART_CLOCKSOURCE_PCLK1:
;;;2988   #if defined(USART_PRESC_PRESCALER)
;;;2989         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), husart->Init.BaudRate, husart->Init.ClockPrescaler));
;;;2990   #else
;;;2991         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), husart->Init.BaudRate));
0000c0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
;;;2992   #endif
;;;2993         break;
0000c4  e001              B        |L40.202|
;;;2994       case USART_CLOCKSOURCE_PCLK2:
;;;2995   #if defined(USART_PRESC_PRESCALER)
;;;2996         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), husart->Init.BaudRate, husart->Init.ClockPrescaler));
;;;2997   #else
;;;2998         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), husart->Init.BaudRate));
0000c6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
                  |L40.202|
0000ca  0041              LSLS     r1,r0,#1              ;2991
0000cc  6860              LDR      r0,[r4,#4]            ;2991
                  |L40.206|
0000ce  eb010150          ADD      r1,r1,r0,LSR #1       ;2991
0000d2  fbb1f1f0          UDIV     r1,r1,r0              ;2991
0000d6  e00a              B        |L40.238|
;;;2999   #endif
;;;3000         break;
;;;3001       case USART_CLOCKSOURCE_HSI:
;;;3002   #if defined(USART_PRESC_PRESCALER)
;;;3003         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
;;;3004   #else
;;;3005         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate));
0000d8  4914              LDR      r1,|L40.300|
;;;3006   #endif
;;;3007         break;
0000da  6860              LDR      r0,[r4,#4]
0000dc  e7f7              B        |L40.206|
;;;3008       case USART_CLOCKSOURCE_SYSCLK:
;;;3009   #if defined(USART_PRESC_PRESCALER)
;;;3010         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), husart->Init.BaudRate, husart->Init.ClockPrescaler));
;;;3011   #else
;;;3012         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), husart->Init.BaudRate));
0000de  f7fffffe          BL       HAL_RCC_GetSysClockFreq
;;;3013   #endif
;;;3014         break;
0000e2  e7f2              B        |L40.202|
;;;3015       case USART_CLOCKSOURCE_LSE:
;;;3016   #if defined(USART_PRESC_PRESCALER)
;;;3017         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
;;;3018   #else
;;;3019         usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate));
0000e4  f44f3180          MOV      r1,#0x10000
;;;3020   #endif
;;;3021         break;
0000e8  6860              LDR      r0,[r4,#4]
0000ea  e7f0              B        |L40.206|
                  |L40.236|
;;;3022       default:
;;;3023         ret = HAL_ERROR;
0000ec  2501              MOVS     r5,#1
                  |L40.238|
;;;3024         break;
;;;3025     }
;;;3026   
;;;3027     /* USARTDIV must be greater than or equal to 0d16 and smaller than or equal to ffff */
;;;3028     if ((usartdiv >= USART_BRR_MIN) && (usartdiv <= USART_BRR_MAX))
0000ee  f1a10010          SUB      r0,r1,#0x10
0000f2  f64f72ef          MOV      r2,#0xffef
0000f6  4290              CMP      r0,r2
0000f8  d808              BHI      |L40.268|
;;;3029     {
;;;3030       brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
0000fa  1c52              ADDS     r2,r2,#1
0000fc  ea010002          AND      r0,r1,r2
;;;3031       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
000100  f3c10142          UBFX     r1,r1,#1,#3
000104  4308              ORRS     r0,r0,r1
;;;3032       husart->Instance->BRR = brrtemp;
000106  6821              LDR      r1,[r4,#0]
000108  60c8              STR      r0,[r1,#0xc]
00010a  e000              B        |L40.270|
                  |L40.268|
;;;3033     }
;;;3034     else
;;;3035     {
;;;3036       ret = HAL_ERROR;
00010c  2501              MOVS     r5,#1
                  |L40.270|
;;;3037     }
;;;3038   
;;;3039   #if defined(USART_CR1_FIFOEN)
;;;3040     /* Initialize the number of data to process during RX/TX ISR execution */
;;;3041     husart->NbTxDataToProcess = 1U;
;;;3042     husart->NbRxDataToProcess = 1U;
;;;3043   #endif
;;;3044   
;;;3045     /* Clear ISR function pointers */
;;;3046     husart->RxISR   = NULL;
00010e  2000              MOVS     r0,#0
;;;3047     husart->TxISR   = NULL;
000110  63a0              STR      r0,[r4,#0x38]
;;;3048   
;;;3049     return ret;
000112  63e0              STR      r0,[r4,#0x3c]
000114  4628              MOV      r0,r5
;;;3050   }
000116  bd70              POP      {r4-r6,pc}
;;;3051   
                          ENDP

                  |L40.280|
                          DCD      0xefff69f3
                  |L40.284|
                          DCD      0x40013800
                  |L40.288|
                          DCD      0x40021000
                  |L40.292|
                          DCD      0x40004400
                  |L40.296|
                          DCD      0x40004800
                  |L40.300|
                          DCD      0x01e84800

                          AREA ||i.USART_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  USART_TxISR_16BIT PROC
;;;3141     */
;;;3142   static void USART_TxISR_16BIT(USART_HandleTypeDef *husart)
000000  f8901049          LDRB     r1,[r0,#0x49]
;;;3143   {
;;;3144     const HAL_USART_StateTypeDef state = husart->State;
;;;3145     uint16_t *tmp;
;;;3146   
;;;3147     if ((state == HAL_USART_STATE_BUSY_TX) ||
000004  2912              CMP      r1,#0x12
000006  d001              BEQ      |L41.12|
;;;3148         (state == HAL_USART_STATE_BUSY_TX_RX))
000008  2932              CMP      r1,#0x32
00000a  d10d              BNE      |L41.40|
                  |L41.12|
;;;3149     {
;;;3150       if (husart->TxXferCount == 0U)
00000c  8d41              LDRH     r1,[r0,#0x2a]
00000e  b161              CBZ      r1,|L41.42|
;;;3151       {
;;;3152         /* Disable the USART Transmit data register empty interrupt */
;;;3153         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;3154   
;;;3155         /* Enable the USART Transmit Complete Interrupt */
;;;3156         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
;;;3157       }
;;;3158       else
;;;3159       {
;;;3160         tmp = (uint16_t *) husart->pTxBuffPtr;
;;;3161         husart->Instance->TDR = (uint16_t)(*tmp & 0x01FFU);
000010  6a41              LDR      r1,[r0,#0x24]
000012  6802              LDR      r2,[r0,#0]
000014  8809              LDRH     r1,[r1,#0]
000016  f3c10108          UBFX     r1,r1,#0,#9
00001a  8511              STRH     r1,[r2,#0x28]
;;;3162         husart->pTxBuffPtr += 2U;
00001c  6a41              LDR      r1,[r0,#0x24]
00001e  1c89              ADDS     r1,r1,#2
;;;3163         husart->TxXferCount--;
000020  6241              STR      r1,[r0,#0x24]
000022  8d41              LDRH     r1,[r0,#0x2a]
000024  1e49              SUBS     r1,r1,#1
000026  8541              STRH     r1,[r0,#0x2a]
                  |L41.40|
;;;3164       }
;;;3165     }
;;;3166   }
000028  4770              BX       lr
                  |L41.42|
00002a  6801              LDR      r1,[r0,#0]            ;3153
00002c  680a              LDR      r2,[r1,#0]            ;3153
00002e  f0220280          BIC      r2,r2,#0x80           ;3153
000032  600a              STR      r2,[r1,#0]            ;3153
000034  6800              LDR      r0,[r0,#0]            ;3156
000036  6801              LDR      r1,[r0,#0]            ;3156
000038  f0410140          ORR      r1,r1,#0x40           ;3156
00003c  6001              STR      r1,[r0,#0]            ;3156
00003e  4770              BX       lr
;;;3167   
                          ENDP


                          AREA ||i.USART_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  USART_TxISR_8BIT PROC
;;;3106     */
;;;3107   static void USART_TxISR_8BIT(USART_HandleTypeDef *husart)
000000  f8901049          LDRB     r1,[r0,#0x49]
;;;3108   {
;;;3109     const HAL_USART_StateTypeDef state = husart->State;
;;;3110   
;;;3111     /* Check that a Tx process is ongoing */
;;;3112     if ((state == HAL_USART_STATE_BUSY_TX) ||
000004  2912              CMP      r1,#0x12
000006  d001              BEQ      |L42.12|
;;;3113         (state == HAL_USART_STATE_BUSY_TX_RX))
000008  2932              CMP      r1,#0x32
00000a  d10b              BNE      |L42.36|
                  |L42.12|
;;;3114     {
;;;3115       if (husart->TxXferCount == 0U)
00000c  8d41              LDRH     r1,[r0,#0x2a]
00000e  b151              CBZ      r1,|L42.38|
;;;3116       {
;;;3117         /* Disable the USART Transmit data register empty interrupt */
;;;3118         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;3119   
;;;3120         /* Enable the USART Transmit Complete Interrupt */
;;;3121         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
;;;3122       }
;;;3123       else
;;;3124       {
;;;3125         husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr & (uint8_t)0xFF);
000010  6a41              LDR      r1,[r0,#0x24]
000012  6802              LDR      r2,[r0,#0]
000014  7809              LDRB     r1,[r1,#0]
000016  8511              STRH     r1,[r2,#0x28]
;;;3126         husart->pTxBuffPtr++;
000018  6a41              LDR      r1,[r0,#0x24]
00001a  1c49              ADDS     r1,r1,#1
;;;3127         husart->TxXferCount--;
00001c  6241              STR      r1,[r0,#0x24]
00001e  8d41              LDRH     r1,[r0,#0x2a]
000020  1e49              SUBS     r1,r1,#1
000022  8541              STRH     r1,[r0,#0x2a]
                  |L42.36|
;;;3128       }
;;;3129     }
;;;3130   }
000024  4770              BX       lr
                  |L42.38|
000026  6801              LDR      r1,[r0,#0]            ;3118
000028  680a              LDR      r2,[r1,#0]            ;3118
00002a  f0220280          BIC      r2,r2,#0x80           ;3118
00002e  600a              STR      r2,[r1,#0]            ;3118
000030  6800              LDR      r0,[r0,#0]            ;3121
000032  6801              LDR      r1,[r0,#0]            ;3121
000034  f0410140          ORR      r1,r1,#0x40           ;3121
000038  6001              STR      r1,[r0,#0]            ;3121
00003a  4770              BX       lr
;;;3131   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  USART_WaitOnFlagUntilTimeout PROC
;;;2903     */
;;;2904   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2905   {
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  4688              MOV      r8,r1
00000a  4605              MOV      r5,r0
;;;2906     /* Wait until flag is set */
;;;2907     while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
;;;2908     {
;;;2909       /* Check for the Timeout */
;;;2910       if (Timeout != HAL_MAX_DELAY)
;;;2911       {
;;;2912         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;2913         {
;;;2914           husart->State = HAL_USART_STATE_READY;
;;;2915   
;;;2916           /* Process Unlocked */
;;;2917           __HAL_UNLOCK(husart);
;;;2918   
;;;2919           return HAL_TIMEOUT;
00000c  9c06              LDR      r4,[sp,#0x18]
00000e  e007              B        |L43.32|
                  |L43.16|
000010  1c60              ADDS     r0,r4,#1              ;2910
000012  d005              BEQ      |L43.32|
000014  f7fffffe          BL       HAL_GetTick
000018  1b80              SUBS     r0,r0,r6              ;2912
00001a  42a0              CMP      r0,r4                 ;2912
00001c  d80b              BHI      |L43.54|
00001e  b154              CBZ      r4,|L43.54|
                  |L43.32|
000020  6828              LDR      r0,[r5,#0]            ;2907
000022  69c1              LDR      r1,[r0,#0x1c]         ;2907
000024  ea380001          BICS     r0,r8,r1              ;2907
000028  d00d              BEQ      |L43.70|
00002a  2000              MOVS     r0,#0                 ;2907
                  |L43.44|
00002c  42b8              CMP      r0,r7                 ;2907
00002e  d0ef              BEQ      |L43.16|
;;;2920         }
;;;2921       }
;;;2922     }
;;;2923     return HAL_OK;
000030  2000              MOVS     r0,#0
                  |L43.50|
;;;2924   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L43.54|
000036  2001              MOVS     r0,#1                 ;2914
000038  f8850049          STRB     r0,[r5,#0x49]         ;2914
00003c  2000              MOVS     r0,#0                 ;2917
00003e  f8850048          STRB     r0,[r5,#0x48]         ;2917
000042  2003              MOVS     r0,#3                 ;2919
000044  e7f5              B        |L43.50|
                  |L43.70|
000046  2001              MOVS     r0,#1                 ;2907
000048  e7f0              B        |L43.44|
;;;2925   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32l4xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___21_stm32l4xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32l4xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32l4xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32l4xx_hal_usart_c_32ae8742____RRX|
#line 587
|__asm___21_stm32l4xx_hal_usart_c_32ae8742____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
