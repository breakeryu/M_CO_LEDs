; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal_rcc_ex.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal_rcc_ex.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal_rcc_ex.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_DisableLSCO||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableLSCO PROC
;;;2440     */
;;;2441   void HAL_RCCEx_DisableLSCO(void)
000000  b538              PUSH     {r3-r5,lr}
;;;2442   {
;;;2443     FlagStatus       pwrclkchanged = RESET;
;;;2444     FlagStatus       backupchanged = RESET;
;;;2445   
;;;2446     /* Update LSCOEN bit in Backup Domain control register */
;;;2447     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000002  4d13              LDR      r5,|L1.80|
000004  2400              MOVS     r4,#0                 ;2443
000006  4620              MOV      r0,r4                 ;2444
000008  6da9              LDR      r1,[r5,#0x58]
00000a  00c9              LSLS     r1,r1,#3
00000c  d408              BMI      |L1.32|
;;;2448     {
;;;2449       __HAL_RCC_PWR_CLK_ENABLE();
00000e  6da9              LDR      r1,[r5,#0x58]
000010  f0415180          ORR      r1,r1,#0x10000000
000014  65a9              STR      r1,[r5,#0x58]
000016  6da9              LDR      r1,[r5,#0x58]
;;;2450       pwrclkchanged = SET;
000018  2401              MOVS     r4,#1
00001a  f0015180          AND      r1,r1,#0x10000000     ;2449
00001e  9100              STR      r1,[sp,#0]
                  |L1.32|
;;;2451     }
;;;2452     if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
000020  490c              LDR      r1,|L1.84|
000022  6809              LDR      r1,[r1,#0]
000024  05c9              LSLS     r1,r1,#23
000026  d402              BMI      |L1.46|
;;;2453     {
;;;2454       /* Enable access to the backup domain */
;;;2455       HAL_PWR_EnableBkUpAccess();
000028  f7fffffe          BL       HAL_PWR_EnableBkUpAccess
;;;2456       backupchanged = SET;
00002c  2001              MOVS     r0,#1
                  |L1.46|
;;;2457     }
;;;2458   
;;;2459     CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
00002e  f8d51090          LDR      r1,[r5,#0x90]
000032  f0217180          BIC      r1,r1,#0x1000000
000036  f8c51090          STR      r1,[r5,#0x90]
;;;2460   
;;;2461     /* Restore previous configuration */
;;;2462     if(backupchanged == SET)
00003a  b108              CBZ      r0,|L1.64|
;;;2463     {
;;;2464       /* Disable access to the backup domain */
;;;2465       HAL_PWR_DisableBkUpAccess();
00003c  f7fffffe          BL       HAL_PWR_DisableBkUpAccess
                  |L1.64|
;;;2466     }
;;;2467     if(pwrclkchanged == SET)
000040  2c00              CMP      r4,#0
000042  d003              BEQ      |L1.76|
;;;2468     {
;;;2469       __HAL_RCC_PWR_CLK_DISABLE();
000044  6da8              LDR      r0,[r5,#0x58]
000046  f0205080          BIC      r0,r0,#0x10000000
00004a  65a8              STR      r0,[r5,#0x58]
                  |L1.76|
;;;2470     }
;;;2471   }
00004c  bd38              POP      {r3-r5,pc}
;;;2472   
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40021000
                  |L1.84|
                          DCD      0x40007000

                          AREA ||i.HAL_RCCEx_DisableLSECSS||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableLSECSS PROC
;;;2331     */
;;;2332   void HAL_RCCEx_DisableLSECSS(void)
000000  4805              LDR      r0,|L2.24|
;;;2333   {
;;;2334     CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
000002  f8501f90          LDR      r1,[r0,#0x90]!
000006  f0210120          BIC      r1,r1,#0x20
00000a  f8401978          STR      r1,[r0],#-0x78
;;;2335   
;;;2336     /* Disable LSE CSS IT if any */
;;;2337     __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
00000e  6801              LDR      r1,[r0,#0]
000010  f4217100          BIC      r1,r1,#0x200
000014  6001              STR      r1,[r0,#0]
;;;2338   }
000016  4770              BX       lr
;;;2339   
                          ENDP

                  |L2.24|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_DisableMSIPLLMode||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableMSIPLLMode PROC
;;;2488     */
;;;2489   void HAL_RCCEx_DisableMSIPLLMode(void)
000000  4802              LDR      r0,|L3.12|
;;;2490   {
;;;2491     CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;2492   }
00000a  4770              BX       lr
;;;2493   
                          ENDP

                  |L3.12|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_DisablePLLSAI1||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLSAI1 PROC
;;;2112     */
;;;2113   HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI1(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2114   {
;;;2115     uint32_t tickstart;
;;;2116     HAL_StatusTypeDef status = HAL_OK;
;;;2117   
;;;2118     /* Disable the PLLSAI1 */
;;;2119     __HAL_RCC_PLLSAI1_DISABLE();
000002  4d11              LDR      r5,|L4.72|
000004  2600              MOVS     r6,#0                 ;2116
000006  6828              LDR      r0,[r5,#0]
000008  f0206080          BIC      r0,r0,#0x4000000
00000c  6028              STR      r0,[r5,#0]
;;;2120   
;;;2121     /* Get Start Tick*/
;;;2122     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4604              MOV      r4,r0
;;;2123   
;;;2124     /* Wait till PLLSAI1 is ready */
;;;2125     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
000014  e006              B        |L4.36|
                  |L4.22|
;;;2126     {
;;;2127       if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b00              SUBS     r0,r0,r4
00001c  2802              CMP      r0,#2
00001e  d901              BLS      |L4.36|
;;;2128       {
;;;2129         status = HAL_TIMEOUT;
000020  2603              MOVS     r6,#3
;;;2130         break;
000022  e002              B        |L4.42|
                  |L4.36|
000024  6828              LDR      r0,[r5,#0]            ;2125
000026  0100              LSLS     r0,r0,#4              ;2125
000028  d4f5              BMI      |L4.22|
                  |L4.42|
;;;2131       }
;;;2132     }
;;;2133   
;;;2134     /* Disable the PLLSAI1 Clock outputs */
;;;2135     __HAL_RCC_PLLSAI1CLKOUT_DISABLE(RCC_PLLSAI1CFGR_PLLSAI1PEN|RCC_PLLSAI1CFGR_PLLSAI1QEN|RCC_PLLSAI1CFGR_PLLSAI1REN);
00002a  6928              LDR      r0,[r5,#0x10]
00002c  4907              LDR      r1,|L4.76|
00002e  4008              ANDS     r0,r0,r1
000030  6128              STR      r0,[r5,#0x10]
;;;2136   
;;;2137     /* Reset PLL source to save power if no PLLs on */
;;;2138   #if defined(RCC_PLLSAI2_SUPPORT)
;;;2139     if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI2RDY)) == 0U)
000032  6828              LDR      r0,[r5,#0]
000034  f0105f08          TST      r0,#0x22000000
000038  d103              BNE      |L4.66|
;;;2140     {
;;;2141       MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
00003a  68e8              LDR      r0,[r5,#0xc]
00003c  f0200003          BIC      r0,r0,#3
000040  60e8              STR      r0,[r5,#0xc]
                  |L4.66|
;;;2142     }
;;;2143   #else
;;;2144     if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;2145     {
;;;2146       MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;2147     }
;;;2148   #endif /* RCC_PLLSAI2_SUPPORT */
;;;2149   
;;;2150     return status;
000042  4630              MOV      r0,r6
;;;2151   }
000044  bd70              POP      {r4-r6,pc}
;;;2152   
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      0x40021000
                  |L4.76|
                          DCD      0xfeeeffff

                          AREA ||i.HAL_RCCEx_DisablePLLSAI2||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLSAI2 PROC
;;;2240     */
;;;2241   HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI2(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2242   {
;;;2243     uint32_t tickstart;
;;;2244     HAL_StatusTypeDef status = HAL_OK;
;;;2245   
;;;2246     /* Disable the PLLSAI2 */
;;;2247     __HAL_RCC_PLLSAI2_DISABLE();
000002  4d11              LDR      r5,|L5.72|
000004  2600              MOVS     r6,#0                 ;2244
000006  6828              LDR      r0,[r5,#0]
000008  f0205080          BIC      r0,r0,#0x10000000
00000c  6028              STR      r0,[r5,#0]
;;;2248   
;;;2249     /* Get Start Tick*/
;;;2250     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4604              MOV      r4,r0
;;;2251   
;;;2252     /* Wait till PLLSAI2 is ready */
;;;2253     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
000014  e006              B        |L5.36|
                  |L5.22|
;;;2254     {
;;;2255       if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b00              SUBS     r0,r0,r4
00001c  2802              CMP      r0,#2
00001e  d901              BLS      |L5.36|
;;;2256       {
;;;2257         status = HAL_TIMEOUT;
000020  2603              MOVS     r6,#3
;;;2258         break;
000022  e002              B        |L5.42|
                  |L5.36|
000024  6828              LDR      r0,[r5,#0]            ;2253
000026  0080              LSLS     r0,r0,#2              ;2253
000028  d4f5              BMI      |L5.22|
                  |L5.42|
;;;2259       }
;;;2260     }
;;;2261   
;;;2262     /* Disable the PLLSAI2 Clock outputs */
;;;2263   #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2264     __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2QEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
;;;2265   #else
;;;2266     __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
00002a  6968              LDR      r0,[r5,#0x14]
00002c  4907              LDR      r1,|L5.76|
00002e  4008              ANDS     r0,r0,r1
000030  6168              STR      r0,[r5,#0x14]
;;;2267   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */
;;;2268   
;;;2269     /* Reset PLL source to save power if no PLLs on */
;;;2270     if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY)) == 0U)
000032  6828              LDR      r0,[r5,#0]
000034  f0106f20          TST      r0,#0xa000000
000038  d103              BNE      |L5.66|
;;;2271     {
;;;2272       MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
00003a  68e8              LDR      r0,[r5,#0xc]
00003c  f0200003          BIC      r0,r0,#3
000040  60e8              STR      r0,[r5,#0xc]
                  |L5.66|
;;;2273     }
;;;2274   
;;;2275     return status;
000042  4630              MOV      r0,r6
;;;2276   }
000044  bd70              POP      {r4-r6,pc}
;;;2277   
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      0x40021000
                  |L5.76|
                          DCD      0xfefeffff

                          AREA ||i.HAL_RCCEx_EnableLSCO||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSCO PROC
;;;2393     */
;;;2394   void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2395   {
;;;2396     GPIO_InitTypeDef GPIO_InitStruct;
;;;2397     FlagStatus       pwrclkchanged = RESET;
;;;2398     FlagStatus       backupchanged = RESET;
;;;2399   
;;;2400     /* Check the parameters */
;;;2401     assert_param(IS_RCC_LSCOSOURCE(LSCOSource));
;;;2402   
;;;2403     /* LSCO Pin Clock Enable */
;;;2404     __LSCO_CLK_ENABLE();
000002  4e20              LDR      r6,|L6.132|
000004  4607              MOV      r7,r0                 ;2395
000006  2500              MOVS     r5,#0                 ;2397
000008  6cf0              LDR      r0,[r6,#0x4c]
00000a  b087              SUB      sp,sp,#0x1c           ;2395
00000c  462c              MOV      r4,r5                 ;2398
00000e  f0400001          ORR      r0,r0,#1
000012  64f0              STR      r0,[r6,#0x4c]
000014  6cf0              LDR      r0,[r6,#0x4c]
;;;2405   
;;;2406     /* Configue the LSCO pin in analog mode */
;;;2407     GPIO_InitStruct.Pin = LSCO_PIN;
;;;2408     GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
;;;2409     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
;;;2410     GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;2411     HAL_GPIO_Init(LSCO_GPIO_PORT, &GPIO_InitStruct);
000016  4669              MOV      r1,sp
000018  f0000001          AND      r0,r0,#1              ;2404
00001c  9005              STR      r0,[sp,#0x14]         ;2407
00001e  2004              MOVS     r0,#4                 ;2407
000020  9000              STR      r0,[sp,#0]            ;2408
000022  2003              MOVS     r0,#3                 ;2408
000024  9001              STR      r0,[sp,#4]            ;2409
000026  2002              MOVS     r0,#2                 ;2409
000028  e9cd5002          STRD     r5,r0,[sp,#8]
00002c  f04f4090          MOV      r0,#0x48000000
000030  f7fffffe          BL       HAL_GPIO_Init
;;;2412   
;;;2413     /* Update LSCOSEL clock source in Backup Domain control register */
;;;2414     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000034  6db0              LDR      r0,[r6,#0x58]
000036  00c0              LSLS     r0,r0,#3
000038  d408              BMI      |L6.76|
;;;2415     {
;;;2416       __HAL_RCC_PWR_CLK_ENABLE();
00003a  6db0              LDR      r0,[r6,#0x58]
00003c  f0405080          ORR      r0,r0,#0x10000000
000040  65b0              STR      r0,[r6,#0x58]
000042  6db0              LDR      r0,[r6,#0x58]
;;;2417       pwrclkchanged = SET;
000044  2501              MOVS     r5,#1
000046  f0005080          AND      r0,r0,#0x10000000     ;2416
00004a  9005              STR      r0,[sp,#0x14]
                  |L6.76|
;;;2418     }
;;;2419     if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
00004c  480e              LDR      r0,|L6.136|
00004e  6800              LDR      r0,[r0,#0]
000050  05c0              LSLS     r0,r0,#23
000052  d402              BMI      |L6.90|
;;;2420     {
;;;2421       HAL_PWR_EnableBkUpAccess();
000054  f7fffffe          BL       HAL_PWR_EnableBkUpAccess
;;;2422       backupchanged = SET;
000058  2401              MOVS     r4,#1
                  |L6.90|
;;;2423     }
;;;2424   
;;;2425     MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL | RCC_BDCR_LSCOEN, LSCOSource | RCC_BDCR_LSCOEN);
00005a  f8d60090          LDR      r0,[r6,#0x90]
00005e  f0207040          BIC      r0,r0,#0x3000000
000062  4338              ORRS     r0,r0,r7
000064  f0407080          ORR      r0,r0,#0x1000000
000068  f8c60090          STR      r0,[r6,#0x90]
;;;2426   
;;;2427     if(backupchanged == SET)
00006c  b10c              CBZ      r4,|L6.114|
;;;2428     {
;;;2429       HAL_PWR_DisableBkUpAccess();
00006e  f7fffffe          BL       HAL_PWR_DisableBkUpAccess
                  |L6.114|
;;;2430     }
;;;2431     if(pwrclkchanged == SET)
000072  2d00              CMP      r5,#0
000074  d003              BEQ      |L6.126|
;;;2432     {
;;;2433       __HAL_RCC_PWR_CLK_DISABLE();
000076  6db0              LDR      r0,[r6,#0x58]
000078  f0205080          BIC      r0,r0,#0x10000000
00007c  65b0              STR      r0,[r6,#0x58]
                  |L6.126|
;;;2434     }
;;;2435   }
00007e  b007              ADD      sp,sp,#0x1c
000080  bdf0              POP      {r4-r7,pc}
;;;2436   
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      0x40021000
                  |L6.136|
                          DCD      0x40007000

                          AREA ||i.HAL_RCCEx_EnableLSECSS||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSECSS PROC
;;;2321     */
;;;2322   void HAL_RCCEx_EnableLSECSS(void)
000000  4803              LDR      r0,|L7.16|
;;;2323   {
;;;2324     SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
000002  f8501f90          LDR      r1,[r0,#0x90]!
000006  f0410120          ORR      r1,r1,#0x20
00000a  6001              STR      r1,[r0,#0]
;;;2325   }
00000c  4770              BX       lr
;;;2326   
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_EnableLSECSS_IT||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSECSS_IT PROC
;;;2344     */
;;;2345   void HAL_RCCEx_EnableLSECSS_IT(void)
000000  480b              LDR      r0,|L8.48|
;;;2346   {
;;;2347     /* Enable LSE CSS */
;;;2348     SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
000002  f8501f90          LDR      r1,[r0,#0x90]!
000006  f0410120          ORR      r1,r1,#0x20
00000a  f8401978          STR      r1,[r0],#-0x78
;;;2349   
;;;2350     /* Enable LSE CSS IT */
;;;2351     __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
00000e  6801              LDR      r1,[r0,#0]
000010  f4417100          ORR      r1,r1,#0x200
000014  6001              STR      r1,[r0,#0]
;;;2352   
;;;2353     /* Enable IT on EXTI Line 19 */
;;;2354     __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
000016  4807              LDR      r0,|L8.52|
000018  6801              LDR      r1,[r0,#0]
00001a  f4412100          ORR      r1,r1,#0x80000
00001e  6001              STR      r1,[r0,#0]
;;;2355     __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
000020  4804              LDR      r0,|L8.52|
000022  3008              ADDS     r0,r0,#8
000024  6801              LDR      r1,[r0,#0]
000026  f4412100          ORR      r1,r1,#0x80000
00002a  6001              STR      r1,[r0,#0]
;;;2356   }
00002c  4770              BX       lr
;;;2357   
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x40021000
                  |L8.52|
                          DCD      0x40010400

                          AREA ||i.HAL_RCCEx_EnableMSIPLLMode||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableMSIPLLMode PROC
;;;2478     */
;;;2479   void HAL_RCCEx_EnableMSIPLLMode(void)
000000  4802              LDR      r0,|L9.12|
;;;2480   {
;;;2481     SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;2482   }
00000a  4770              BX       lr
;;;2483   
                          ENDP

                  |L9.12|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_EnablePLLSAI1||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLSAI1 PROC
;;;2044     */
;;;2045   HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2046   {
;;;2047     uint32_t tickstart;
;;;2048     HAL_StatusTypeDef status = HAL_OK;
;;;2049   
;;;2050     /* check for PLLSAI1 Parameters used to output PLLSAI1CLK */
;;;2051     assert_param(IS_RCC_PLLSAI1SOURCE(PLLSAI1Init->PLLSAI1Source));
;;;2052     assert_param(IS_RCC_PLLSAI1M_VALUE(PLLSAI1Init->PLLSAI1M));
;;;2053     assert_param(IS_RCC_PLLSAI1N_VALUE(PLLSAI1Init->PLLSAI1N));
;;;2054     assert_param(IS_RCC_PLLSAI1P_VALUE(PLLSAI1Init->PLLSAI1P));
;;;2055     assert_param(IS_RCC_PLLSAI1Q_VALUE(PLLSAI1Init->PLLSAI1Q));
;;;2056     assert_param(IS_RCC_PLLSAI1R_VALUE(PLLSAI1Init->PLLSAI1R));
;;;2057     assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1Init->PLLSAI1ClockOut));
;;;2058   
;;;2059     /* Disable the PLLSAI1 */
;;;2060     __HAL_RCC_PLLSAI1_DISABLE();
000004  4f1f              LDR      r7,|L10.132|
000006  4604              MOV      r4,r0                 ;2046
000008  2500              MOVS     r5,#0                 ;2048
00000a  6838              LDR      r0,[r7,#0]
00000c  f0206080          BIC      r0,r0,#0x4000000
000010  6038              STR      r0,[r7,#0]
;;;2061   
;;;2062     /* Get Start Tick*/
;;;2063     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4606              MOV      r6,r0
;;;2064   
;;;2065     /* Wait till PLLSAI1 is ready to be updated */
;;;2066     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
000018  e006              B        |L10.40|
                  |L10.26|
;;;2067     {
;;;2068       if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6
000020  2802              CMP      r0,#2
000022  d901              BLS      |L10.40|
                  |L10.36|
;;;2069       {
;;;2070         status = HAL_TIMEOUT;
000024  2503              MOVS     r5,#3
;;;2071         break;
000026  e02a              B        |L10.126|
                  |L10.40|
000028  6838              LDR      r0,[r7,#0]            ;2066
00002a  0100              LSLS     r0,r0,#4              ;2066
00002c  d4f5              BMI      |L10.26|
;;;2072       }
;;;2073     }
;;;2074   
;;;2075     if(status == HAL_OK)
00002e  bb35              CBNZ     r5,|L10.126|
;;;2076     {
;;;2077   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2078       /* Configure the PLLSAI1 Multiplication factor N */
;;;2079       /* Configure the PLLSAI1 Division factors M, P, Q and R */
;;;2080       __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1M, PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
;;;2081   #else
;;;2082       /* Configure the PLLSAI1 Multiplication factor N */
;;;2083       /* Configure the PLLSAI1 Division factors P, Q and R */
;;;2084       __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
000030  68a0              LDR      r0,[r4,#8]
000032  68e1              LDR      r1,[r4,#0xc]
000034  0200              LSLS     r0,r0,#8
000036  0909              LSRS     r1,r1,#4
000038  ea404041          ORR      r0,r0,r1,LSL #17
00003c  8a21              LDRH     r1,[r4,#0x10]
00003e  4a12              LDR      r2,|L10.136|
000040  0849              LSRS     r1,r1,#1
000042  eb025141          ADD      r1,r2,r1,LSL #21
000046  4308              ORRS     r0,r0,r1
000048  7d21              LDRB     r1,[r4,#0x14]
00004a  0849              LSRS     r1,r1,#1
00004c  0112              LSLS     r2,r2,#4
00004e  eb026141          ADD      r1,r2,r1,LSL #25
000052  4308              ORRS     r0,r0,r1
000054  6138              STR      r0,[r7,#0x10]
;;;2085   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;2086       /* Configure the PLLSAI1 Clock output(s) */
;;;2087       __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1Init->PLLSAI1ClockOut);
000056  6938              LDR      r0,[r7,#0x10]
000058  69a1              LDR      r1,[r4,#0x18]
00005a  4308              ORRS     r0,r0,r1
00005c  6138              STR      r0,[r7,#0x10]
;;;2088   
;;;2089       /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
;;;2090       __HAL_RCC_PLLSAI1_ENABLE();
00005e  6838              LDR      r0,[r7,#0]
000060  f0406080          ORR      r0,r0,#0x4000000
000064  6038              STR      r0,[r7,#0]
;;;2091   
;;;2092       /* Get Start Tick*/
;;;2093       tickstart = HAL_GetTick();
000066  f7fffffe          BL       HAL_GetTick
00006a  4604              MOV      r4,r0
;;;2094   
;;;2095       /* Wait till PLLSAI1 is ready */
;;;2096       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
00006c  e004              B        |L10.120|
                  |L10.110|
;;;2097       {
;;;2098         if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
00006e  f7fffffe          BL       HAL_GetTick
000072  1b00              SUBS     r0,r0,r4
000074  2802              CMP      r0,#2
000076  d8d5              BHI      |L10.36|
                  |L10.120|
000078  6838              LDR      r0,[r7,#0]            ;2096
00007a  0100              LSLS     r0,r0,#4              ;2096
00007c  d5f7              BPL      |L10.110|
                  |L10.126|
;;;2099         {
;;;2100           status = HAL_TIMEOUT;
;;;2101           break;
;;;2102         }
;;;2103       }
;;;2104     }
;;;2105   
;;;2106     return status;
00007e  4628              MOV      r0,r5
;;;2107   }
000080  e8bd81f0          POP      {r4-r8,pc}
;;;2108   
                          ENDP

                  |L10.132|
                          DCD      0x40021000
                  |L10.136|
                          DCD      0xffe00000

                          AREA ||i.HAL_RCCEx_EnablePLLSAI2||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLSAI2 PROC
;;;2162     */
;;;2163   HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2164   {
;;;2165     uint32_t tickstart;
;;;2166     HAL_StatusTypeDef status = HAL_OK;
;;;2167   
;;;2168     /* check for PLLSAI2 Parameters used to output PLLSAI2CLK */
;;;2169     assert_param(IS_RCC_PLLSAI2SOURCE(PLLSAI2Init->PLLSAI2Source));
;;;2170     assert_param(IS_RCC_PLLSAI2M_VALUE(PLLSAI2Init->PLLSAI2M));
;;;2171     assert_param(IS_RCC_PLLSAI2N_VALUE(PLLSAI2Init->PLLSAI2N));
;;;2172     assert_param(IS_RCC_PLLSAI2P_VALUE(PLLSAI2Init->PLLSAI2P));
;;;2173   #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2174     assert_param(IS_RCC_PLLSAI2Q_VALUE(PLLSAI2Init->PLLSAI2Q));
;;;2175   #endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
;;;2176     assert_param(IS_RCC_PLLSAI2R_VALUE(PLLSAI2Init->PLLSAI2R));
;;;2177     assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PLLSAI2Init->PLLSAI2ClockOut));
;;;2178   
;;;2179     /* Disable the PLLSAI2 */
;;;2180     __HAL_RCC_PLLSAI2_DISABLE();
000004  4f1d              LDR      r7,|L11.124|
000006  4605              MOV      r5,r0                 ;2164
000008  2400              MOVS     r4,#0                 ;2166
00000a  6838              LDR      r0,[r7,#0]
00000c  f0205080          BIC      r0,r0,#0x10000000
000010  6038              STR      r0,[r7,#0]
;;;2181   
;;;2182     /* Get Start Tick*/
;;;2183     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4606              MOV      r6,r0
;;;2184   
;;;2185     /* Wait till PLLSAI2 is ready to be updated */
;;;2186     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
000018  e006              B        |L11.40|
                  |L11.26|
;;;2187     {
;;;2188       if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6
000020  2802              CMP      r0,#2
000022  d901              BLS      |L11.40|
                  |L11.36|
;;;2189       {
;;;2190         status = HAL_TIMEOUT;
000024  2403              MOVS     r4,#3
;;;2191         break;
000026  e025              B        |L11.116|
                  |L11.40|
000028  6838              LDR      r0,[r7,#0]            ;2186
00002a  0080              LSLS     r0,r0,#2              ;2186
00002c  d4f5              BMI      |L11.26|
;;;2192       }
;;;2193     }
;;;2194   
;;;2195     if(status == HAL_OK)
00002e  bb0c              CBNZ     r4,|L11.116|
;;;2196     {
;;;2197   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2198       /* Configure the PLLSAI2 Multiplication factor N */
;;;2199       /* Configure the PLLSAI2 Division factors M, P, Q and R */
;;;2200       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2M, PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2Q, PLLSAI2Init->PLLSAI2R);
;;;2201   #elif defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;2202       /* Configure the PLLSAI2 Multiplication factor N */
;;;2203       /* Configure the PLLSAI2 Division factors M, P and R */
;;;2204       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2M, PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
;;;2205   #elif defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2206       /* Configure the PLLSAI2 Multiplication factor N */
;;;2207       /* Configure the PLLSAI2 Division factors P, Q and R */
;;;2208       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2Q, PLLSAI2Init->PLLSAI2R);
;;;2209   #else
;;;2210       /* Configure the PLLSAI2 Multiplication factor N */
;;;2211       /* Configure the PLLSAI2 Division factors P and R */
;;;2212       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
000030  68a8              LDR      r0,[r5,#8]
000032  68e9              LDR      r1,[r5,#0xc]
000034  0200              LSLS     r0,r0,#8
000036  0909              LSRS     r1,r1,#4
000038  ea404041          ORR      r0,r0,r1,LSL #17
00003c  7c29              LDRB     r1,[r5,#0x10]
00003e  f04f427e          MOV      r2,#0xfe000000
000042  0849              LSRS     r1,r1,#1
000044  eb026141          ADD      r1,r2,r1,LSL #25
000048  4308              ORRS     r0,r0,r1
00004a  6178              STR      r0,[r7,#0x14]
;;;2213   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */
;;;2214       /* Configure the PLLSAI2 Clock output(s) */
;;;2215       __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PLLSAI2Init->PLLSAI2ClockOut);
00004c  6978              LDR      r0,[r7,#0x14]
00004e  6969              LDR      r1,[r5,#0x14]
000050  4308              ORRS     r0,r0,r1
000052  6178              STR      r0,[r7,#0x14]
;;;2216   
;;;2217       /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
;;;2218       __HAL_RCC_PLLSAI2_ENABLE();
000054  6838              LDR      r0,[r7,#0]
000056  f0405080          ORR      r0,r0,#0x10000000
00005a  6038              STR      r0,[r7,#0]
;;;2219   
;;;2220       /* Get Start Tick*/
;;;2221       tickstart = HAL_GetTick();
00005c  f7fffffe          BL       HAL_GetTick
000060  4605              MOV      r5,r0
;;;2222   
;;;2223       /* Wait till PLLSAI2 is ready */
;;;2224       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
000062  e004              B        |L11.110|
                  |L11.100|
;;;2225       {
;;;2226         if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
000064  f7fffffe          BL       HAL_GetTick
000068  1b40              SUBS     r0,r0,r5
00006a  2802              CMP      r0,#2
00006c  d8da              BHI      |L11.36|
                  |L11.110|
00006e  6838              LDR      r0,[r7,#0]            ;2224
000070  0080              LSLS     r0,r0,#2              ;2224
000072  d5f7              BPL      |L11.100|
                  |L11.116|
;;;2227         {
;;;2228           status = HAL_TIMEOUT;
;;;2229           break;
;;;2230         }
;;;2231       }
;;;2232     }
;;;2233   
;;;2234     return status;
000074  4620              MOV      r0,r4
;;;2235   }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;2236   
                          ENDP

00007a  0000              DCW      0x0000
                  |L11.124|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;841      */
;;;842    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b530              PUSH     {r4,r5,lr}
;;;843    {
;;;844      /* Set all possible values for the extended clock type parameter------------*/
;;;845    
;;;846    #if defined(STM32L412xx) || defined(STM32L422xx)
;;;847    
;;;848      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 |                                               \
;;;849                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;850                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 |                                               RCC_PERIPHCLK_USB    | \
;;;851                                                                    RCC_PERIPHCLK_RNG    |                                                                      \
;;;852                                            RCC_PERIPHCLK_RTC ;
;;;853    
;;;854    #elif defined(STM32L431xx)
;;;855    
;;;856      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 |                                               \
;;;857                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;858                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                                               \
;;;859                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 |                        \
;;;860                                            RCC_PERIPHCLK_RTC ;
;;;861    
;;;862    #elif defined(STM32L432xx) || defined(STM32L442xx)
;;;863    
;;;864      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 |                                                                      \
;;;865                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   |                        RCC_PERIPHCLK_I2C3   |                        \
;;;866                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                        RCC_PERIPHCLK_USB    | \
;;;867                                                                    RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 |                        \
;;;868                                            RCC_PERIPHCLK_RTC ;
;;;869    
;;;870    #elif defined(STM32L433xx) || defined(STM32L443xx)
;;;871    
;;;872      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 |                                               \
;;;873                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;874                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                        RCC_PERIPHCLK_USB    | \
;;;875                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 |                        \
;;;876                                            RCC_PERIPHCLK_RTC ;
;;;877    
;;;878    #elif defined(STM32L451xx)
;;;879    
;;;880      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  |                        \
;;;881                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;882                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                                               \
;;;883                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    |                        RCC_PERIPHCLK_DFSDM1 | \
;;;884                                            RCC_PERIPHCLK_RTC ;
;;;885    
;;;886    #elif defined(STM32L452xx) || defined(STM32L462xx)
;;;887    
;;;888      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  |                        \
;;;889                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;890                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                        RCC_PERIPHCLK_USB    | \
;;;891                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    |                        RCC_PERIPHCLK_DFSDM1 | \
;;;892                                            RCC_PERIPHCLK_RTC ;
;;;893    
;;;894    #elif defined(STM32L471xx)
;;;895    
;;;896      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;897                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3                          | \
;;;898                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2                          | \
;;;899                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
;;;900                                            RCC_PERIPHCLK_RTC ;
;;;901    
;;;902    #elif defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
;;;903    
;;;904      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
000002  4945              LDR      r1,|L12.280|
;;;905                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;906                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;907                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
;;;908                                            RCC_PERIPHCLK_RTC ;
;;;909    
;;;910    #elif defined(STM32L496xx) || defined(STM32L4A6xx)
;;;911    
;;;912      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;913                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;914                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;915                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
;;;916                                            RCC_PERIPHCLK_RTC ;
;;;917    
;;;918    #elif defined(STM32L4R5xx) || defined(STM32L4S5xx)
;;;919    
;;;920      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;921                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;922                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;923                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC                           | RCC_PERIPHCLK_DFSDM1 | \
;;;924                                            RCC_PERIPHCLK_DFSDM1AUDIO | RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_OSPI;
;;;925    
;;;926    #elif defined(STM32L4R7xx) || defined(STM32L4S7xx)
;;;927    
;;;928      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;929                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;930                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;931                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC                           | RCC_PERIPHCLK_DFSDM1 | \
;;;932                                            RCC_PERIPHCLK_DFSDM1AUDIO | RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_OSPI  | RCC_PERIPHCLK_LTDC;
;;;933    
;;;934    #elif defined(STM32L4R9xx) || defined(STM32L4S9xx)
;;;935    
;;;936      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;937                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;938                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;939                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC                           | RCC_PERIPHCLK_DFSDM1 | \
;;;940                                            RCC_PERIPHCLK_DFSDM1AUDIO | RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_OSPI  | RCC_PERIPHCLK_LTDC   | RCC_PERIPHCLK_DSI;
;;;941    
;;;942    #endif /* STM32L431xx */
;;;943    
;;;944    #if defined(RCC_PLLSAI1_SUPPORT)
;;;945    
;;;946      /* Get the PLLSAI1 Clock configuration -----------------------------------------------*/
;;;947    
;;;948      PeriphClkInit->PLLSAI1.PLLSAI1Source = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC) >> RCC_PLLCFGR_PLLSRC_Pos;
000004  6001              STR      r1,[r0,#0]
000006  4945              LDR      r1,|L12.284|
000008  f8512f0c          LDR      r2,[r1,#0xc]!
00000c  f0020303          AND      r3,r2,#3
;;;949    #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;950      PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U;
;;;951    #else
;;;952      PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
000010  6043              STR      r3,[r0,#4]
000012  680a              LDR      r2,[r1,#0]
000014  f3c21202          UBFX     r2,r2,#4,#3
000018  1c52              ADDS     r2,r2,#1
;;;953    #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;954      PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
00001a  6082              STR      r2,[r0,#8]
00001c  684c              LDR      r4,[r1,#4]
00001e  f3c42406          UBFX     r4,r4,#8,#7
;;;955      PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
000022  60c4              STR      r4,[r0,#0xc]
000024  684c              LDR      r4,[r1,#4]
000026  2507              MOVS     r5,#7
000028  f4043400          AND      r4,r4,#0x20000
00002c  eb053454          ADD      r4,r5,r4,LSR #13
;;;956      PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
000030  6104              STR      r4,[r0,#0x10]
000032  684c              LDR      r4,[r1,#4]
000034  f3c45441          UBFX     r4,r4,#21,#2
000038  1c64              ADDS     r4,r4,#1
00003a  0064              LSLS     r4,r4,#1
;;;957      PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
00003c  6144              STR      r4,[r0,#0x14]
00003e  684c              LDR      r4,[r1,#4]
000040  f3c46441          UBFX     r4,r4,#25,#2
000044  1c64              ADDS     r4,r4,#1
000046  0064              LSLS     r4,r4,#1
000048  6184              STR      r4,[r0,#0x18]
00004a  e9c03208          STRD     r3,r2,[r0,#0x20]
;;;958    
;;;959    #endif /* RCC_PLLSAI1_SUPPORT */
;;;960    
;;;961    #if defined(RCC_PLLSAI2_SUPPORT)
;;;962    
;;;963      /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/
;;;964    
;;;965      PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
;;;966    #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;967      PeriphClkInit->PLLSAI2.PLLSAI2M = (READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U;
;;;968    #else
;;;969      PeriphClkInit->PLLSAI2.PLLSAI2M = PeriphClkInit->PLLSAI1.PLLSAI1M;
;;;970    #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;971      PeriphClkInit->PLLSAI2.PLLSAI2N = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
00004e  688a              LDR      r2,[r1,#8]
000050  f3c22206          UBFX     r2,r2,#8,#7
;;;972      PeriphClkInit->PLLSAI2.PLLSAI2P = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) >> RCC_PLLSAI2CFGR_PLLSAI2P_Pos) << 4U) + 7U;
000054  6282              STR      r2,[r0,#0x28]
000056  688a              LDR      r2,[r1,#8]
000058  f4023200          AND      r2,r2,#0x20000
00005c  eb053252          ADD      r2,r5,r2,LSR #13
;;;973    #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;974      PeriphClkInit->PLLSAI2.PLLSAI2Q = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2Q) >> RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) + 1U) * 2U;
;;;975    #endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
;;;976      PeriphClkInit->PLLSAI2.PLLSAI2R = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R)>> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) * 2U;
000060  62c2              STR      r2,[r0,#0x2c]
000062  688a              LDR      r2,[r1,#8]
000064  f3c26241          UBFX     r2,r2,#25,#2
000068  1c52              ADDS     r2,r2,#1
00006a  0052              LSLS     r2,r2,#1
;;;977    
;;;978    #endif /* RCC_PLLSAI2_SUPPORT */
;;;979    
;;;980      /* Get the USART1 clock source ---------------------------------------------*/
;;;981      PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
00006c  6302              STR      r2,[r0,#0x30]
00006e  6fca              LDR      r2,[r1,#0x7c]
000070  f0020203          AND      r2,r2,#3
;;;982      /* Get the USART2 clock source ---------------------------------------------*/
;;;983      PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
000074  6382              STR      r2,[r0,#0x38]
000076  6fca              LDR      r2,[r1,#0x7c]
000078  f002020c          AND      r2,r2,#0xc
;;;984    
;;;985    #if defined(USART3)
;;;986      /* Get the USART3 clock source ---------------------------------------------*/
;;;987      PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
00007c  63c2              STR      r2,[r0,#0x3c]
00007e  6fca              LDR      r2,[r1,#0x7c]
000080  f0020230          AND      r2,r2,#0x30
;;;988    #endif /* USART3 */
;;;989    
;;;990    #if defined(UART4)
;;;991      /* Get the UART4 clock source ----------------------------------------------*/
;;;992      PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
000084  6402              STR      r2,[r0,#0x40]
000086  6fca              LDR      r2,[r1,#0x7c]
000088  f00202c0          AND      r2,r2,#0xc0
;;;993    #endif /* UART4 */
;;;994    
;;;995    #if defined(UART5)
;;;996      /* Get the UART5 clock source ----------------------------------------------*/
;;;997      PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
00008c  6442              STR      r2,[r0,#0x44]
00008e  6fca              LDR      r2,[r1,#0x7c]
000090  f4027240          AND      r2,r2,#0x300
;;;998    #endif /* UART5 */
;;;999    
;;;1000     /* Get the LPUART1 clock source --------------------------------------------*/
;;;1001     PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
000094  6482              STR      r2,[r0,#0x48]
000096  6fca              LDR      r2,[r1,#0x7c]
000098  f4026240          AND      r2,r2,#0xc00
;;;1002   
;;;1003     /* Get the I2C1 clock source -----------------------------------------------*/
;;;1004     PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
00009c  64c2              STR      r2,[r0,#0x4c]
00009e  6fca              LDR      r2,[r1,#0x7c]
0000a0  f4025240          AND      r2,r2,#0x3000
;;;1005   
;;;1006   #if defined(I2C2)
;;;1007      /* Get the I2C2 clock source ----------------------------------------------*/
;;;1008     PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
0000a4  6502              STR      r2,[r0,#0x50]
0000a6  6fca              LDR      r2,[r1,#0x7c]
0000a8  f4024240          AND      r2,r2,#0xc000
;;;1009   #endif /* I2C2 */
;;;1010   
;;;1011     /* Get the I2C3 clock source -----------------------------------------------*/
;;;1012     PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
0000ac  6542              STR      r2,[r0,#0x54]
0000ae  6fca              LDR      r2,[r1,#0x7c]
0000b0  f4023240          AND      r2,r2,#0x30000
;;;1013   
;;;1014   #if defined(I2C4)
;;;1015     /* Get the I2C4 clock source -----------------------------------------------*/
;;;1016     PeriphClkInit->I2c4ClockSelection    = __HAL_RCC_GET_I2C4_SOURCE();
;;;1017   #endif /* I2C4 */
;;;1018   
;;;1019     /* Get the LPTIM1 clock source ---------------------------------------------*/
;;;1020     PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
0000b4  6582              STR      r2,[r0,#0x58]
0000b6  6fca              LDR      r2,[r1,#0x7c]
0000b8  f4022240          AND      r2,r2,#0xc0000
;;;1021   
;;;1022     /* Get the LPTIM2 clock source ---------------------------------------------*/
;;;1023     PeriphClkInit->Lptim2ClockSelection  = __HAL_RCC_GET_LPTIM2_SOURCE();
0000bc  65c2              STR      r2,[r0,#0x5c]
0000be  6fca              LDR      r2,[r1,#0x7c]
0000c0  f4021240          AND      r2,r2,#0x300000
;;;1024   
;;;1025   #if defined(SAI1)
;;;1026     /* Get the SAI1 clock source -----------------------------------------------*/
;;;1027     PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
0000c4  6602              STR      r2,[r0,#0x60]
0000c6  6fca              LDR      r2,[r1,#0x7c]
0000c8  f4020240          AND      r2,r2,#0xc00000
;;;1028   #endif /* SAI1 */
;;;1029   
;;;1030   #if defined(SAI2)
;;;1031     /* Get the SAI2 clock source -----------------------------------------------*/
;;;1032     PeriphClkInit->Sai2ClockSelection    = __HAL_RCC_GET_SAI2_SOURCE();
0000cc  6642              STR      r2,[r0,#0x64]
0000ce  6fca              LDR      r2,[r1,#0x7c]
0000d0  f0027240          AND      r2,r2,#0x3000000
;;;1033   #endif /* SAI2 */
;;;1034   
;;;1035     /* Get the RTC clock source ------------------------------------------------*/
;;;1036     PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
0000d4  6682              STR      r2,[r0,#0x68]
0000d6  f8d12084          LDR      r2,[r1,#0x84]
0000da  f4027240          AND      r2,r2,#0x300
;;;1037   
;;;1038   #if defined(USB_OTG_FS) || defined(USB)
;;;1039     /* Get the USB clock source ------------------------------------------------*/
;;;1040     PeriphClkInit->UsbClockSelection   = __HAL_RCC_GET_USB_SOURCE();
0000de  f8c02084          STR      r2,[r0,#0x84]
0000e2  6fca              LDR      r2,[r1,#0x7c]
0000e4  f0026240          AND      r2,r2,#0xc000000
;;;1041   #endif /* USB_OTG_FS || USB */
;;;1042   
;;;1043   #if defined(SDMMC1)
;;;1044     /* Get the SDMMC1 clock source ---------------------------------------------*/
;;;1045     PeriphClkInit->Sdmmc1ClockSelection   = __HAL_RCC_GET_SDMMC1_SOURCE();
0000e8  66c2              STR      r2,[r0,#0x6c]
0000ea  6fca              LDR      r2,[r1,#0x7c]
0000ec  f0026240          AND      r2,r2,#0xc000000
;;;1046   #endif /* SDMMC1 */
;;;1047   
;;;1048     /* Get the RNG clock source ------------------------------------------------*/
;;;1049     PeriphClkInit->RngClockSelection   = __HAL_RCC_GET_RNG_SOURCE();
0000f0  6702              STR      r2,[r0,#0x70]
0000f2  6fca              LDR      r2,[r1,#0x7c]
0000f4  f0026240          AND      r2,r2,#0xc000000
;;;1050   
;;;1051   #if !defined(STM32L412xx) && !defined(STM32L422xx)
;;;1052     /* Get the ADC clock source ------------------------------------------------*/
;;;1053     PeriphClkInit->AdcClockSelection     = __HAL_RCC_GET_ADC_SOURCE();
0000f8  6742              STR      r2,[r0,#0x74]
0000fa  6fca              LDR      r2,[r1,#0x7c]
0000fc  f0025240          AND      r2,r2,#0x30000000
;;;1054   #endif /* !STM32L412xx && !STM32L422xx */
;;;1055   
;;;1056   #if defined(SWPMI1)
;;;1057     /* Get the SWPMI1 clock source ---------------------------------------------*/
;;;1058     PeriphClkInit->Swpmi1ClockSelection  = __HAL_RCC_GET_SWPMI1_SOURCE();
000100  6782              STR      r2,[r0,#0x78]
000102  6fca              LDR      r2,[r1,#0x7c]
000104  f0024280          AND      r2,r2,#0x40000000
;;;1059   #endif /* SWPMI1 */
;;;1060   
;;;1061   #if defined(DFSDM1_Filter0)
;;;1062     /* Get the DFSDM1 clock source ---------------------------------------------*/
;;;1063     PeriphClkInit->Dfsdm1ClockSelection  = __HAL_RCC_GET_DFSDM1_SOURCE();
000108  67c2              STR      r2,[r0,#0x7c]
00010a  6fc9              LDR      r1,[r1,#0x7c]
00010c  f0014100          AND      r1,r1,#0x80000000
000110  f8c01080          STR      r1,[r0,#0x80]
;;;1064   
;;;1065   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1066     /* Get the DFSDM1 audio clock source ---------------------------------------*/
;;;1067     PeriphClkInit->Dfsdm1AudioClockSelection  = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
;;;1068   #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;1069   #endif /* DFSDM1_Filter0 */
;;;1070   
;;;1071   #if defined(LTDC)
;;;1072     /* Get the LTDC clock source -----------------------------------------------*/
;;;1073     PeriphClkInit->LtdcClockSelection = __HAL_RCC_GET_LTDC_SOURCE();
;;;1074   #endif /* LTDC */
;;;1075   
;;;1076   #if defined(DSI)
;;;1077     /* Get the DSI clock source ------------------------------------------------*/
;;;1078     PeriphClkInit->DsiClockSelection = __HAL_RCC_GET_DSI_SOURCE();
;;;1079   #endif /* DSI */
;;;1080   
;;;1081   #if defined(OCTOSPI1) || defined(OCTOSPI2)
;;;1082     /* Get the OctoSPIclock source --------------------------------------------*/
;;;1083     PeriphClkInit->OspiClockSelection = __HAL_RCC_GET_OSPI_SOURCE();
;;;1084   #endif /* OCTOSPI1 || OCTOSPI2 */
;;;1085   }
000114  bd30              POP      {r4,r5,pc}
;;;1086   
                          ENDP

000116  0000              DCW      0x0000
                  |L12.280|
                          DCD      0x000fffff
                  |L12.284|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;1167     */
;;;1168   uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1169   {
000004  4607              MOV      r7,r0
;;;1170     uint32_t frequency = 0U;
;;;1171     uint32_t srcclk, pll_oscsource, pllvco, plln;    /* no init needed */
;;;1172   #if defined(SDMMC1) && defined(RCC_CCIPR2_SDMMCSEL)
;;;1173     uint32_t pllp;  /* no init needed */
;;;1174   #endif
;;;1175   
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;1178   
;;;1179     if(PeriphClk == RCC_PERIPHCLK_RTC)
;;;1180     {
;;;1181       /* Get the current RTC source */
;;;1182       srcclk = __HAL_RCC_GET_RTC_SOURCE();
;;;1183   
;;;1184       switch(srcclk)
000006  f44f7680          MOV      r6,#0x100
00000a  2000              MOVS     r0,#0                 ;1170
;;;1185       {
;;;1186       case RCC_RTCCLKSOURCE_LSE:
;;;1187         /* Check if LSE is ready */
;;;1188         if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1189         {
;;;1190           frequency = LSE_VALUE;
00000c  01f4              LSLS     r4,r6,#7
00000e  4ae2              LDR      r2,|L13.920|
;;;1191         }
;;;1192         break;
;;;1193       case RCC_RTCCLKSOURCE_LSI:
;;;1194         /* Check if LSI is ready */
;;;1195         if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
;;;1196         {
;;;1197           frequency = LSI_VALUE;
000010  f44f45fa          MOV      r5,#0x7d00
000014  f44f7900          MOV      r9,#0x200             ;1184
000018  f5b73f00          CMP      r7,#0x20000           ;1179
00001c  d00e              BEQ      |L13.60|
;;;1198         }
;;;1199         break;
;;;1200       case RCC_RTCCLKSOURCE_HSE_DIV32:
;;;1201         /* Check if HSE is ready */
;;;1202         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
;;;1203         {
;;;1204           frequency = HSE_VALUE / 32U;
;;;1205         }
;;;1206         break;
;;;1207       default:
;;;1208         /* No clock source, frequency default init at 0 */
;;;1209         break;
;;;1210       }
;;;1211     }
;;;1212     else
;;;1213     {
;;;1214       /* Other external peripheral clock source than RTC */
;;;1215       pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
00001e  68d1              LDR      r1,[r2,#0xc]
;;;1216   
;;;1217       /* Compute PLL clock input */
;;;1218       switch(pll_oscsource)
;;;1219       {
;;;1220       case RCC_PLLSOURCE_MSI:   /* MSI ? */
;;;1221         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1222         {
;;;1223           /*MSI frequency range in HZ*/
;;;1224           pllvco = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
000020  f8df8378          LDR      r8,|L13.924|
000024  f0010103          AND      r1,r1,#3              ;1215
;;;1225         }
;;;1226         else
;;;1227         {
;;;1228           pllvco = 0U;
;;;1229         }
;;;1230         break;
;;;1231       case RCC_PLLSOURCE_HSI:   /* HSI ? */
;;;1232         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1233         {
;;;1234           pllvco = HSI_VALUE;
000028  4bdd              LDR      r3,|L13.928|
;;;1235         }
;;;1236         else
;;;1237         {
;;;1238           pllvco = 0U;
;;;1239         }
;;;1240         break;
;;;1241       case RCC_PLLSOURCE_HSE:   /* HSE ? */
;;;1242         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
;;;1243         {
;;;1244           pllvco = HSE_VALUE;
;;;1245         }
;;;1246         else
;;;1247         {
;;;1248           pllvco = 0U;
;;;1249         }
;;;1250         break;
;;;1251       default:
;;;1252         /* No source */
;;;1253         pllvco = 0U;
;;;1254         break;
;;;1255       }
;;;1256   
;;;1257       switch(PeriphClk)
;;;1258       {
;;;1259   #if defined(SAI1)
;;;1260   
;;;1261       case RCC_PERIPHCLK_SAI1:
;;;1262         frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI1, pllvco);
;;;1263         break;
;;;1264   
;;;1265   #endif
;;;1266   
;;;1267   #if defined(SAI2)
;;;1268   
;;;1269       case RCC_PERIPHCLK_SAI2:
;;;1270         frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI2, pllvco);
;;;1271         break;
;;;1272   
;;;1273   #endif
;;;1274   
;;;1275   #if defined(USB_OTG_FS) || defined(USB)
;;;1276   
;;;1277       case RCC_PERIPHCLK_USB:
;;;1278   
;;;1279   #endif /* USB_OTG_FS || USB */
;;;1280   
;;;1281       case RCC_PERIPHCLK_RNG:
;;;1282   
;;;1283   #if defined(SDMMC1) && !defined(RCC_CCIPR2_SDMMCSEL)
;;;1284   
;;;1285       case RCC_PERIPHCLK_SDMMC1:
;;;1286   
;;;1287   #endif /* SDMMC1 && !RCC_CCIPR2_SDMMCSEL */
;;;1288         {
;;;1289           srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
;;;1290   
;;;1291           switch(srcclk)
;;;1292           {
;;;1293           case RCC_CCIPR_CLK48SEL:   /* MSI ? */
;;;1294             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1295             {
;;;1296               /*MSI frequency range in HZ*/
;;;1297               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1298             }
;;;1299             break;
;;;1300           case RCC_CCIPR_CLK48SEL_1:  /* PLL ? */
;;;1301             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1302             {
;;;1303               if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
;;;1304               {
;;;1305                 /* f(PLL Source) / PLLM */
;;;1306                 pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1307                 /* f(PLL48M1CLK) = f(VCO input) * PLLN / PLLQ */
;;;1308                 plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1309                 frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
;;;1310               }
;;;1311             }
;;;1312             break;
;;;1313   #if defined(RCC_PLLSAI1_SUPPORT)
;;;1314           case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
;;;1315             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
;;;1316             {
;;;1317               if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
;;;1318               {
;;;1319   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;1320                 /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;1321                 /* f(PLLSAI1 Source) / PLLSAI1M */
;;;1322                 pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;1323   #else
;;;1324                 /* f(PLL Source) / PLLM */
;;;1325                 pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1326   #endif
;;;1327                 /* f(PLL48M2CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1Q */
;;;1328                 plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;1329                 frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U);
;;;1330               }
;;;1331             }
;;;1332             break;
;;;1333   #endif /* RCC_PLLSAI1_SUPPORT */
;;;1334   #if defined(RCC_HSI48_SUPPORT)
;;;1335           case 0U:
;;;1336             if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
;;;1337             {
;;;1338               frequency = HSI48_VALUE;
;;;1339             }
;;;1340             break;
;;;1341   #endif /* RCC_HSI48_SUPPORT */
;;;1342           default:
;;;1343             /* No clock source, frequency default init at 0 */
;;;1344             break;
;;;1345           } /* switch(srcclk) */
;;;1346           break;
;;;1347         }
;;;1348   
;;;1349   #if defined(SDMMC1) && defined(RCC_CCIPR2_SDMMCSEL)
;;;1350   
;;;1351       case RCC_PERIPHCLK_SDMMC1:
;;;1352   
;;;1353         if(HAL_IS_BIT_SET(RCC->CCIPR2, RCC_CCIPR2_SDMMCSEL))  /* PLL "P" ? */
;;;1354         {
;;;1355           if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1356           {
;;;1357             if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLPEN))
;;;1358             {
;;;1359               /* f(PLL Source) / PLLM */
;;;1360               pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1361               /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
;;;1362               plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1363               pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;1364               if(pllp == 0U)
;;;1365               {
;;;1366                 if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;1367                 {
;;;1368                   pllp = 17U;
;;;1369                 }
;;;1370                 else
;;;1371                 {
;;;1372                   pllp = 7U;
;;;1373                 }
;;;1374               }
;;;1375               frequency = (pllvco * plln) / pllp;
;;;1376             }
;;;1377           }
;;;1378         }
;;;1379         else  /* 48MHz from PLL "Q" or MSI or PLLSAI1Q or HSI48 */
;;;1380         {
;;;1381           srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
;;;1382   
;;;1383           switch(srcclk)
;;;1384           {
;;;1385           case RCC_CCIPR_CLK48SEL:   /* MSI ? */
;;;1386             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1387             {
;;;1388               /*MSI frequency range in HZ*/
;;;1389               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1390             }
;;;1391             break;
;;;1392           case RCC_CCIPR_CLK48SEL_1:  /* PLL "Q" ? */
;;;1393             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1394             {
;;;1395               if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
;;;1396               {
;;;1397                 /* f(PLL Source) / PLLM */
;;;1398                 pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1399                 /* f(PLL48M1CLK) = f(VCO input) * PLLN / PLLQ */
;;;1400                 plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1401                 frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
;;;1402               }
;;;1403             }
;;;1404             break;
;;;1405           case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
;;;1406             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
;;;1407             {
;;;1408               if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
;;;1409               {
;;;1410                 /* f(PLLSAI1 Source) / PLLSAI1M */
;;;1411                 pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;1412                 /* f(PLL48M2CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1Q */
;;;1413                 plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;1414                 frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U);
;;;1415               }
;;;1416             }
;;;1417             break;
;;;1418           case 0U:
;;;1419             if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
;;;1420             {
;;;1421               frequency = HSI48_VALUE;
;;;1422             }
;;;1423             break;
;;;1424           default:
;;;1425             /* No clock source, frequency default init at 0 */
;;;1426             break;
;;;1427           } /* switch(srcclk) */
;;;1428         }
;;;1429         break;
;;;1430   
;;;1431   #endif /* SDMMC1 && RCC_CCIPR2_SDMMCSEL */
;;;1432   
;;;1433       case RCC_PERIPHCLK_USART1:
;;;1434         {
;;;1435           /* Get the current USART1 source */
;;;1436           srcclk = __HAL_RCC_GET_USART1_SOURCE();
;;;1437   
;;;1438           switch(srcclk)
;;;1439           {
;;;1440           case RCC_USART1CLKSOURCE_PCLK2:
;;;1441             frequency = HAL_RCC_GetPCLK2Freq();
;;;1442             break;
;;;1443           case RCC_USART1CLKSOURCE_SYSCLK:
;;;1444             frequency = HAL_RCC_GetSysClockFreq();
;;;1445             break;
;;;1446           case RCC_USART1CLKSOURCE_HSI:
;;;1447             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1448             {
;;;1449               frequency = HSI_VALUE;
;;;1450             }
;;;1451             break;
;;;1452           case RCC_USART1CLKSOURCE_LSE:
;;;1453             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1454             {
;;;1455               frequency = LSE_VALUE;
;;;1456             }
;;;1457             break;
;;;1458           default:
;;;1459             /* No clock source, frequency default init at 0 */
;;;1460             break;
;;;1461           }
;;;1462   
;;;1463           break;
;;;1464         }
;;;1465   
;;;1466       case RCC_PERIPHCLK_USART2:
;;;1467         {
;;;1468           /* Get the current USART2 source */
;;;1469           srcclk = __HAL_RCC_GET_USART2_SOURCE();
;;;1470   
;;;1471           switch(srcclk)
;;;1472           {
;;;1473           case RCC_USART2CLKSOURCE_PCLK1:
;;;1474             frequency = HAL_RCC_GetPCLK1Freq();
;;;1475             break;
;;;1476           case RCC_USART2CLKSOURCE_SYSCLK:
;;;1477             frequency = HAL_RCC_GetSysClockFreq();
;;;1478             break;
;;;1479           case RCC_USART2CLKSOURCE_HSI:
;;;1480             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1481             {
;;;1482               frequency = HSI_VALUE;
;;;1483             }
;;;1484             break;
;;;1485           case RCC_USART2CLKSOURCE_LSE:
;;;1486             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1487             {
;;;1488               frequency = LSE_VALUE;
;;;1489             }
;;;1490             break;
;;;1491           default:
;;;1492             /* No clock source, frequency default init at 0 */
;;;1493             break;
;;;1494           }
;;;1495   
;;;1496           break;
;;;1497         }
;;;1498   
;;;1499   #if defined(USART3)
;;;1500   
;;;1501       case RCC_PERIPHCLK_USART3:
;;;1502         {
;;;1503           /* Get the current USART3 source */
;;;1504           srcclk = __HAL_RCC_GET_USART3_SOURCE();
;;;1505   
;;;1506           switch(srcclk)
;;;1507           {
;;;1508           case RCC_USART3CLKSOURCE_PCLK1:
;;;1509             frequency = HAL_RCC_GetPCLK1Freq();
;;;1510             break;
;;;1511           case RCC_USART3CLKSOURCE_SYSCLK:
;;;1512             frequency = HAL_RCC_GetSysClockFreq();
;;;1513             break;
;;;1514           case RCC_USART3CLKSOURCE_HSI:
;;;1515             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1516             {
;;;1517               frequency = HSI_VALUE;
;;;1518             }
;;;1519             break;
;;;1520           case RCC_USART3CLKSOURCE_LSE:
;;;1521             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1522             {
;;;1523               frequency = LSE_VALUE;
;;;1524             }
;;;1525             break;
;;;1526           default:
;;;1527             /* No clock source, frequency default init at 0 */
;;;1528             break;
;;;1529           }
;;;1530   
;;;1531           break;
;;;1532         }
;;;1533   
;;;1534   #endif /* USART3 */
;;;1535   
;;;1536   #if defined(UART4)
;;;1537   
;;;1538       case RCC_PERIPHCLK_UART4:
;;;1539         {
;;;1540           /* Get the current UART4 source */
;;;1541           srcclk = __HAL_RCC_GET_UART4_SOURCE();
;;;1542   
;;;1543           switch(srcclk)
;;;1544           {
;;;1545           case RCC_UART4CLKSOURCE_PCLK1:
;;;1546             frequency = HAL_RCC_GetPCLK1Freq();
;;;1547             break;
;;;1548           case RCC_UART4CLKSOURCE_SYSCLK:
;;;1549             frequency = HAL_RCC_GetSysClockFreq();
;;;1550             break;
;;;1551           case RCC_UART4CLKSOURCE_HSI:
;;;1552             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1553             {
;;;1554               frequency = HSI_VALUE;
;;;1555             }
;;;1556             break;
;;;1557           case RCC_UART4CLKSOURCE_LSE:
;;;1558             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1559             {
;;;1560               frequency = LSE_VALUE;
;;;1561             }
;;;1562             break;
;;;1563           default:
;;;1564             /* No clock source, frequency default init at 0 */
;;;1565             break;
;;;1566           }
;;;1567   
;;;1568           break;
;;;1569         }
;;;1570   
;;;1571   #endif /* UART4 */
;;;1572   
;;;1573   #if defined(UART5)
;;;1574   
;;;1575       case RCC_PERIPHCLK_UART5:
;;;1576         {
;;;1577           /* Get the current UART5 source */
;;;1578           srcclk = __HAL_RCC_GET_UART5_SOURCE();
;;;1579   
;;;1580           switch(srcclk)
;;;1581           {
;;;1582           case RCC_UART5CLKSOURCE_PCLK1:
;;;1583             frequency = HAL_RCC_GetPCLK1Freq();
;;;1584             break;
;;;1585           case RCC_UART5CLKSOURCE_SYSCLK:
;;;1586             frequency = HAL_RCC_GetSysClockFreq();
;;;1587             break;
;;;1588           case RCC_UART5CLKSOURCE_HSI:
;;;1589             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1590             {
;;;1591               frequency = HSI_VALUE;
;;;1592             }
;;;1593             break;
;;;1594           case RCC_UART5CLKSOURCE_LSE:
;;;1595             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1596             {
;;;1597               frequency = LSE_VALUE;
;;;1598             }
;;;1599             break;
;;;1600           default:
;;;1601             /* No clock source, frequency default init at 0 */
;;;1602             break;
;;;1603           }
;;;1604   
;;;1605           break;
;;;1606         }
;;;1607   
;;;1608   #endif /* UART5 */
;;;1609   
;;;1610       case RCC_PERIPHCLK_LPUART1:
;;;1611         {
;;;1612           /* Get the current LPUART1 source */
;;;1613           srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
;;;1614   
;;;1615           switch(srcclk)
;;;1616           {
;;;1617           case RCC_LPUART1CLKSOURCE_PCLK1:
;;;1618             frequency = HAL_RCC_GetPCLK1Freq();
;;;1619             break;
;;;1620           case RCC_LPUART1CLKSOURCE_SYSCLK:
;;;1621             frequency = HAL_RCC_GetSysClockFreq();
;;;1622             break;
;;;1623           case RCC_LPUART1CLKSOURCE_HSI:
;;;1624             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1625             {
;;;1626               frequency = HSI_VALUE;
;;;1627             }
;;;1628             break;
;;;1629           case RCC_LPUART1CLKSOURCE_LSE:
;;;1630             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1631             {
;;;1632               frequency = LSE_VALUE;
;;;1633             }
;;;1634             break;
;;;1635           default:
;;;1636             /* No clock source, frequency default init at 0 */
;;;1637             break;
;;;1638           }
;;;1639   
;;;1640           break;
;;;1641         }
;;;1642   
;;;1643       case RCC_PERIPHCLK_ADC:
;;;1644         {
;;;1645           srcclk = __HAL_RCC_GET_ADC_SOURCE();
;;;1646   
;;;1647           switch(srcclk)
;;;1648           {
;;;1649           case RCC_ADCCLKSOURCE_SYSCLK:
;;;1650             frequency = HAL_RCC_GetSysClockFreq();
;;;1651             break;
;;;1652   #if defined(RCC_PLLSAI1_SUPPORT)
;;;1653           case RCC_ADCCLKSOURCE_PLLSAI1:
;;;1654             if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_ADC1CLK) != 0U)
;;;1655             {
;;;1656   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;1657               /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;1658               /* f(PLLSAI1 Source) / PLLSAI1M */
;;;1659               pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;1660   #else
;;;1661               /* f(PLL Source) / PLLM */
;;;1662               pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1663   #endif
;;;1664               /* f(PLLADC1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1R */
;;;1665               plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;1666               frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U);
;;;1667             }
;;;1668             break;
;;;1669   #endif /* RCC_PLLSAI1_SUPPORT */
;;;1670   #if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) || defined(STM32L496xx) || defined(STM32L4A6xx)
;;;1671           case RCC_ADCCLKSOURCE_PLLSAI2:
;;;1672             if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_ADC2CLK) != 0U)
;;;1673             {
;;;1674   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;1675               /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
;;;1676               /* f(PLLSAI2 Source) / PLLSAI2M */
;;;1677               pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
;;;1678   #else
;;;1679               /* f(PLL Source) / PLLM */
;;;1680               pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1681   #endif
;;;1682               /* f(PLLADC2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2R */
;;;1683               plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
;;;1684               frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U);
;;;1685             }
;;;1686             break;
;;;1687   #endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx || STM32L496xx || STM32L4A6xx */
;;;1688           default:
;;;1689             /* No clock source, frequency default init at 0 */
;;;1690             break;
;;;1691           }
;;;1692   
;;;1693           break;
;;;1694         }
;;;1695   
;;;1696   #if defined(DFSDM1_Filter0)
;;;1697   
;;;1698       case RCC_PERIPHCLK_DFSDM1:
;;;1699         {
;;;1700           /* Get the current DFSDM1 source */
;;;1701           srcclk = __HAL_RCC_GET_DFSDM1_SOURCE();
;;;1702   
;;;1703           if(srcclk == RCC_DFSDM1CLKSOURCE_PCLK2)
;;;1704           {
;;;1705             frequency = HAL_RCC_GetPCLK2Freq();
;;;1706           }
;;;1707           else
;;;1708           {
;;;1709             frequency = HAL_RCC_GetSysClockFreq();
;;;1710           }
;;;1711   
;;;1712           break;
;;;1713         }
;;;1714   
;;;1715   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1716   
;;;1717       case RCC_PERIPHCLK_DFSDM1AUDIO:
;;;1718         {
;;;1719           /* Get the current DFSDM1 audio source */
;;;1720           srcclk = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
;;;1721   
;;;1722           switch(srcclk)
;;;1723           {
;;;1724           case RCC_DFSDM1AUDIOCLKSOURCE_SAI1:
;;;1725             frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI1, pllvco);
;;;1726             break;
;;;1727           case RCC_DFSDM1AUDIOCLKSOURCE_MSI:
;;;1728             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1729             {
;;;1730               /*MSI frequency range in HZ*/
;;;1731               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1732             }
;;;1733             break;
;;;1734           case RCC_DFSDM1AUDIOCLKSOURCE_HSI:
;;;1735             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1736             {
;;;1737               frequency = HSI_VALUE;
;;;1738             }
;;;1739             break;
;;;1740           default:
;;;1741             /* No clock source, frequency default init at 0 */
;;;1742             break;
;;;1743           }
;;;1744   
;;;1745           break;
;;;1746         }
;;;1747   
;;;1748   #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;1749   
;;;1750   #endif /* DFSDM1_Filter0 */
;;;1751   
;;;1752       case RCC_PERIPHCLK_I2C1:
;;;1753         {
;;;1754           /* Get the current I2C1 source */
;;;1755           srcclk = __HAL_RCC_GET_I2C1_SOURCE();
;;;1756   
;;;1757           switch(srcclk)
;;;1758           {
;;;1759           case RCC_I2C1CLKSOURCE_PCLK1:
;;;1760             frequency = HAL_RCC_GetPCLK1Freq();
;;;1761             break;
;;;1762           case RCC_I2C1CLKSOURCE_SYSCLK:
;;;1763             frequency = HAL_RCC_GetSysClockFreq();
;;;1764             break;
;;;1765           case RCC_I2C1CLKSOURCE_HSI:
;;;1766             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1767             {
;;;1768               frequency = HSI_VALUE;
;;;1769             }
;;;1770             break;
;;;1771           default:
;;;1772             /* No clock source, frequency default init at 0 */
;;;1773             break;
;;;1774           }
;;;1775   
;;;1776           break;
;;;1777         }
;;;1778   
;;;1779   #if defined(I2C2)
;;;1780   
;;;1781       case RCC_PERIPHCLK_I2C2:
;;;1782         {
;;;1783           /* Get the current I2C2 source */
;;;1784           srcclk = __HAL_RCC_GET_I2C2_SOURCE();
;;;1785   
;;;1786           switch(srcclk)
;;;1787           {
;;;1788           case RCC_I2C2CLKSOURCE_PCLK1:
;;;1789             frequency = HAL_RCC_GetPCLK1Freq();
;;;1790             break;
;;;1791           case RCC_I2C2CLKSOURCE_SYSCLK:
;;;1792             frequency = HAL_RCC_GetSysClockFreq();
;;;1793             break;
;;;1794           case RCC_I2C2CLKSOURCE_HSI:
;;;1795             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1796             {
;;;1797               frequency = HSI_VALUE;
;;;1798             }
;;;1799             break;
;;;1800           default:
;;;1801             /* No clock source, frequency default init at 0 */
;;;1802             break;
;;;1803           }
;;;1804   
;;;1805           break;
;;;1806         }
;;;1807   
;;;1808   #endif /* I2C2 */
;;;1809   
;;;1810       case RCC_PERIPHCLK_I2C3:
;;;1811         {
;;;1812           /* Get the current I2C3 source */
;;;1813           srcclk = __HAL_RCC_GET_I2C3_SOURCE();
;;;1814   
;;;1815           switch(srcclk)
;;;1816           {
;;;1817           case RCC_I2C3CLKSOURCE_PCLK1:
;;;1818             frequency = HAL_RCC_GetPCLK1Freq();
;;;1819             break;
;;;1820           case RCC_I2C3CLKSOURCE_SYSCLK:
;;;1821             frequency = HAL_RCC_GetSysClockFreq();
;;;1822             break;
;;;1823           case RCC_I2C3CLKSOURCE_HSI:
;;;1824             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1825             {
;;;1826               frequency = HSI_VALUE;
;;;1827             }
;;;1828             break;
;;;1829           default:
;;;1830             /* No clock source, frequency default init at 0 */
;;;1831             break;
;;;1832           }
;;;1833   
;;;1834           break;
;;;1835         }
;;;1836   
;;;1837   #if defined(I2C4)
;;;1838   
;;;1839       case RCC_PERIPHCLK_I2C4:
;;;1840         {
;;;1841           /* Get the current I2C4 source */
;;;1842           srcclk = __HAL_RCC_GET_I2C4_SOURCE();
;;;1843   
;;;1844           switch(srcclk)
;;;1845           {
;;;1846           case RCC_I2C4CLKSOURCE_PCLK1:
;;;1847             frequency = HAL_RCC_GetPCLK1Freq();
;;;1848             break;
;;;1849           case RCC_I2C4CLKSOURCE_SYSCLK:
;;;1850             frequency = HAL_RCC_GetSysClockFreq();
;;;1851             break;
;;;1852           case RCC_I2C4CLKSOURCE_HSI:
;;;1853             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1854             {
;;;1855               frequency = HSI_VALUE;
;;;1856             }
;;;1857             break;
;;;1858           default:
;;;1859             /* No clock source, frequency default init at 0 */
;;;1860             break;
;;;1861           }
;;;1862   
;;;1863           break;
;;;1864         }
;;;1865   
;;;1866   #endif /* I2C4 */
;;;1867   
;;;1868       case RCC_PERIPHCLK_LPTIM1:
;;;1869         {
;;;1870           /* Get the current LPTIM1 source */
;;;1871           srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
;;;1872   
;;;1873           switch(srcclk)
;;;1874           {
;;;1875           case RCC_LPTIM1CLKSOURCE_PCLK1:
;;;1876             frequency = HAL_RCC_GetPCLK1Freq();
;;;1877             break;
;;;1878           case RCC_LPTIM1CLKSOURCE_LSI:
;;;1879             if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
;;;1880             {
;;;1881               frequency = LSI_VALUE;
;;;1882             }
;;;1883             break;
;;;1884           case RCC_LPTIM1CLKSOURCE_HSI:
;;;1885             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1886             {
;;;1887               frequency = HSI_VALUE;
;;;1888             }
;;;1889             break;
;;;1890           case RCC_LPTIM1CLKSOURCE_LSE:
;;;1891             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1892             {
;;;1893               frequency = LSE_VALUE;
;;;1894             }
;;;1895             break;
;;;1896           default:
;;;1897             /* No clock source, frequency default init at 0 */
;;;1898             break;
;;;1899           }
;;;1900   
;;;1901           break;
;;;1902         }
;;;1903   
;;;1904       case RCC_PERIPHCLK_LPTIM2:
;;;1905         {
;;;1906           /* Get the current LPTIM2 source */
;;;1907          srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
;;;1908   
;;;1909           switch(srcclk)
;;;1910           {
;;;1911           case RCC_LPTIM2CLKSOURCE_PCLK1:
;;;1912             frequency = HAL_RCC_GetPCLK1Freq();
;;;1913             break;
;;;1914           case RCC_LPTIM2CLKSOURCE_LSI:
;;;1915             if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
;;;1916             {
;;;1917               frequency = LSI_VALUE;
;;;1918             }
;;;1919             break;
;;;1920           case RCC_LPTIM2CLKSOURCE_HSI:
;;;1921             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1922             {
;;;1923               frequency = HSI_VALUE;
;;;1924             }
;;;1925             break;
;;;1926           case RCC_LPTIM2CLKSOURCE_LSE:
;;;1927             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1928             {
;;;1929               frequency = LSE_VALUE;
;;;1930             }
;;;1931             break;
;;;1932           default:
;;;1933             /* No clock source, frequency default init at 0 */
;;;1934             break;
;;;1935           }
;;;1936   
;;;1937           break;
;;;1938         }
;;;1939   
;;;1940   #if defined(SWPMI1)
;;;1941   
;;;1942       case RCC_PERIPHCLK_SWPMI1:
;;;1943         {
;;;1944           /* Get the current SWPMI1 source */
;;;1945           srcclk = __HAL_RCC_GET_SWPMI1_SOURCE();
;;;1946   
;;;1947           switch(srcclk)
;;;1948           {
;;;1949           case RCC_SWPMI1CLKSOURCE_PCLK1:
;;;1950             frequency = HAL_RCC_GetPCLK1Freq();
;;;1951             break;
;;;1952           case RCC_SWPMI1CLKSOURCE_HSI:
;;;1953             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1954             {
;;;1955               frequency = HSI_VALUE;
;;;1956             }
;;;1957             break;
;;;1958           default:
;;;1959             /* No clock source, frequency default init at 0 */
;;;1960             break;
;;;1961           }
;;;1962   
;;;1963           break;
;;;1964         }
;;;1965   
;;;1966   #endif /* SWPMI1 */
;;;1967   
;;;1968   #if defined(OCTOSPI1) || defined(OCTOSPI2)
;;;1969   
;;;1970       case RCC_PERIPHCLK_OSPI:
;;;1971         {
;;;1972           /* Get the current OctoSPI clock source */
;;;1973           srcclk = __HAL_RCC_GET_OSPI_SOURCE();
;;;1974   
;;;1975           switch(srcclk)
;;;1976           {
;;;1977           case RCC_OSPICLKSOURCE_SYSCLK:
;;;1978             frequency = HAL_RCC_GetSysClockFreq();
;;;1979             break;
;;;1980           case RCC_OSPICLKSOURCE_MSI:
;;;1981             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1982             {
;;;1983               /*MSI frequency range in HZ*/
;;;1984               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1985             }
;;;1986             break;
;;;1987           case RCC_OSPICLKSOURCE_PLL:
;;;1988             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1989             {
;;;1990               if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
;;;1991               {
;;;1992                 /* f(PLL Source) / PLLM */
;;;1993                 pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1994                 /* f(PLL48M1CLK) = f(VCO input) * PLLN / PLLQ */
;;;1995                 plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1996                 frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
;;;1997               }
;;;1998             }
;;;1999             break;
;;;2000           default:
;;;2001             /* No clock source, frequency default init at 0 */
;;;2002             break;
;;;2003           }
;;;2004   
;;;2005           break;
;;;2006         }
;;;2007   
;;;2008   #endif /* OCTOSPI1 || OCTOSPI2 */
;;;2009   
;;;2010       default:
;;;2011         break;
;;;2012       }
;;;2013     }
;;;2014   
;;;2015     return(frequency);
;;;2016   }
00002a  f04f0cf0          MOV      r12,#0xf0
00002e  2901              CMP      r1,#1                 ;1218
000030  d021              BEQ      |L13.118|
000032  2902              CMP      r1,#2                 ;1218
000034  d031              BEQ      |L13.154|
000036  2903              CMP      r1,#3                 ;1218
000038  d139              BNE      |L13.174|
00003a  e033              B        |L13.164|
                  |L13.60|
00003c  f8d21090          LDR      r1,[r2,#0x90]         ;1182
000040  f4017140          AND      r1,r1,#0x300          ;1182
000044  42b1              CMP      r1,r6                 ;1184
000046  d00a              BEQ      |L13.94|
000048  4549              CMP      r1,r9                 ;1184
00004a  d00e              BEQ      |L13.106|
00004c  f5b17f40          CMP      r1,#0x300             ;1184
000050  d103              BNE      |L13.90|
000052  6811              LDR      r1,[r2,#0]            ;1202
000054  0389              LSLS     r1,r1,#14             ;1202
000056  d500              BPL      |L13.90|
000058  48d2              LDR      r0,|L13.932|
                  |L13.90|
00005a  e8bd9ff0          POP      {r4-r12,pc}
                  |L13.94|
00005e  f8d21090          LDR      r1,[r2,#0x90]         ;1188
000062  0789              LSLS     r1,r1,#30             ;1188
000064  d5f9              BPL      |L13.90|
000066  4620              MOV      r0,r4                 ;1190
                  |L13.104|
000068  e7f7              B        |L13.90|
                  |L13.106|
00006a  f8d21094          LDR      r1,[r2,#0x94]         ;1195
00006e  0789              LSLS     r1,r1,#30             ;1195
000070  d5f3              BPL      |L13.90|
000072  4628              MOV      r0,r5                 ;1197
                  |L13.116|
000074  e7f1              B        |L13.90|
                  |L13.118|
000076  6811              LDR      r1,[r2,#0]            ;1221
000078  0789              LSLS     r1,r1,#30             ;1221
00007a  d518              BPL      |L13.174|
00007c  6811              LDR      r1,[r2,#0]            ;1224
00007e  0709              LSLS     r1,r1,#28             ;1224
000080  d503              BPL      |L13.138|
000082  6811              LDR      r1,[r2,#0]            ;1224
000084  f00101f0          AND      r1,r1,#0xf0           ;1224
000088  e003              B        |L13.146|
                  |L13.138|
00008a  f8d21094          LDR      r1,[r2,#0x94]         ;1224
00008e  ea0c1111          AND      r1,r12,r1,LSR #4
                  |L13.146|
000092  0909              LSRS     r1,r1,#4              ;1224
000094  f8581021          LDR      r1,[r8,r1,LSL #2]     ;1224
000098  e00a              B        |L13.176|
                  |L13.154|
00009a  6811              LDR      r1,[r2,#0]            ;1232
00009c  0549              LSLS     r1,r1,#21             ;1232
00009e  d506              BPL      |L13.174|
0000a0  4619              MOV      r1,r3                 ;1234
0000a2  e005              B        |L13.176|
                  |L13.164|
0000a4  6811              LDR      r1,[r2,#0]            ;1242
0000a6  0389              LSLS     r1,r1,#14             ;1242
0000a8  d501              BPL      |L13.174|
0000aa  49bf              LDR      r1,|L13.936|
0000ac  e000              B        |L13.176|
                  |L13.174|
0000ae  2100              MOVS     r1,#0                 ;1248
                  |L13.176|
0000b0  46cb              MOV      r11,r9                ;1257
0000b2  f44f4e80          MOV      lr,#0x4000            ;1257
0000b6  f44f6900          MOV      r9,#0x800             ;1257
0000ba  f44f5a80          MOV      r10,#0x1000           ;1257
0000be  455f              CMP      r7,r11                ;1257
0000c0  d07d              BEQ      |L13.446|
0000c2  dc2a              BGT      |L13.282|
0000c4  2f10              CMP      r7,#0x10              ;1257
0000c6  d07b              BEQ      |L13.448|
0000c8  dc13              BGT      |L13.242|
0000ca  2f01              CMP      r7,#1                 ;1257
0000cc  d079              BEQ      |L13.450|
0000ce  2f02              CMP      r7,#2                 ;1257
0000d0  d078              BEQ      |L13.452|
0000d2  2f04              CMP      r7,#4                 ;1257
0000d4  d077              BEQ      |L13.454|
0000d6  2f08              CMP      r7,#8                 ;1257
0000d8  d1bf              BNE      |L13.90|
0000da  f8d21088          LDR      r1,[r2,#0x88]         ;1541
0000de  f01101c0          ANDS     r1,r1,#0xc0           ;1541
0000e2  d071              BEQ      |L13.456|
0000e4  2940              CMP      r1,#0x40              ;1543
0000e6  d070              BEQ      |L13.458|
0000e8  2980              CMP      r1,#0x80              ;1543
0000ea  d015              BEQ      |L13.280|
0000ec  29c0              CMP      r1,#0xc0              ;1543
0000ee  d1b4              BNE      |L13.90|
0000f0  e7b5              B        |L13.94|
                  |L13.242|
0000f2  2f20              CMP      r7,#0x20              ;1257
0000f4  d06a              BEQ      |L13.460|
0000f6  2f40              CMP      r7,#0x40              ;1257
0000f8  d069              BEQ      |L13.462|
0000fa  2f80              CMP      r7,#0x80              ;1257
0000fc  d068              BEQ      |L13.464|
0000fe  42b7              CMP      r7,r6                 ;1257
000100  d1ab              BNE      |L13.90|
000102  f8d21088          LDR      r1,[r2,#0x88]         ;1813
000106  f4113140          ANDS     r1,r1,#0x30000        ;1813
00010a  d05d              BEQ      |L13.456|
00010c  f5b13f80          CMP      r1,#0x10000           ;1815
000110  d05b              BEQ      |L13.458|
000112  f5b13f00          CMP      r1,#0x20000           ;1815
000116  d1a0              BNE      |L13.90|
                  |L13.280|
000118  e135              B        |L13.902|
                  |L13.282|
00011a  4577              CMP      r7,lr                 ;1257
00011c  d074              BEQ      |L13.520|
00011e  dc0a              BGT      |L13.310|
000120  f5b76f80          CMP      r7,#0x400             ;1257
000124  d071              BEQ      |L13.522|
000126  454f              CMP      r7,r9                 ;1257
000128  d028              BEQ      |L13.380|
00012a  4557              CMP      r7,r10                ;1257
00012c  d028              BEQ      |L13.384|
00012e  f5b75f00          CMP      r7,#0x2000            ;1257
000132  d192              BNE      |L13.90|
000134  e00a              B        |L13.332|
                  |L13.310|
000136  42a7              CMP      r7,r4                 ;1257
000138  d068              BEQ      |L13.524|
00013a  f5b73f80          CMP      r7,#0x10000           ;1257
00013e  d072              BEQ      |L13.550|
000140  f5b72f80          CMP      r7,#0x40000           ;1257
000144  d002              BEQ      |L13.332|
000146  f5b72f00          CMP      r7,#0x80000           ;1257
00014a  d186              BNE      |L13.90|
                  |L13.332|
00014c  f8d23088          LDR      r3,[r2,#0x88]         ;1289
000150  f0036340          AND      r3,r3,#0xc000000      ;1289
000154  f1b36f80          CMP      r3,#0x4000000         ;1291
000158  d03e              BEQ      |L13.472|
00015a  f1b36f00          CMP      r3,#0x8000000         ;1291
00015e  d01c              BEQ      |L13.410|
000160  f1b36f40          CMP      r3,#0xc000000         ;1291
000164  d186              BNE      |L13.116|
000166  6811              LDR      r1,[r2,#0]            ;1294
000168  0789              LSLS     r1,r1,#30             ;1294
00016a  f57faf7d          BPL      |L13.104|
00016e  6810              LDR      r0,[r2,#0]            ;1297
000170  0700              LSLS     r0,r0,#28             ;1297
000172  d50a              BPL      |L13.394|
000174  6810              LDR      r0,[r2,#0]            ;1297
000176  f00000f0          AND      r0,r0,#0xf0           ;1297
00017a  e00a              B        |L13.402|
                  |L13.380|
00017c  4648              MOV      r0,r9                 ;1262
00017e  e000              B        |L13.386|
                  |L13.384|
000180  4650              MOV      r0,r10                ;1270
                  |L13.386|
000182  e8bd5ff0          POP      {r4-r12,lr}           ;1270
000186  f7ffbffe          B.W      RCCEx_GetSAIxPeriphCLKFreq
                  |L13.394|
00018a  f8d20094          LDR      r0,[r2,#0x94]         ;1297
00018e  ea0c1010          AND      r0,r12,r0,LSR #4
                  |L13.402|
000192  0900              LSRS     r0,r0,#4              ;1297
000194  f8580020          LDR      r0,[r8,r0,LSL #2]     ;1297
                  |L13.408|
000198  e75f              B        |L13.90|
                  |L13.410|
00019a  6813              LDR      r3,[r2,#0]            ;1301
00019c  019b              LSLS     r3,r3,#6              ;1301
00019e  d5fb              BPL      |L13.408|
0001a0  68d3              LDR      r3,[r2,#0xc]          ;1303
0001a2  02db              LSLS     r3,r3,#11             ;1303
0001a4  d5f8              BPL      |L13.408|
0001a6  68d0              LDR      r0,[r2,#0xc]          ;1306
0001a8  f3c01002          UBFX     r0,r0,#4,#3           ;1306
0001ac  1c40              ADDS     r0,r0,#1              ;1306
0001ae  fbb1f0f0          UDIV     r0,r1,r0              ;1306
0001b2  68d1              LDR      r1,[r2,#0xc]          ;1308
0001b4  f3c12106          UBFX     r1,r1,#8,#7           ;1308
0001b8  4348              MULS     r0,r1,r0              ;1309
0001ba  68d1              LDR      r1,[r2,#0xc]          ;1309
0001bc  e009              B        |L13.466|
                  |L13.446|
0001be  e0bb              B        |L13.824|
                  |L13.448|
0001c0  e04a              B        |L13.600|
                  |L13.450|
0001c2  e024              B        |L13.526|
                  |L13.452|
0001c4  e030              B        |L13.552|
                  |L13.454|
0001c6  e03b              B        |L13.576|
                  |L13.456|
0001c8  e0a7              B        |L13.794|
                  |L13.458|
0001ca  e06d              B        |L13.680|
                  |L13.460|
0001cc  e051              B        |L13.626|
                  |L13.462|
0001ce  e099              B        |L13.772|
                  |L13.464|
0001d0  e0a4              B        |L13.796|
                  |L13.466|
0001d2  f3c15141          UBFX     r1,r1,#21,#2          ;1309
0001d6  e087              B        |L13.744|
                  |L13.472|
0001d8  6813              LDR      r3,[r2,#0]            ;1315
0001da  011b              LSLS     r3,r3,#4              ;1315
0001dc  d5dc              BPL      |L13.408|
0001de  6913              LDR      r3,[r2,#0x10]         ;1317
0001e0  02db              LSLS     r3,r3,#11             ;1317
0001e2  d5d9              BPL      |L13.408|
0001e4  68d0              LDR      r0,[r2,#0xc]          ;1325
0001e6  f3c01002          UBFX     r0,r0,#4,#3           ;1325
0001ea  1c40              ADDS     r0,r0,#1              ;1325
0001ec  fbb1f1f0          UDIV     r1,r1,r0              ;1325
0001f0  6910              LDR      r0,[r2,#0x10]         ;1328
0001f2  f3c02006          UBFX     r0,r0,#8,#7           ;1328
0001f6  4341              MULS     r1,r0,r1              ;1329
0001f8  6910              LDR      r0,[r2,#0x10]         ;1329
0001fa  f3c05041          UBFX     r0,r0,#21,#2          ;1329
0001fe  1c40              ADDS     r0,r0,#1              ;1329
000200  0040              LSLS     r0,r0,#1              ;1329
000202  fbb1f0f0          UDIV     r0,r1,r0              ;1329
                  |L13.518|
000206  e728              B        |L13.90|
                  |L13.520|
000208  e041              B        |L13.654|
                  |L13.522|
00020a  e0a5              B        |L13.856|
                  |L13.524|
00020c  e0b3              B        |L13.886|
                  |L13.526|
00020e  f8d21088          LDR      r1,[r2,#0x88]         ;1436
000212  f0110103          ANDS     r1,r1,#3              ;1436
000216  d071              BEQ      |L13.764|
000218  2901              CMP      r1,#1                 ;1438
00021a  d045              BEQ      |L13.680|
00021c  2902              CMP      r1,#2                 ;1438
00021e  d07b              BEQ      |L13.792|
000220  2903              CMP      r1,#3                 ;1438
000222  d1b9              BNE      |L13.408|
000224  e71b              B        |L13.94|
                  |L13.550|
000226  e064              B        |L13.754|
                  |L13.552|
000228  f8d21088          LDR      r1,[r2,#0x88]         ;1469
00022c  f011010c          ANDS     r1,r1,#0xc            ;1469
000230  d073              BEQ      |L13.794|
000232  2904              CMP      r1,#4                 ;1471
000234  d07c              BEQ      |L13.816|
000236  2908              CMP      r1,#8                 ;1471
000238  d06e              BEQ      |L13.792|
00023a  290c              CMP      r1,#0xc               ;1471
00023c  d1ac              BNE      |L13.408|
00023e  e70e              B        |L13.94|
                  |L13.576|
000240  f8d21088          LDR      r1,[r2,#0x88]         ;1504
000244  f0110130          ANDS     r1,r1,#0x30           ;1504
000248  d067              BEQ      |L13.794|
00024a  2910              CMP      r1,#0x10              ;1506
00024c  d070              BEQ      |L13.816|
00024e  2920              CMP      r1,#0x20              ;1506
000250  d062              BEQ      |L13.792|
000252  2930              CMP      r1,#0x30              ;1506
000254  d1a0              BNE      |L13.408|
000256  e702              B        |L13.94|
                  |L13.600|
000258  f8d21088          LDR      r1,[r2,#0x88]         ;1578
00025c  f4117140          ANDS     r1,r1,#0x300          ;1578
000260  d05b              BEQ      |L13.794|
000262  42b1              CMP      r1,r6                 ;1580
000264  d064              BEQ      |L13.816|
000266  4559              CMP      r1,r11                ;1580
000268  d056              BEQ      |L13.792|
00026a  f5b17f40          CMP      r1,#0x300             ;1580
00026e  d193              BNE      |L13.408|
000270  e6f5              B        |L13.94|
                  |L13.626|
000272  f8d21088          LDR      r1,[r2,#0x88]         ;1613
000276  f4116140          ANDS     r1,r1,#0xc00          ;1613
00027a  d04e              BEQ      |L13.794|
00027c  f5b16f80          CMP      r1,#0x400             ;1615
000280  d056              BEQ      |L13.816|
000282  4549              CMP      r1,r9                 ;1615
000284  d07f              BEQ      |L13.902|
000286  f5b16f40          CMP      r1,#0xc00             ;1615
00028a  d185              BNE      |L13.408|
00028c  e6e7              B        |L13.94|
                  |L13.654|
00028e  f8d23088          LDR      r3,[r2,#0x88]         ;1645
000292  f0035340          AND      r3,r3,#0x30000000     ;1645
000296  f1b35f80          CMP      r3,#0x10000000        ;1647
00029a  d006              BEQ      |L13.682|
00029c  f1b35f00          CMP      r3,#0x20000000        ;1647
0002a0  d012              BEQ      |L13.712|
0002a2  f1b35f40          CMP      r3,#0x30000000        ;1647
0002a6  d1ae              BNE      |L13.518|
                  |L13.680|
0002a8  e042              B        |L13.816|
                  |L13.682|
0002aa  6913              LDR      r3,[r2,#0x10]         ;1654
0002ac  01db              LSLS     r3,r3,#7              ;1654
0002ae  d5aa              BPL      |L13.518|
0002b0  68d0              LDR      r0,[r2,#0xc]          ;1662
0002b2  f3c01002          UBFX     r0,r0,#4,#3           ;1662
0002b6  1c40              ADDS     r0,r0,#1              ;1662
0002b8  fbb1f0f0          UDIV     r0,r1,r0              ;1662
0002bc  6911              LDR      r1,[r2,#0x10]         ;1665
0002be  f3c12106          UBFX     r1,r1,#8,#7           ;1665
0002c2  4348              MULS     r0,r1,r0              ;1666
0002c4  6911              LDR      r1,[r2,#0x10]         ;1666
0002c6  e00d              B        |L13.740|
                  |L13.712|
0002c8  6953              LDR      r3,[r2,#0x14]         ;1672
0002ca  01db              LSLS     r3,r3,#7              ;1672
0002cc  d59b              BPL      |L13.518|
0002ce  68d0              LDR      r0,[r2,#0xc]          ;1680
0002d0  f3c01002          UBFX     r0,r0,#4,#3           ;1680
0002d4  1c40              ADDS     r0,r0,#1              ;1680
0002d6  fbb1f0f0          UDIV     r0,r1,r0              ;1680
0002da  6951              LDR      r1,[r2,#0x14]         ;1683
0002dc  f3c12106          UBFX     r1,r1,#8,#7           ;1683
0002e0  4348              MULS     r0,r1,r0              ;1684
0002e2  6951              LDR      r1,[r2,#0x14]         ;1684
                  |L13.740|
0002e4  f3c16141          UBFX     r1,r1,#25,#2          ;1666
                  |L13.744|
0002e8  1c49              ADDS     r1,r1,#1              ;1666
0002ea  0049              LSLS     r1,r1,#1              ;1666
0002ec  fbb0f0f1          UDIV     r0,r0,r1              ;1666
                  |L13.752|
0002f0  e6b3              B        |L13.90|
                  |L13.754|
0002f2  f8d20088          LDR      r0,[r2,#0x88]         ;1701
0002f6  f0104f00          TST      r0,#0x80000000        ;1701
0002fa  d119              BNE      |L13.816|
                  |L13.764|
0002fc  e8bd5ff0          POP      {r4-r12,lr}           ;1705
000300  f7ffbffe          B.W      HAL_RCC_GetPCLK2Freq
                  |L13.772|
000304  f8d21088          LDR      r1,[r2,#0x88]         ;1755
000308  f4115140          ANDS     r1,r1,#0x3000         ;1755
00030c  d040              BEQ      |L13.912|
00030e  4551              CMP      r1,r10                ;1757
000310  d00e              BEQ      |L13.816|
000312  f5b15f00          CMP      r1,#0x2000            ;1757
000316  d1eb              BNE      |L13.752|
                  |L13.792|
000318  e035              B        |L13.902|
                  |L13.794|
00031a  e039              B        |L13.912|
                  |L13.796|
00031c  f8d21088          LDR      r1,[r2,#0x88]         ;1784
000320  f4114140          ANDS     r1,r1,#0xc000         ;1784
000324  d034              BEQ      |L13.912|
000326  4571              CMP      r1,lr                 ;1786
000328  d002              BEQ      |L13.816|
00032a  42a1              CMP      r1,r4                 ;1786
00032c  d1e0              BNE      |L13.752|
00032e  e02a              B        |L13.902|
                  |L13.816|
000330  e8bd5ff0          POP      {r4-r12,lr}           ;1821
000334  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L13.824|
000338  f8d21088          LDR      r1,[r2,#0x88]         ;1871
00033c  f4112140          ANDS     r1,r1,#0xc0000        ;1871
000340  d026              BEQ      |L13.912|
000342  f5b12f80          CMP      r1,#0x40000           ;1873
                  |L13.838|
000346  f43fae90          BEQ      |L13.106|
00034a  f5b12f00          CMP      r1,#0x80000           ;1873
00034e  d01a              BEQ      |L13.902|
000350  f5b12f40          CMP      r1,#0xc0000           ;1873
000354  d1cc              BNE      |L13.752|
000356  e682              B        |L13.94|
                  |L13.856|
000358  f8d21088          LDR      r1,[r2,#0x88]         ;1907
00035c  f4111140          ANDS     r1,r1,#0x300000       ;1907
000360  d016              BEQ      |L13.912|
000362  f5b11f80          CMP      r1,#0x100000          ;1909
000366  d0ee              BEQ      |L13.838|
000368  f5b11f00          CMP      r1,#0x200000          ;1909
00036c  d00b              BEQ      |L13.902|
00036e  f5b11f40          CMP      r1,#0x300000          ;1909
000372  d1bd              BNE      |L13.752|
000374  e673              B        |L13.94|
                  |L13.886|
000376  f8d21088          LDR      r1,[r2,#0x88]         ;1945
00037a  f0114180          ANDS     r1,r1,#0x40000000     ;1945
00037e  d007              BEQ      |L13.912|
000380  f1b14f80          CMP      r1,#0x40000000        ;1947
000384  d1b4              BNE      |L13.752|
                  |L13.902|
000386  6811              LDR      r1,[r2,#0]            ;1953
000388  0549              LSLS     r1,r1,#21             ;1953
00038a  d5b1              BPL      |L13.752|
00038c  4618              MOV      r0,r3                 ;1955
00038e  e664              B        |L13.90|
                  |L13.912|
000390  e8bd5ff0          POP      {r4-r12,lr}           ;1950
000394  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
;;;2017   
                          ENDP

                  |L13.920|
                          DCD      0x40021000
                  |L13.924|
                          DCD      MSIRangeTable
                  |L13.928|
                          DCD      0x00f42400
                  |L13.932|
                          DCD      0x0003d090
                  |L13.936|
                          DCD      0x007a1200

                          AREA ||i.HAL_RCCEx_LSECSS_Callback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_LSECSS_Callback PROC
;;;2378     */
;;;2379   __weak void HAL_RCCEx_LSECSS_Callback(void)
000000  4770              BX       lr
;;;2380   {
;;;2381     /* NOTE : This function should not be modified, when the callback is needed,
;;;2382               the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
;;;2383      */
;;;2384   }
;;;2385   
                          ENDP


                          AREA ||i.HAL_RCCEx_LSECSS_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_LSECSS_IRQHandler PROC
;;;2361     */
;;;2362   void HAL_RCCEx_LSECSS_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;2363   {
;;;2364     /* Check RCC LSE CSSF flag  */
;;;2365     if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
000002  4c04              LDR      r4,|L15.20|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  0580              LSLS     r0,r0,#22
000008  d503              BPL      |L15.18|
;;;2366     {
;;;2367       /* RCC LSE Clock Security System interrupt user callback */
;;;2368       HAL_RCCEx_LSECSS_Callback();
00000a  f7fffffe          BL       HAL_RCCEx_LSECSS_Callback
;;;2369   
;;;2370       /* Clear RCC LSE CSS pending bit */
;;;2371       __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
00000e  1560              ASRS     r0,r4,#21
000010  6220              STR      r0,[r4,#0x20]
                  |L15.18|
;;;2372     }
;;;2373   }
000012  bd10              POP      {r4,pc}
;;;2374   
                          ENDP

                  |L15.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;211      */
;;;212    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;213    {
000004  4604              MOV      r4,r0
;;;214      uint32_t tmpregister, tickstart;     /* no init needed */
;;;215      HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
000006  2500              MOVS     r5,#0
;;;216      HAL_StatusTypeDef status = HAL_OK;   /* Final status */
;;;217    
;;;218      /* Check the parameters */
;;;219      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;220    
;;;221    #if defined(SAI1)
;;;222    
;;;223      /*-------------------------- SAI1 clock source configuration ---------------------*/
;;;224      if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
000008  8800              LDRH     r0,[r0,#0]
;;;225      {
;;;226        /* Check the parameters */
;;;227        assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));
;;;228    
;;;229        switch(PeriphClkInit->Sai1ClockSelection)
;;;230        {
;;;231        case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
;;;232          /* Enable SAI Clock output generated form System PLL . */
;;;233    #if defined(RCC_PLLSAI2_SUPPORT)
;;;234          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
00000a  4ee4              LDR      r6,|L16.924|
00000c  462f              MOV      r7,r5                 ;216
00000e  0501              LSLS     r1,r0,#20             ;224
;;;235    #else
;;;236          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
;;;237    #endif /* RCC_PLLSAI2_SUPPORT */
;;;238          /* SAI1 clock source config set later after clock selection check */
;;;239          break;
;;;240    
;;;241        case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
;;;242          /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
;;;243          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
;;;244          /* SAI1 clock source config set later after clock selection check */
;;;245          break;
;;;246    
;;;247    #if defined(RCC_PLLSAI2_SUPPORT)
;;;248    
;;;249        case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
;;;250          /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
;;;251          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
000010  f1040b20          ADD      r11,r4,#0x20
000014  d51d              BPL      |L16.82|
000016  6e60              LDR      r0,[r4,#0x64]         ;229
000018  b178              CBZ      r0,|L16.58|
00001a  f5b00f80          CMP      r0,#0x400000          ;229
00001e  d011              BEQ      |L16.68|
000020  f5b00f00          CMP      r0,#0x800000          ;229
000024  d004              BEQ      |L16.48|
000026  f5b00f40          CMP      r0,#0xc00000          ;229
00002a  d022              BEQ      |L16.114|
;;;252          /* SAI1 clock source config set later after clock selection check */
;;;253          break;
;;;254    
;;;255    #endif /* RCC_PLLSAI2_SUPPORT */
;;;256    
;;;257        case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
;;;258    #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;259        case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
;;;260    #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;261          /* SAI1 clock source config set later after clock selection check */
;;;262          break;
;;;263    
;;;264        default:
;;;265          ret = HAL_ERROR;
00002c  2501              MOVS     r5,#1
;;;266          break;
00002e  e00f              B        |L16.80|
                  |L16.48|
000030  68f0              LDR      r0,[r6,#0xc]          ;234
000032  f4403080          ORR      r0,r0,#0x10000        ;234
000036  60f0              STR      r0,[r6,#0xc]          ;234
000038  e01b              B        |L16.114|
                  |L16.58|
00003a  2100              MOVS     r1,#0                 ;243
00003c  1d20              ADDS     r0,r4,#4              ;243
00003e  f7fffffe          BL       RCCEx_PLLSAI1_Config
000042  e003              B        |L16.76|
                  |L16.68|
000044  2100              MOVS     r1,#0                 ;251
000046  4658              MOV      r0,r11                ;251
000048  f7fffffe          BL       RCCEx_PLLSAI2_Config
                  |L16.76|
00004c  0005              MOVS     r5,r0                 ;243
00004e  d010              BEQ      |L16.114|
                  |L16.80|
;;;267        }
;;;268    
;;;269        if(ret == HAL_OK)
;;;270        {
;;;271          /* Set the source of SAI1 clock*/
;;;272          __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
;;;273        }
;;;274        else
;;;275        {
;;;276          /* set overall return value */
;;;277          status = ret;
000050  462f              MOV      r7,r5
                  |L16.82|
;;;278        }
;;;279      }
;;;280    
;;;281    #endif /* SAI1 */
;;;282    
;;;283    #if defined(SAI2)
;;;284    
;;;285      /*-------------------------- SAI2 clock source configuration ---------------------*/
;;;286      if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
000052  8820              LDRH     r0,[r4,#0]
000054  04c0              LSLS     r0,r0,#19
000056  d526              BPL      |L16.166|
;;;287      {
;;;288        /* Check the parameters */
;;;289        assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));
;;;290    
;;;291        switch(PeriphClkInit->Sai2ClockSelection)
000058  6ea0              LDR      r0,[r4,#0x68]
00005a  b1c0              CBZ      r0,|L16.142|
00005c  f1b07f80          CMP      r0,#0x1000000
000060  d01a              BEQ      |L16.152|
000062  f1b07f00          CMP      r0,#0x2000000
000066  d00d              BEQ      |L16.132|
000068  f1b07f40          CMP      r0,#0x3000000
00006c  d019              BEQ      |L16.162|
;;;292        {
;;;293        case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
;;;294          /* Enable SAI Clock output generated form System PLL . */
;;;295          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
;;;296          /* SAI2 clock source config set later after clock selection check */
;;;297          break;
;;;298    
;;;299        case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
;;;300          /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
;;;301          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
;;;302          /* SAI2 clock source config set later after clock selection check */
;;;303          break;
;;;304    
;;;305        case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
;;;306          /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
;;;307          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
;;;308          /* SAI2 clock source config set later after clock selection check */
;;;309          break;
;;;310    
;;;311        case RCC_SAI2CLKSOURCE_PIN:      /* External clock is used as source of SAI2 clock*/
;;;312    #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;313        case RCC_SAI2CLKSOURCE_HSI:      /* HSI is used as source of SAI2 clock*/
;;;314    #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;315          /* SAI2 clock source config set later after clock selection check */
;;;316          break;
;;;317    
;;;318        default:
;;;319          ret = HAL_ERROR;
00006e  2501              MOVS     r5,#1
;;;320          break;
000070  e018              B        |L16.164|
                  |L16.114|
000072  f8d60088          LDR      r0,[r6,#0x88]         ;272
000076  6e61              LDR      r1,[r4,#0x64]         ;272
000078  f4200040          BIC      r0,r0,#0xc00000       ;272
00007c  4308              ORRS     r0,r0,r1              ;272
00007e  f8c60088          STR      r0,[r6,#0x88]         ;272
000082  e7e6              B        |L16.82|
                  |L16.132|
000084  68f0              LDR      r0,[r6,#0xc]          ;295
000086  f4403080          ORR      r0,r0,#0x10000        ;295
00008a  60f0              STR      r0,[r6,#0xc]          ;295
00008c  e009              B        |L16.162|
                  |L16.142|
00008e  2100              MOVS     r1,#0                 ;301
000090  1d20              ADDS     r0,r4,#4              ;301
000092  f7fffffe          BL       RCCEx_PLLSAI1_Config
000096  e003              B        |L16.160|
                  |L16.152|
000098  2100              MOVS     r1,#0                 ;307
00009a  4658              MOV      r0,r11                ;307
00009c  f7fffffe          BL       RCCEx_PLLSAI2_Config
                  |L16.160|
0000a0  4605              MOV      r5,r0                 ;301
                  |L16.162|
;;;321        }
;;;322    
;;;323        if(ret == HAL_OK)
0000a2  b1f5              CBZ      r5,|L16.226|
                  |L16.164|
;;;324        {
;;;325          /* Set the source of SAI2 clock*/
;;;326          __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
;;;327        }
;;;328        else
;;;329        {
;;;330          /* set overall return value */
;;;331          status = ret;
0000a4  462f              MOV      r7,r5
                  |L16.166|
;;;332        }
;;;333      }
;;;334    #endif /* SAI2 */
;;;335    
;;;336      /*-------------------------- RTC clock source configuration ----------------------*/
;;;337      if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
0000a6  6820              LDR      r0,[r4,#0]
0000a8  0380              LSLS     r0,r0,#14
0000aa  d566              BPL      |L16.378|
;;;338      {
;;;339        FlagStatus       pwrclkchanged = RESET;
;;;340    
;;;341        /* Check for RTC Parameters used to output RTCCLK */
;;;342        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;343    
;;;344        /* Enable Power Clock */
;;;345        if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
0000ac  6db0              LDR      r0,[r6,#0x58]
0000ae  f04f0900          MOV      r9,#0                 ;339
0000b2  00c0              LSLS     r0,r0,#3
0000b4  d409              BMI      |L16.202|
;;;346        {
;;;347          __HAL_RCC_PWR_CLK_ENABLE();
0000b6  6db0              LDR      r0,[r6,#0x58]
0000b8  f0405080          ORR      r0,r0,#0x10000000
0000bc  65b0              STR      r0,[r6,#0x58]
0000be  6db0              LDR      r0,[r6,#0x58]
;;;348          pwrclkchanged = SET;
0000c0  f04f0901          MOV      r9,#1
0000c4  f0005080          AND      r0,r0,#0x10000000     ;347
0000c8  9000              STR      r0,[sp,#0]
                  |L16.202|
;;;349        }
;;;350    
;;;351        /* Enable write access to Backup domain */
;;;352        SET_BIT(PWR->CR1, PWR_CR1_DBP);
0000ca  f8dfa2d4          LDR      r10,|L16.928|
0000ce  f8da1000          LDR      r1,[r10,#0]
0000d2  f4417180          ORR      r1,r1,#0x100
0000d6  f8ca1000          STR      r1,[r10,#0]
;;;353    
;;;354        /* Wait for Backup domain Write protection disable */
;;;355        tickstart = HAL_GetTick();
0000da  f7fffffe          BL       HAL_GetTick
0000de  4680              MOV      r8,r0
;;;356    
;;;357        while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
0000e0  e010              B        |L16.260|
                  |L16.226|
0000e2  f8d60088          LDR      r0,[r6,#0x88]         ;326
0000e6  6ea1              LDR      r1,[r4,#0x68]         ;326
0000e8  f0207040          BIC      r0,r0,#0x3000000      ;326
0000ec  4308              ORRS     r0,r0,r1              ;326
0000ee  f8c60088          STR      r0,[r6,#0x88]         ;326
0000f2  e7d8              B        |L16.166|
                  |L16.244|
;;;358        {
;;;359          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
0000f4  f7fffffe          BL       HAL_GetTick
0000f8  eba00008          SUB      r0,r0,r8
0000fc  2802              CMP      r0,#2
0000fe  d901              BLS      |L16.260|
                  |L16.256|
;;;360          {
;;;361            ret = HAL_TIMEOUT;
000100  2503              MOVS     r5,#3
;;;362            break;
000102  e032              B        |L16.362|
                  |L16.260|
000104  f8da0000          LDR      r0,[r10,#0]           ;357
000108  05c0              LSLS     r0,r0,#23             ;357
00010a  d5f3              BPL      |L16.244|
;;;363          }
;;;364        }
;;;365    
;;;366        if(ret == HAL_OK)
00010c  bb6d              CBNZ     r5,|L16.362|
;;;367        {
;;;368          /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
;;;369          tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
00010e  f8d60090          LDR      r0,[r6,#0x90]
000112  f4107040          ANDS     r0,r0,#0x300
;;;370    
;;;371          if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
000116  d015              BEQ      |L16.324|
000118  f8d41084          LDR      r1,[r4,#0x84]
00011c  4281              CMP      r1,r0
00011e  d011              BEQ      |L16.324|
;;;372          {
;;;373            /* Store the content of BDCR register before the reset of Backup Domain */
;;;374            tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
000120  f8d60090          LDR      r0,[r6,#0x90]
;;;375            /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;376            __HAL_RCC_BACKUPRESET_FORCE();
000124  f8d61090          LDR      r1,[r6,#0x90]
000128  f4207040          BIC      r0,r0,#0x300          ;374
00012c  f4413180          ORR      r1,r1,#0x10000
000130  f8c61090          STR      r1,[r6,#0x90]
;;;377            __HAL_RCC_BACKUPRESET_RELEASE();
000134  f8d61090          LDR      r1,[r6,#0x90]
000138  f4213180          BIC      r1,r1,#0x10000
00013c  f8c61090          STR      r1,[r6,#0x90]
;;;378            /* Restore the Content of BDCR register */
;;;379            RCC->BDCR = tmpregister;
000140  f8c60090          STR      r0,[r6,#0x90]
                  |L16.324|
;;;380          }
;;;381    
;;;382          /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
;;;383          if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
000144  07c0              LSLS     r0,r0,#31
000146  d04e              BEQ      |L16.486|
;;;384          {
;;;385            /* Get Start Tick*/
;;;386            tickstart = HAL_GetTick();
000148  f7fffffe          BL       HAL_GetTick
00014c  4680              MOV      r8,r0
;;;387    
;;;388            /* Wait till LSE is ready */
;;;389            while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
;;;390            {
;;;391              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
00014e  f2413a88          MOV      r10,#0x1388
000152  e005              B        |L16.352|
                  |L16.340|
000154  f7fffffe          BL       HAL_GetTick
000158  eba00108          SUB      r1,r0,r8
00015c  4551              CMP      r1,r10
00015e  d8cf              BHI      |L16.256|
                  |L16.352|
000160  f8d60090          LDR      r0,[r6,#0x90]         ;389
000164  0780              LSLS     r0,r0,#30             ;389
000166  d5f5              BPL      |L16.340|
;;;392              {
;;;393                ret = HAL_TIMEOUT;
;;;394                break;
;;;395              }
;;;396            }
;;;397          }
;;;398    
;;;399          if(ret == HAL_OK)
000168  b3ed              CBZ      r5,|L16.486|
                  |L16.362|
;;;400          {
;;;401            /* Apply new RTC clock source selection */
;;;402            __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;403          }
;;;404          else
;;;405          {
;;;406            /* set overall return value */
;;;407            status = ret;
00016a  462f              MOV      r7,r5
                  |L16.364|
;;;408          }
;;;409        }
;;;410        else
;;;411        {
;;;412          /* set overall return value */
;;;413          status = ret;
;;;414        }
;;;415    
;;;416        /* Restore clock configuration if changed */
;;;417        if(pwrclkchanged == SET)
00016c  f1b90f00          CMP      r9,#0
000170  d003              BEQ      |L16.378|
;;;418        {
;;;419          __HAL_RCC_PWR_CLK_DISABLE();
000172  6db0              LDR      r0,[r6,#0x58]
000174  f0205080          BIC      r0,r0,#0x10000000
000178  65b0              STR      r0,[r6,#0x58]
                  |L16.378|
;;;420        }
;;;421      }
;;;422    
;;;423      /*-------------------------- USART1 clock source configuration -------------------*/
;;;424      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
00017a  7820              LDRB     r0,[r4,#0]
00017c  07c0              LSLS     r0,r0,#31
00017e  d007              BEQ      |L16.400|
;;;425      {
;;;426        /* Check the parameters */
;;;427        assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
;;;428    
;;;429        /* Configure the USART1 clock source */
;;;430        __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
000180  f8d60088          LDR      r0,[r6,#0x88]
000184  6ba1              LDR      r1,[r4,#0x38]
000186  f0200003          BIC      r0,r0,#3
00018a  4308              ORRS     r0,r0,r1
00018c  f8c60088          STR      r0,[r6,#0x88]
                  |L16.400|
;;;431      }
;;;432    
;;;433      /*-------------------------- USART2 clock source configuration -------------------*/
;;;434      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
000190  7820              LDRB     r0,[r4,#0]
000192  0780              LSLS     r0,r0,#30
000194  d507              BPL      |L16.422|
;;;435      {
;;;436        /* Check the parameters */
;;;437        assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
;;;438    
;;;439        /* Configure the USART2 clock source */
;;;440        __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
000196  f8d60088          LDR      r0,[r6,#0x88]
00019a  6be1              LDR      r1,[r4,#0x3c]
00019c  f020000c          BIC      r0,r0,#0xc
0001a0  4308              ORRS     r0,r0,r1
0001a2  f8c60088          STR      r0,[r6,#0x88]
                  |L16.422|
;;;441      }
;;;442    
;;;443    #if defined(USART3)
;;;444    
;;;445      /*-------------------------- USART3 clock source configuration -------------------*/
;;;446      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
0001a6  7820              LDRB     r0,[r4,#0]
0001a8  0740              LSLS     r0,r0,#29
0001aa  d507              BPL      |L16.444|
;;;447      {
;;;448        /* Check the parameters */
;;;449        assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
;;;450    
;;;451        /* Configure the USART3 clock source */
;;;452        __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
0001ac  f8d60088          LDR      r0,[r6,#0x88]
0001b0  6c21              LDR      r1,[r4,#0x40]
0001b2  f0200030          BIC      r0,r0,#0x30
0001b6  4308              ORRS     r0,r0,r1
0001b8  f8c60088          STR      r0,[r6,#0x88]
                  |L16.444|
;;;453      }
;;;454    
;;;455    #endif /* USART3 */
;;;456    
;;;457    #if defined(UART4)
;;;458    
;;;459      /*-------------------------- UART4 clock source configuration --------------------*/
;;;460      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
0001bc  7820              LDRB     r0,[r4,#0]
0001be  0700              LSLS     r0,r0,#28
0001c0  d507              BPL      |L16.466|
;;;461      {
;;;462        /* Check the parameters */
;;;463        assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
;;;464    
;;;465        /* Configure the UART4 clock source */
;;;466        __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
0001c2  f8d60088          LDR      r0,[r6,#0x88]
0001c6  6c61              LDR      r1,[r4,#0x44]
0001c8  f02000c0          BIC      r0,r0,#0xc0
0001cc  4308              ORRS     r0,r0,r1
0001ce  f8c60088          STR      r0,[r6,#0x88]
                  |L16.466|
;;;467      }
;;;468    
;;;469    #endif /* UART4 */
;;;470    
;;;471    #if defined(UART5)
;;;472    
;;;473      /*-------------------------- UART5 clock source configuration --------------------*/
;;;474      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
0001d2  7820              LDRB     r0,[r4,#0]
0001d4  06c0              LSLS     r0,r0,#27
0001d6  d509              BPL      |L16.492|
;;;475      {
;;;476        /* Check the parameters */
;;;477        assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
;;;478    
;;;479        /* Configure the UART5 clock source */
;;;480        __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
0001d8  f8d60088          LDR      r0,[r6,#0x88]
0001dc  6ca1              LDR      r1,[r4,#0x48]
0001de  f4207040          BIC      r0,r0,#0x300
0001e2  4308              ORRS     r0,r0,r1
0001e4  e000              B        |L16.488|
                  |L16.486|
0001e6  e05a              B        |L16.670|
                  |L16.488|
0001e8  f8c60088          STR      r0,[r6,#0x88]
                  |L16.492|
;;;481      }
;;;482    
;;;483    #endif /* UART5 */
;;;484    
;;;485      /*-------------------------- LPUART1 clock source configuration ------------------*/
;;;486      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
0001ec  7820              LDRB     r0,[r4,#0]
0001ee  0680              LSLS     r0,r0,#26
0001f0  d507              BPL      |L16.514|
;;;487      {
;;;488        /* Check the parameters */
;;;489        assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
;;;490    
;;;491        /* Configure the LPUAR1 clock source */
;;;492        __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
0001f2  f8d60088          LDR      r0,[r6,#0x88]
0001f6  6ce1              LDR      r1,[r4,#0x4c]
0001f8  f4206040          BIC      r0,r0,#0xc00
0001fc  4308              ORRS     r0,r0,r1
0001fe  f8c60088          STR      r0,[r6,#0x88]
                  |L16.514|
;;;493      }
;;;494    
;;;495      /*-------------------------- LPTIM1 clock source configuration -------------------*/
;;;496      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
000202  8820              LDRH     r0,[r4,#0]
000204  0580              LSLS     r0,r0,#22
000206  d507              BPL      |L16.536|
;;;497      {
;;;498        assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
;;;499        __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
000208  f8d60088          LDR      r0,[r6,#0x88]
00020c  6de1              LDR      r1,[r4,#0x5c]
00020e  f4202040          BIC      r0,r0,#0xc0000
000212  4308              ORRS     r0,r0,r1
000214  f8c60088          STR      r0,[r6,#0x88]
                  |L16.536|
;;;500      }
;;;501    
;;;502      /*-------------------------- LPTIM2 clock source configuration -------------------*/
;;;503      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
000218  8820              LDRH     r0,[r4,#0]
00021a  0540              LSLS     r0,r0,#21
00021c  d507              BPL      |L16.558|
;;;504      {
;;;505        assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
;;;506        __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
00021e  f8d60088          LDR      r0,[r6,#0x88]
000222  6e21              LDR      r1,[r4,#0x60]
000224  f4201040          BIC      r0,r0,#0x300000
000228  4308              ORRS     r0,r0,r1
00022a  f8c60088          STR      r0,[r6,#0x88]
                  |L16.558|
;;;507      }
;;;508    
;;;509      /*-------------------------- I2C1 clock source configuration ---------------------*/
;;;510      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
00022e  7820              LDRB     r0,[r4,#0]
000230  0640              LSLS     r0,r0,#25
000232  d507              BPL      |L16.580|
;;;511      {
;;;512        /* Check the parameters */
;;;513        assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
;;;514    
;;;515        /* Configure the I2C1 clock source */
;;;516        __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
000234  f8d60088          LDR      r0,[r6,#0x88]
000238  6d21              LDR      r1,[r4,#0x50]
00023a  f4205040          BIC      r0,r0,#0x3000
00023e  4308              ORRS     r0,r0,r1
000240  f8c60088          STR      r0,[r6,#0x88]
                  |L16.580|
;;;517      }
;;;518    
;;;519    #if defined(I2C2)
;;;520    
;;;521      /*-------------------------- I2C2 clock source configuration ---------------------*/
;;;522      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
000244  7820              LDRB     r0,[r4,#0]
000246  0600              LSLS     r0,r0,#24
000248  d507              BPL      |L16.602|
;;;523      {
;;;524        /* Check the parameters */
;;;525        assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
;;;526    
;;;527        /* Configure the I2C2 clock source */
;;;528        __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
00024a  f8d60088          LDR      r0,[r6,#0x88]
00024e  6d61              LDR      r1,[r4,#0x54]
000250  f4204040          BIC      r0,r0,#0xc000
000254  4308              ORRS     r0,r0,r1
000256  f8c60088          STR      r0,[r6,#0x88]
                  |L16.602|
;;;529      }
;;;530    
;;;531    #endif /* I2C2 */
;;;532    
;;;533      /*-------------------------- I2C3 clock source configuration ---------------------*/
;;;534      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
00025a  8820              LDRH     r0,[r4,#0]
00025c  05c0              LSLS     r0,r0,#23
00025e  d507              BPL      |L16.624|
;;;535      {
;;;536        /* Check the parameters */
;;;537        assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
;;;538    
;;;539        /* Configure the I2C3 clock source */
;;;540        __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
000260  f8d60088          LDR      r0,[r6,#0x88]
000264  6da1              LDR      r1,[r4,#0x58]
000266  f4203040          BIC      r0,r0,#0x30000
00026a  4308              ORRS     r0,r0,r1
00026c  f8c60088          STR      r0,[r6,#0x88]
                  |L16.624|
;;;541      }
;;;542    
;;;543    #if defined(I2C4)
;;;544    
;;;545      /*-------------------------- I2C4 clock source configuration ---------------------*/
;;;546      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
;;;547      {
;;;548        /* Check the parameters */
;;;549        assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
;;;550    
;;;551        /* Configure the I2C4 clock source */
;;;552        __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
;;;553      }
;;;554    
;;;555    #endif /* I2C4 */
;;;556    
;;;557    #if defined(USB_OTG_FS) || defined(USB)
;;;558    
;;;559      /*-------------------------- USB clock source configuration ----------------------*/
;;;560      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
000270  8820              LDRH     r0,[r4,#0]
;;;561      {
;;;562        assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
;;;563        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;564    
;;;565        if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
000272  f04f6500          MOV      r5,#0x8000000
000276  0480              LSLS     r0,r0,#18             ;560
;;;566        {
;;;567          /* Enable PLL48M1CLK output */
;;;568          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
;;;569        }
;;;570        else
;;;571        {
;;;572    #if defined(RCC_PLLSAI1_SUPPORT)
;;;573          if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
000278  f04f6880          MOV      r8,#0x4000000
00027c  d521              BPL      |L16.706|
00027e  f8d60088          LDR      r0,[r6,#0x88]         ;563
000282  6ee1              LDR      r1,[r4,#0x6c]         ;563
000284  f0206040          BIC      r0,r0,#0xc000000      ;563
000288  4308              ORRS     r0,r0,r1              ;563
00028a  f8c60088          STR      r0,[r6,#0x88]         ;563
00028e  6ee0              LDR      r0,[r4,#0x6c]         ;565
000290  42a8              CMP      r0,r5                 ;565
000292  d10e              BNE      |L16.690|
000294  68f0              LDR      r0,[r6,#0xc]          ;568
000296  f4401080          ORR      r0,r0,#0x100000       ;568
00029a  60f0              STR      r0,[r6,#0xc]          ;568
00029c  e011              B        |L16.706|
                  |L16.670|
00029e  f8d60090          LDR      r0,[r6,#0x90]         ;402
0002a2  f8d41084          LDR      r1,[r4,#0x84]         ;402
0002a6  f4207040          BIC      r0,r0,#0x300          ;402
0002aa  4308              ORRS     r0,r0,r1              ;402
0002ac  f8c60090          STR      r0,[r6,#0x90]         ;402
0002b0  e75c              B        |L16.364|
                  |L16.690|
0002b2  4540              CMP      r0,r8
0002b4  d105              BNE      |L16.706|
;;;574          {
;;;575            /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
;;;576            ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
0002b6  2101              MOVS     r1,#1
0002b8  1d20              ADDS     r0,r4,#4
0002ba  f7fffffe          BL       RCCEx_PLLSAI1_Config
;;;577    
;;;578            if(ret != HAL_OK)
0002be  b100              CBZ      r0,|L16.706|
;;;579            {
;;;580              /* set overall return value */
;;;581              status = ret;
0002c0  4607              MOV      r7,r0
                  |L16.706|
;;;582            }
;;;583          }
;;;584    #endif /* RCC_PLLSAI1_SUPPORT */
;;;585        }
;;;586      }
;;;587    
;;;588    #endif /* USB_OTG_FS || USB */
;;;589    
;;;590    #if defined(SDMMC1)
;;;591    
;;;592      /*-------------------------- SDMMC1 clock source configuration -------------------*/
;;;593      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
0002c2  6820              LDR      r0,[r4,#0]
0002c4  0300              LSLS     r0,r0,#12
0002c6  d517              BPL      |L16.760|
;;;594      {
;;;595        assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
;;;596        __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
0002c8  f8d60088          LDR      r0,[r6,#0x88]
0002cc  6f21              LDR      r1,[r4,#0x70]
0002ce  f0206040          BIC      r0,r0,#0xc000000
0002d2  4308              ORRS     r0,r0,r1
0002d4  f8c60088          STR      r0,[r6,#0x88]
;;;597    
;;;598        if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
0002d8  6f20              LDR      r0,[r4,#0x70]
0002da  42a8              CMP      r0,r5
0002dc  d104              BNE      |L16.744|
;;;599        {
;;;600          /* Enable PLL48M1CLK output */
;;;601          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
0002de  68f0              LDR      r0,[r6,#0xc]
0002e0  f4401080          ORR      r0,r0,#0x100000
0002e4  60f0              STR      r0,[r6,#0xc]
0002e6  e007              B        |L16.760|
                  |L16.744|
;;;602        }
;;;603    #if defined(RCC_CCIPR2_SDMMCSEL)
;;;604        else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLP) /* PLL "P" ? */
;;;605        {
;;;606          /* Enable PLLSAI3CLK output */
;;;607          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
;;;608        }
;;;609    #endif
;;;610        else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
0002e8  4540              CMP      r0,r8
0002ea  d105              BNE      |L16.760|
;;;611        {
;;;612          /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
;;;613          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
0002ec  2101              MOVS     r1,#1
0002ee  1d20              ADDS     r0,r4,#4
0002f0  f7fffffe          BL       RCCEx_PLLSAI1_Config
;;;614    
;;;615          if(ret != HAL_OK)
0002f4  b100              CBZ      r0,|L16.760|
;;;616          {
;;;617            /* set overall return value */
;;;618            status = ret;
0002f6  4607              MOV      r7,r0
                  |L16.760|
;;;619          }
;;;620        }
;;;621        else
;;;622        {
;;;623          /* nothing to do */
;;;624        }
;;;625      }
;;;626    
;;;627    #endif /* SDMMC1 */
;;;628    
;;;629      /*-------------------------- RNG clock source configuration ----------------------*/
;;;630      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
0002f8  6820              LDR      r0,[r4,#0]
0002fa  0340              LSLS     r0,r0,#13
0002fc  d517              BPL      |L16.814|
;;;631      {
;;;632        assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
;;;633        __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
0002fe  f8d60088          LDR      r0,[r6,#0x88]
000302  6f61              LDR      r1,[r4,#0x74]
000304  f0206040          BIC      r0,r0,#0xc000000
000308  4308              ORRS     r0,r0,r1
00030a  f8c60088          STR      r0,[r6,#0x88]
;;;634    
;;;635        if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
00030e  6f60              LDR      r0,[r4,#0x74]
000310  42a8              CMP      r0,r5
000312  d104              BNE      |L16.798|
;;;636        {
;;;637          /* Enable PLL48M1CLK output */
;;;638          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
000314  68f0              LDR      r0,[r6,#0xc]
000316  f4401080          ORR      r0,r0,#0x100000
00031a  60f0              STR      r0,[r6,#0xc]
00031c  e007              B        |L16.814|
                  |L16.798|
;;;639        }
;;;640    #if defined(RCC_PLLSAI1_SUPPORT)
;;;641        else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
00031e  4540              CMP      r0,r8
000320  d105              BNE      |L16.814|
;;;642        {
;;;643          /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
;;;644          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
000322  2101              MOVS     r1,#1
000324  1d20              ADDS     r0,r4,#4
000326  f7fffffe          BL       RCCEx_PLLSAI1_Config
;;;645    
;;;646          if(ret != HAL_OK)
00032a  b100              CBZ      r0,|L16.814|
;;;647          {
;;;648            /* set overall return value */
;;;649            status = ret;
00032c  4607              MOV      r7,r0
                  |L16.814|
;;;650          }
;;;651        }
;;;652    #endif /* RCC_PLLSAI1_SUPPORT */
;;;653        else
;;;654        {
;;;655          /* nothing to do */
;;;656        }
;;;657      }
;;;658    
;;;659      /*-------------------------- ADC clock source configuration ----------------------*/
;;;660    #if !defined(STM32L412xx) && !defined(STM32L422xx)
;;;661      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
00032e  8820              LDRH     r0,[r4,#0]
000330  0440              LSLS     r0,r0,#17
000332  d51a              BPL      |L16.874|
;;;662      {
;;;663        /* Check the parameters */
;;;664        assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
;;;665    
;;;666        /* Configure the ADC interface clock source */
;;;667        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
000334  f8d60088          LDR      r0,[r6,#0x88]
000338  6fa1              LDR      r1,[r4,#0x78]
00033a  f0205040          BIC      r0,r0,#0x30000000
00033e  4308              ORRS     r0,r0,r1
000340  f8c60088          STR      r0,[r6,#0x88]
;;;668    
;;;669    #if defined(RCC_PLLSAI1_SUPPORT)
;;;670        if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
000344  6fa0              LDR      r0,[r4,#0x78]
000346  f1b05f80          CMP      r0,#0x10000000
00034a  d003              BEQ      |L16.852|
;;;671        {
;;;672          /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
;;;673          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
;;;674    
;;;675          if(ret != HAL_OK)
;;;676          {
;;;677            /* set overall return value */
;;;678            status = ret;
;;;679          }
;;;680        }
;;;681    #endif /* RCC_PLLSAI1_SUPPORT */
;;;682    
;;;683    #if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) || defined(STM32L496xx) || defined(STM32L4A6xx)
;;;684    
;;;685        else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
00034c  f1b05f00          CMP      r0,#0x20000000
000350  d005              BEQ      |L16.862|
000352  e00a              B        |L16.874|
                  |L16.852|
000354  2102              MOVS     r1,#2                 ;673
000356  1d20              ADDS     r0,r4,#4              ;673
000358  f7fffffe          BL       RCCEx_PLLSAI1_Config
00035c  e003              B        |L16.870|
                  |L16.862|
;;;686        {
;;;687          /* PLLSAI2 input clock, parameters M, N & R configuration and clock output (PLLSAI2ClockOut) */
;;;688          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
00035e  2102              MOVS     r1,#2
000360  4658              MOV      r0,r11
000362  f7fffffe          BL       RCCEx_PLLSAI2_Config
                  |L16.870|
000366  b100              CBZ      r0,|L16.874|
;;;689    
;;;690          if(ret != HAL_OK)
;;;691          {
;;;692            /* set overall return value */
;;;693            status = ret;
000368  4607              MOV      r7,r0
                  |L16.874|
;;;694          }
;;;695        }
;;;696    
;;;697    #endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx || STM32L496xx || STM32L4A6xx */
;;;698    
;;;699      }
;;;700    #endif /* !STM32L412xx && !STM32L422xx */
;;;701    
;;;702    #if defined(SWPMI1)
;;;703    
;;;704      /*-------------------------- SWPMI1 clock source configuration -------------------*/
;;;705      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
00036a  8820              LDRH     r0,[r4,#0]
00036c  0400              LSLS     r0,r0,#16
00036e  d507              BPL      |L16.896|
;;;706      {
;;;707        /* Check the parameters */
;;;708        assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
;;;709    
;;;710        /* Configure the SWPMI1 clock source */
;;;711        __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
000370  f8d60088          LDR      r0,[r6,#0x88]
000374  6fe1              LDR      r1,[r4,#0x7c]
000376  f0204080          BIC      r0,r0,#0x40000000
00037a  4308              ORRS     r0,r0,r1
00037c  f8c60088          STR      r0,[r6,#0x88]
                  |L16.896|
;;;712      }
;;;713    
;;;714    #endif /* SWPMI1 */
;;;715    
;;;716    #if defined(DFSDM1_Filter0)
;;;717    
;;;718      /*-------------------------- DFSDM1 clock source configuration -------------------*/
;;;719      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
000380  6820              LDR      r0,[r4,#0]
000382  03c0              LSLS     r0,r0,#15
000384  d507              BPL      |L16.918|
;;;720      {
;;;721        /* Check the parameters */
;;;722        assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
;;;723    
;;;724        /* Configure the DFSDM1 interface clock source */
;;;725        __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
000386  f8560f88          LDR      r0,[r6,#0x88]!
00038a  f8d41080          LDR      r1,[r4,#0x80]
00038e  f0204000          BIC      r0,r0,#0x80000000
000392  4308              ORRS     r0,r0,r1
000394  6030              STR      r0,[r6,#0]
                  |L16.918|
;;;726      }
;;;727    
;;;728    #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;729      /*-------------------------- DFSDM1 audio clock source configuration -------------*/
;;;730      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
;;;731      {
;;;732        /* Check the parameters */
;;;733        assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));
;;;734    
;;;735        /* Configure the DFSDM1 interface audio clock source */
;;;736        __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
;;;737      }
;;;738    
;;;739    #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;740    
;;;741    #endif /* DFSDM1_Filter0 */
;;;742    
;;;743    #if defined(LTDC)
;;;744    
;;;745      /*-------------------------- LTDC clock source configuration --------------------*/
;;;746      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
;;;747      {
;;;748        /* Check the parameters */
;;;749        assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
;;;750    
;;;751        /* Disable the PLLSAI2 */
;;;752        __HAL_RCC_PLLSAI2_DISABLE();
;;;753    
;;;754        /* Get Start Tick*/
;;;755        tickstart = HAL_GetTick();
;;;756    
;;;757        /* Wait till PLLSAI2 is ready */
;;;758        while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
;;;759        {
;;;760          if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
;;;761          {
;;;762            ret = HAL_TIMEOUT;
;;;763            break;
;;;764          }
;;;765        }
;;;766    
;;;767        if(ret == HAL_OK)
;;;768        {
;;;769          /* Configure the LTDC clock source */
;;;770          __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
;;;771    
;;;772          /* PLLSAI2 input clock, parameters M, N & R configuration and clock output (PLLSAI2ClockOut) */
;;;773          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
;;;774        }
;;;775    
;;;776        if(ret != HAL_OK)
;;;777        {
;;;778          /* set overall return value */
;;;779          status = ret;
;;;780        }
;;;781      }
;;;782    
;;;783    #endif /* LTDC */
;;;784    
;;;785    #if defined(DSI)
;;;786    
;;;787      /*-------------------------- DSI clock source configuration ---------------------*/
;;;788      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)
;;;789      {
;;;790        /* Check the parameters */
;;;791        assert_param(IS_RCC_DSICLKSOURCE(PeriphClkInit->DsiClockSelection));
;;;792    
;;;793        /* Configure the DSI clock source */
;;;794        __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
;;;795    
;;;796        if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
;;;797        {
;;;798          /* PLLSAI2 input clock, parameters M, N & Q configuration and clock output (PLLSAI2ClockOut) */
;;;799          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_Q_UPDATE);
;;;800    
;;;801          if(ret != HAL_OK)
;;;802          {
;;;803            /* set overall return value */
;;;804            status = ret;
;;;805          }
;;;806        }
;;;807      }
;;;808    
;;;809    #endif /* DSI */
;;;810    
;;;811    #if defined(OCTOSPI1) || defined(OCTOSPI2)
;;;812    
;;;813      /*-------------------------- OctoSPIx clock source configuration ----------------*/
;;;814      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
;;;815      {
;;;816        /* Check the parameters */
;;;817        assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));
;;;818    
;;;819        /* Configure the OctoSPI clock source */
;;;820        __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
;;;821    
;;;822        if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
;;;823        {
;;;824          /* Enable PLL48M1CLK output */
;;;825          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
;;;826        }
;;;827      }
;;;828    
;;;829    #endif /* OCTOSPI1 || OCTOSPI2 */
;;;830    
;;;831      return status;
000396  4638              MOV      r0,r7
;;;832    }
000398  e8bd8ff8          POP      {r3-r11,pc}
;;;833    
                          ENDP

                  |L16.924|
                          DCD      0x40021000
                  |L16.928|
                          DCD      0x40007000

                          AREA ||i.HAL_RCCEx_StandbyMSIRangeConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_StandbyMSIRangeConfig PROC
;;;2307     */
;;;2308   void HAL_RCCEx_StandbyMSIRangeConfig(uint32_t MSIRange)
000000  4904              LDR      r1,|L17.20|
;;;2309   {
;;;2310     assert_param(IS_RCC_MSI_STANDBY_CLOCK_RANGE(MSIRange));
;;;2311   
;;;2312     __HAL_RCC_MSI_STANDBY_RANGE_CONFIG(MSIRange);
000002  f8512f94          LDR      r2,[r1,#0x94]!
000006  f4226270          BIC      r2,r2,#0xf00
00000a  ea421000          ORR      r0,r2,r0,LSL #4
00000e  6008              STR      r0,[r1,#0]
;;;2313   }
000010  4770              BX       lr
;;;2314   
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_WakeUpStopCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_WakeUpStopCLKConfig PROC
;;;2289     */
;;;2290   void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
000000  4903              LDR      r1,|L18.16|
;;;2291   {
;;;2292     assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));
;;;2293   
;;;2294     __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
000002  688a              LDR      r2,[r1,#8]
000004  f4224200          BIC      r2,r2,#0x8000
000008  4302              ORRS     r2,r2,r0
00000a  608a              STR      r2,[r1,#8]
;;;2295   }
00000c  4770              BX       lr
;;;2296   
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40021000

                          AREA ||i.RCCEx_GetSAIxPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  RCCEx_GetSAIxPeriphCLKFreq PROC
;;;3278   
;;;3279   static uint32_t RCCEx_GetSAIxPeriphCLKFreq(uint32_t PeriphClk, uint32_t InputFrequency)
000000  b530              PUSH     {r4,r5,lr}
;;;3280   {
000002  4604              MOV      r4,r0
;;;3281     uint32_t frequency = 0U;
000004  2000              MOVS     r0,#0
;;;3282     uint32_t srcclk = 0U;
;;;3283     uint32_t pllvco, plln;    /* no init needed */
;;;3284   #if defined(RCC_PLLP_SUPPORT)
;;;3285     uint32_t pllp = 0U;
;;;3286   #endif /* RCC_PLLP_SUPPORT */
;;;3287   
;;;3288     /* Handle SAIs */
;;;3289     if(PeriphClk == RCC_PERIPHCLK_SAI1)
;;;3290     {
;;;3291       srcclk = __HAL_RCC_GET_SAI1_SOURCE();
;;;3292       if(srcclk == RCC_SAI1CLKSOURCE_PIN)
;;;3293       {
;;;3294         frequency = EXTERNAL_SAI1_CLOCK_VALUE;
000006  4d2d              LDR      r5,|L19.188|
000008  4b2d              LDR      r3,|L19.192|
00000a  4602              MOV      r2,r0                 ;3282
00000c  f5b46f00          CMP      r4,#0x800             ;3289
000010  d003              BEQ      |L19.26|
;;;3295       }
;;;3296       /* Else, PLL clock output to check below */
;;;3297     }
;;;3298   #if defined(SAI2)
;;;3299     else
;;;3300     {
;;;3301       if(PeriphClk == RCC_PERIPHCLK_SAI2)
000012  f5b45f80          CMP      r4,#0x1000
000016  d008              BEQ      |L19.42|
000018  e00e              B        |L19.56|
                  |L19.26|
00001a  f8d32088          LDR      r2,[r3,#0x88]         ;3291
00001e  f4020240          AND      r2,r2,#0xc00000       ;3291
000022  f5b20f40          CMP      r2,#0xc00000          ;3292
000026  d022              BEQ      |L19.110|
000028  e006              B        |L19.56|
                  |L19.42|
;;;3302       {
;;;3303         srcclk = __HAL_RCC_GET_SAI2_SOURCE();
00002a  f8d32088          LDR      r2,[r3,#0x88]
00002e  f0027240          AND      r2,r2,#0x3000000
;;;3304         if(srcclk == RCC_SAI2CLKSOURCE_PIN)
000032  f1b27f40          CMP      r2,#0x3000000
000036  d01a              BEQ      |L19.110|
                  |L19.56|
;;;3305         {
;;;3306           frequency = EXTERNAL_SAI2_CLOCK_VALUE;
;;;3307         }
;;;3308         /* Else, PLL clock output to check below */
;;;3309       }
;;;3310     }
;;;3311   #endif /* SAI2 */
;;;3312   
;;;3313     if(frequency == 0U)
;;;3314     {
;;;3315       pllvco = InputFrequency;
;;;3316   
;;;3317   #if defined(SAI2)
;;;3318       if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
000038  f5b20f00          CMP      r2,#0x800000
00003c  d019              BEQ      |L19.114|
00003e  f1b27f00          CMP      r2,#0x2000000
000042  d016              BEQ      |L19.114|
;;;3319       {
;;;3320         if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U)
;;;3321         {
;;;3322           /* f(PLL Source) / PLLM */
;;;3323           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3324           /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
;;;3325           plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;3326   #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;3327           pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;3328   #endif
;;;3329           if(pllp == 0U)
;;;3330           {
;;;3331             if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;3332             {
;;;3333               pllp = 17U;
;;;3334             }
;;;3335             else
;;;3336             {
;;;3337               pllp = 7U;
;;;3338             }
;;;3339           }
;;;3340           frequency = (pllvco * plln) / pllp;
;;;3341         }
;;;3342       }
;;;3343       else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
000044  b33a              CBZ      r2,|L19.150|
;;;3344       {
;;;3345         if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U)
;;;3346         {
;;;3347   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3348           /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;3349           /* f(PLLSAI1 Source) / PLLSAI1M */
;;;3350           pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;3351   #else
;;;3352           /* f(PLL Source) / PLLM */
;;;3353           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3354   #endif
;;;3355           /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
;;;3356           plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;3357   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;3358           pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
;;;3359   #endif
;;;3360           if(pllp == 0U)
;;;3361           {
;;;3362             if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
;;;3363             {
;;;3364               pllp = 17U;
;;;3365             }
;;;3366             else
;;;3367             {
;;;3368               pllp = 7U;
;;;3369             }
;;;3370           }
;;;3371           frequency = (pllvco * plln) / pllp;
;;;3372         }
;;;3373       }
;;;3374   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;3375       else if((srcclk == RCC_SAI1CLKSOURCE_HSI) || (srcclk == RCC_SAI2CLKSOURCE_HSI))
;;;3376       {
;;;3377         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;3378         {
;;;3379           frequency = HSI_VALUE;
;;;3380         }
;;;3381       }
;;;3382   #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;3383   
;;;3384   #else
;;;3385       if(srcclk == RCC_SAI1CLKSOURCE_PLL)
;;;3386       {
;;;3387         if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI2CLK) != 0U)
;;;3388         {
;;;3389           /* f(PLL Source) / PLLM */
;;;3390           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3391           /* f(PLLSAI2CLK) = f(VCO input) * PLLN / PLLP */
;;;3392           plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;3393   #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;3394           pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;3395   #endif
;;;3396           if(pllp == 0U)
;;;3397           {
;;;3398             if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;3399             {
;;;3400               pllp = 17U;
;;;3401             }
;;;3402             else
;;;3403             {
;;;3404               pllp = 7U;
;;;3405             }
;;;3406           }
;;;3407           frequency = (pllvco * plln) / pllp;
;;;3408         }
;;;3409         else if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;3410         {
;;;3411           /* HSI automatically selected as clock source if PLLs not enabled */
;;;3412           frequency = HSI_VALUE;
;;;3413         }
;;;3414         else
;;;3415         {
;;;3416           /* No clock source, frequency default init at 0 */
;;;3417         }
;;;3418       }
;;;3419       else if(srcclk == RCC_SAI1CLKSOURCE_PLLSAI1)
;;;3420       {
;;;3421         if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U)
;;;3422         {
;;;3423   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3424           /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;3425           /* f(PLLSAI1 Source) / PLLSAI1M */
;;;3426           pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;3427   #else
;;;3428           /* f(PLL Source) / PLLM */
;;;3429           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3430   #endif
;;;3431           /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
;;;3432           plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;3433   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;3434           pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
;;;3435   #endif
;;;3436           if(pllp == 0U)
;;;3437           {
;;;3438             if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
;;;3439             {
;;;3440               pllp = 17U;
;;;3441             }
;;;3442             else
;;;3443             {
;;;3444               pllp = 7U;
;;;3445             }
;;;3446           }
;;;3447           frequency = (pllvco * plln) / pllp;
;;;3448         }
;;;3449         else if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;3450         {
;;;3451           /* HSI automatically selected as clock source if PLLs not enabled */
;;;3452           frequency = HSI_VALUE;
;;;3453         }
;;;3454         else
;;;3455         {
;;;3456           /* No clock source, frequency default init at 0 */
;;;3457         }
;;;3458       }
;;;3459   #endif /* SAI2 */
;;;3460   
;;;3461   #if defined(RCC_PLLSAI2_SUPPORT)
;;;3462   
;;;3463       else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
000046  f5b20f80          CMP      r2,#0x400000
00004a  d002              BEQ      |L19.82|
00004c  f1b27f80          CMP      r2,#0x1000000
000050  d10e              BNE      |L19.112|
                  |L19.82|
;;;3464       {
;;;3465         if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U)
000052  695a              LDR      r2,[r3,#0x14]
000054  03d2              LSLS     r2,r2,#15
000056  d50b              BPL      |L19.112|
;;;3466         {
;;;3467   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3468           /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
;;;3469           /* f(PLLSAI2 Source) / PLLSAI2M */
;;;3470           pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
;;;3471   #else
;;;3472           /* f(PLL Source) / PLLM */
;;;3473           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
000058  68d8              LDR      r0,[r3,#0xc]
00005a  f3c01002          UBFX     r0,r0,#4,#3
00005e  1c40              ADDS     r0,r0,#1
000060  fbb1f1f0          UDIV     r1,r1,r0
;;;3474   #endif
;;;3475           /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
;;;3476           plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
000064  6958              LDR      r0,[r3,#0x14]
000066  f3c02206          UBFX     r2,r0,#8,#7
;;;3477   #if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
;;;3478           pllp = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos;
;;;3479   #endif
;;;3480           if(pllp == 0U)
;;;3481           {
;;;3482             if(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) != 0U)
00006a  6958              LDR      r0,[r3,#0x14]
00006c  e020              B        |L19.176|
                  |L19.110|
00006e  4628              MOV      r0,r5                 ;3306
                  |L19.112|
;;;3483             {
;;;3484               pllp = 17U;
;;;3485             }
;;;3486             else
;;;3487             {
;;;3488               pllp = 7U;
;;;3489             }
;;;3490           }
;;;3491           frequency = (pllvco * plln) / pllp;
;;;3492         }
;;;3493       }
;;;3494   
;;;3495   #endif /* RCC_PLLSAI2_SUPPORT */
;;;3496   
;;;3497       else
;;;3498       {
;;;3499         /* No clock source, frequency default init at 0 */
;;;3500       }
;;;3501     }
;;;3502   
;;;3503   
;;;3504     return frequency;
;;;3505   }
000070  bd30              POP      {r4,r5,pc}
                  |L19.114|
000072  68da              LDR      r2,[r3,#0xc]          ;3320
000074  03d2              LSLS     r2,r2,#15             ;3320
000076  d5fb              BPL      |L19.112|
000078  68d8              LDR      r0,[r3,#0xc]          ;3323
00007a  f3c01002          UBFX     r0,r0,#4,#3           ;3323
00007e  1c40              ADDS     r0,r0,#1              ;3323
000080  fbb1f1f0          UDIV     r1,r1,r0              ;3323
000084  68d8              LDR      r0,[r3,#0xc]          ;3325
000086  f3c02206          UBFX     r2,r0,#8,#7           ;3325
00008a  68d8              LDR      r0,[r3,#0xc]          ;3331
00008c  e010              B        |L19.176|
                  |L19.142|
00008e  4351              MULS     r1,r2,r1              ;3340
000090  fbb1f0f0          UDIV     r0,r1,r0              ;3340
                  |L19.148|
000094  bd30              POP      {r4,r5,pc}
                  |L19.150|
000096  691a              LDR      r2,[r3,#0x10]         ;3345
000098  03d2              LSLS     r2,r2,#15             ;3345
00009a  d5fb              BPL      |L19.148|
00009c  68d8              LDR      r0,[r3,#0xc]          ;3353
00009e  f3c01002          UBFX     r0,r0,#4,#3           ;3353
0000a2  1c40              ADDS     r0,r0,#1              ;3353
0000a4  fbb1f1f0          UDIV     r1,r1,r0              ;3353
0000a8  6918              LDR      r0,[r3,#0x10]         ;3356
0000aa  f3c02206          UBFX     r2,r0,#8,#7           ;3356
0000ae  6918              LDR      r0,[r3,#0x10]         ;3362
                  |L19.176|
0000b0  0380              LSLS     r0,r0,#14             ;3331
0000b2  d501              BPL      |L19.184|
0000b4  2011              MOVS     r0,#0x11              ;3484
0000b6  e7ea              B        |L19.142|
                  |L19.184|
0000b8  2007              MOVS     r0,#7                 ;3488
0000ba  e7e8              B        |L19.142|
;;;3506   
                          ENDP

                  |L19.188|
                          DCD      0x001fff68
                  |L19.192|
                          DCD      0x40021000

                          AREA ||i.RCCEx_PLLSAI1_Config||, CODE, READONLY, ALIGN=2

                  RCCEx_PLLSAI1_Config PROC
;;;2876     */
;;;2877   static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2878   {
;;;2879     uint32_t tickstart;
;;;2880     HAL_StatusTypeDef status = HAL_OK;
;;;2881   
;;;2882     /* check for PLLSAI1 Parameters used to output PLLSAI1CLK */
;;;2883     /* P, Q and R dividers are verified in each specific divider case below */
;;;2884     assert_param(IS_RCC_PLLSAI1SOURCE(PllSai1->PLLSAI1Source));
;;;2885     assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
;;;2886     assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
;;;2887     assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));
;;;2888   
;;;2889     /* Check that PLLSAI1 clock source and divider M can be applied */
;;;2890     if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
000004  4e44              LDR      r6,|L20.280|
000006  4605              MOV      r5,r0                 ;2878
000008  4688              MOV      r8,r1                 ;2878
00000a  68f0              LDR      r0,[r6,#0xc]
00000c  2400              MOVS     r4,#0                 ;2880
00000e  0781              LSLS     r1,r0,#30
000010  6828              LDR      r0,[r5,#0]            ;2878
000012  d00e              BEQ      |L20.50|
;;;2891     {
;;;2892       /* PLL clock source and divider M already set, check that no request for change  */
;;;2893       if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
000014  68f1              LDR      r1,[r6,#0xc]
000016  f0010103          AND      r1,r1,#3
00001a  4281              CMP      r1,r0
00001c  d107              BNE      |L20.46|
;;;2894          ||
;;;2895          (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
00001e  b130              CBZ      r0,|L20.46|
;;;2896   #if !defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2897          ||
;;;2898          (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
000020  68f0              LDR      r0,[r6,#0xc]
000022  6869              LDR      r1,[r5,#4]
000024  f3c01002          UBFX     r0,r0,#4,#3
000028  1c40              ADDS     r0,r0,#1
00002a  4288              CMP      r0,r1
00002c  d01f              BEQ      |L20.110|
                  |L20.46|
;;;2899   #endif
;;;2900         )
;;;2901       {
;;;2902         status = HAL_ERROR;
00002e  2401              MOVS     r4,#1
000030  e06e              B        |L20.272|
                  |L20.50|
;;;2903       }
;;;2904     }
;;;2905     else
;;;2906     {
;;;2907       /* Check PLLSAI1 clock source availability */
;;;2908       switch(PllSai1->PLLSAI1Source)
000032  2801              CMP      r0,#1
000034  d009              BEQ      |L20.74|
000036  2802              CMP      r0,#2
000038  d00a              BEQ      |L20.80|
00003a  2803              CMP      r0,#3
00003c  d1f7              BNE      |L20.46|
;;;2909       {
;;;2910       case RCC_PLLSOURCE_MSI:
;;;2911         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
;;;2912         {
;;;2913           status = HAL_ERROR;
;;;2914         }
;;;2915         break;
;;;2916       case RCC_PLLSOURCE_HSI:
;;;2917         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
;;;2918         {
;;;2919           status = HAL_ERROR;
;;;2920         }
;;;2921         break;
;;;2922       case RCC_PLLSOURCE_HSE:
;;;2923         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
00003e  6831              LDR      r1,[r6,#0]
000040  0389              LSLS     r1,r1,#14
000042  d409              BMI      |L20.88|
;;;2924         {
;;;2925           if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
000044  6831              LDR      r1,[r6,#0]
000046  0349              LSLS     r1,r1,#13
000048  e004              B        |L20.84|
                  |L20.74|
00004a  6831              LDR      r1,[r6,#0]            ;2911
00004c  0789              LSLS     r1,r1,#30             ;2911
00004e  e001              B        |L20.84|
                  |L20.80|
000050  6831              LDR      r1,[r6,#0]            ;2917
000052  0549              LSLS     r1,r1,#21             ;2917
                  |L20.84|
000054  2900              CMP      r1,#0                 ;2911
000056  daea              BGE      |L20.46|
                  |L20.88|
;;;2926           {
;;;2927             status = HAL_ERROR;
;;;2928           }
;;;2929         }
;;;2930         break;
;;;2931       default:
;;;2932         status = HAL_ERROR;
;;;2933         break;
;;;2934       }
;;;2935   
;;;2936       if(status == HAL_OK)
;;;2937       {
;;;2938   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2939         /* Set PLLSAI1 clock source */
;;;2940         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
;;;2941   #else
;;;2942         /* Set PLLSAI1 clock source and divider M */
;;;2943         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
000058  68f1              LDR      r1,[r6,#0xc]
00005a  686a              LDR      r2,[r5,#4]
00005c  f06f030f          MVN      r3,#0xf
000060  f0210173          BIC      r1,r1,#0x73
000064  eb031202          ADD      r2,r3,r2,LSL #4
000068  4311              ORRS     r1,r1,r2
00006a  4301              ORRS     r1,r1,r0
00006c  60f1              STR      r1,[r6,#0xc]
                  |L20.110|
;;;2944   #endif
;;;2945       }
;;;2946     }
;;;2947   
;;;2948     if(status == HAL_OK)
;;;2949     {
;;;2950       /* Disable the PLLSAI1 */
;;;2951       __HAL_RCC_PLLSAI1_DISABLE();
00006e  6830              LDR      r0,[r6,#0]
000070  f0206080          BIC      r0,r0,#0x4000000
000074  6030              STR      r0,[r6,#0]
;;;2952   
;;;2953       /* Get Start Tick*/
;;;2954       tickstart = HAL_GetTick();
000076  f7fffffe          BL       HAL_GetTick
00007a  4607              MOV      r7,r0
;;;2955   
;;;2956       /* Wait till PLLSAI1 is ready to be updated */
;;;2957       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
00007c  e004              B        |L20.136|
                  |L20.126|
;;;2958       {
;;;2959         if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
00007e  f7fffffe          BL       HAL_GetTick
000082  1bc0              SUBS     r0,r0,r7
000084  2802              CMP      r0,#2
000086  d839              BHI      |L20.252|
                  |L20.136|
000088  6830              LDR      r0,[r6,#0]            ;2957
00008a  0100              LSLS     r0,r0,#4              ;2957
00008c  d4f7              BMI      |L20.126|
;;;2960         {
;;;2961           status = HAL_TIMEOUT;
;;;2962           break;
;;;2963         }
;;;2964       }
;;;2965   
;;;2966       if(status == HAL_OK)
00008e  bb7c              CBNZ     r4,|L20.240|
;;;2967       {
;;;2968         if(Divider == DIVIDER_P_UPDATE)
000090  f1b80f00          CMP      r8,#0
000094  d018              BEQ      |L20.200|
;;;2969         {
;;;2970           assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
;;;2971   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2972   
;;;2973           /* Configure the PLLSAI1 Division factor M, P and Multiplication factor N*/
;;;2974   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;2975           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;2976                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;2977                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;2978                      (PllSai1->PLLSAI1P << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) |
;;;2979                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;2980   #else
;;;2981           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;2982                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;2983                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;2984                      ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos) |
;;;2985                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;2986   #endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
;;;2987   
;;;2988   #else
;;;2989           /* Configure the PLLSAI1 Division factor P and Multiplication factor N*/
;;;2990   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;2991           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;2992                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV,
;;;2993                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;2994                      (PllSai1->PLLSAI1P << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos));
;;;2995   #else
;;;2996           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;2997                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P,
;;;2998                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;2999                      ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
;;;3000   #endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
;;;3001   
;;;3002   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;3003         }
;;;3004         else if(Divider == DIVIDER_Q_UPDATE)
000096  f1b80f01          CMP      r8,#1
00009a  d01e              BEQ      |L20.218|
;;;3005         {
;;;3006           assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
;;;3007   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3008           /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
;;;3009           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3010                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1Q | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;3011                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3012                      (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) |
;;;3013                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;3014   #else
;;;3015           /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
;;;3016           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3017                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1Q,
;;;3018                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3019                      (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos));
;;;3020   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;3021         }
;;;3022         else
;;;3023         {
;;;3024           assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
;;;3025   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3026           /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
;;;3027           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3028                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1R | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;3029                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3030                      (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos) |
;;;3031                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;3032   #else
;;;3033           /* Configure the PLLSAI1 Division factor R and Multiplication factor N*/
;;;3034           MODIFY_REG(RCC->PLLSAI1CFGR,
00009c  7d28              LDRB     r0,[r5,#0x14]
00009e  f04f417e          MOV      r1,#0xfe000000
0000a2  0840              LSRS     r0,r0,#1
0000a4  eb016040          ADD      r0,r1,r0,LSL #25
0000a8  68a9              LDR      r1,[r5,#8]
0000aa  ea402001          ORR      r0,r0,r1,LSL #8
0000ae  6931              LDR      r1,[r6,#0x10]
0000b0  4a1a              LDR      r2,|L20.284|
                  |L20.178|
0000b2  4011              ANDS     r1,r1,r2              ;3016
0000b4  4308              ORRS     r0,r0,r1              ;3016
0000b6  6130              STR      r0,[r6,#0x10]         ;3016
;;;3035                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1R,
;;;3036                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3037                      (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
;;;3038   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;3039         }
;;;3040   
;;;3041         /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
;;;3042         __HAL_RCC_PLLSAI1_ENABLE();
0000b8  6830              LDR      r0,[r6,#0]
0000ba  f0406080          ORR      r0,r0,#0x4000000
0000be  6030              STR      r0,[r6,#0]
;;;3043   
;;;3044         /* Get Start Tick*/
;;;3045         tickstart = HAL_GetTick();
0000c0  f7fffffe          BL       HAL_GetTick
0000c4  4607              MOV      r7,r0
;;;3046   
;;;3047         /* Wait till PLLSAI1 is ready */
;;;3048         while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
0000c6  e01b              B        |L20.256|
                  |L20.200|
0000c8  68a8              LDR      r0,[r5,#8]            ;2996
0000ca  68e9              LDR      r1,[r5,#0xc]          ;2996
0000cc  0200              LSLS     r0,r0,#8              ;2996
0000ce  0909              LSRS     r1,r1,#4              ;2996
0000d0  ea404041          ORR      r0,r0,r1,LSL #17      ;2996
0000d4  6931              LDR      r1,[r6,#0x10]         ;2996
0000d6  4a12              LDR      r2,|L20.288|
0000d8  e7eb              B        |L20.178|
                  |L20.218|
0000da  8a28              LDRH     r0,[r5,#0x10]         ;3016
0000dc  4911              LDR      r1,|L20.292|
0000de  0840              LSRS     r0,r0,#1              ;3016
0000e0  eb015040          ADD      r0,r1,r0,LSL #21      ;3016
0000e4  68a9              LDR      r1,[r5,#8]            ;3016
0000e6  ea402001          ORR      r0,r0,r1,LSL #8       ;3016
0000ea  6931              LDR      r1,[r6,#0x10]         ;3016
0000ec  4a0e              LDR      r2,|L20.296|
0000ee  e7e0              B        |L20.178|
                  |L20.240|
0000f0  e00e              B        |L20.272|
                  |L20.242|
;;;3049         {
;;;3050           if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
0000f2  f7fffffe          BL       HAL_GetTick
0000f6  1bc0              SUBS     r0,r0,r7
0000f8  2802              CMP      r0,#2
0000fa  d901              BLS      |L20.256|
                  |L20.252|
;;;3051           {
;;;3052             status = HAL_TIMEOUT;
0000fc  2403              MOVS     r4,#3
;;;3053             break;
0000fe  e007              B        |L20.272|
                  |L20.256|
000100  6830              LDR      r0,[r6,#0]            ;3048
000102  0100              LSLS     r0,r0,#4              ;3048
000104  d5f5              BPL      |L20.242|
;;;3054           }
;;;3055         }
;;;3056   
;;;3057         if(status == HAL_OK)
000106  b91c              CBNZ     r4,|L20.272|
;;;3058         {
;;;3059           /* Configure the PLLSAI1 Clock output(s) */
;;;3060           __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
000108  6930              LDR      r0,[r6,#0x10]
00010a  69a9              LDR      r1,[r5,#0x18]
00010c  4308              ORRS     r0,r0,r1
00010e  6130              STR      r0,[r6,#0x10]
                  |L20.272|
;;;3061         }
;;;3062       }
;;;3063     }
;;;3064   
;;;3065     return status;
000110  4620              MOV      r0,r4
;;;3066   }
000112  e8bd81f0          POP      {r4-r8,pc}
;;;3067   
                          ENDP

000116  0000              DCW      0x0000
                  |L20.280|
                          DCD      0x40021000
                  |L20.284|
                          DCD      0xf9ff80ff
                  |L20.288|
                          DCD      0xfffd80ff
                  |L20.292|
                          DCD      0xffe00000
                  |L20.296|
                          DCD      0xff9f80ff

                          AREA ||i.RCCEx_PLLSAI2_Config||, CODE, READONLY, ALIGN=2

                  RCCEx_PLLSAI2_Config PROC
;;;3081     */
;;;3082   static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3083   {
;;;3084     uint32_t tickstart;
;;;3085     HAL_StatusTypeDef status = HAL_OK;
;;;3086   
;;;3087     /* check for PLLSAI2 Parameters used to output PLLSAI2CLK */
;;;3088     /* P, Q and R dividers are verified in each specific divider case below */
;;;3089     assert_param(IS_RCC_PLLSAI2SOURCE(PllSai2->PLLSAI2Source));
;;;3090     assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
;;;3091     assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
;;;3092     assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));
;;;3093   
;;;3094     /* Check that PLLSAI2 clock source and divider M can be applied */
;;;3095     if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
000004  4e3e              LDR      r6,|L21.256|
000006  4605              MOV      r5,r0                 ;3083
000008  4688              MOV      r8,r1                 ;3083
00000a  68f0              LDR      r0,[r6,#0xc]
00000c  2400              MOVS     r4,#0                 ;3085
00000e  0781              LSLS     r1,r0,#30
000010  6828              LDR      r0,[r5,#0]            ;3083
000012  d00e              BEQ      |L21.50|
;;;3096     {
;;;3097       /* PLL clock source and divider M already set, check that no request for change  */
;;;3098       if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
000014  68f1              LDR      r1,[r6,#0xc]
000016  f0010103          AND      r1,r1,#3
00001a  4281              CMP      r1,r0
00001c  d107              BNE      |L21.46|
;;;3099          ||
;;;3100          (PllSai2->PLLSAI2Source == RCC_PLLSOURCE_NONE)
00001e  b130              CBZ      r0,|L21.46|
;;;3101   #if !defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3102          ||
;;;3103          (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
000020  68f0              LDR      r0,[r6,#0xc]
000022  6869              LDR      r1,[r5,#4]
000024  f3c01002          UBFX     r0,r0,#4,#3
000028  1c40              ADDS     r0,r0,#1
00002a  4288              CMP      r0,r1
00002c  d01f              BEQ      |L21.110|
                  |L21.46|
;;;3104   #endif
;;;3105         )
;;;3106       {
;;;3107         status = HAL_ERROR;
00002e  2401              MOVS     r4,#1
000030  e062              B        |L21.248|
                  |L21.50|
;;;3108       }
;;;3109     }
;;;3110     else
;;;3111     {
;;;3112       /* Check PLLSAI2 clock source availability */
;;;3113       switch(PllSai2->PLLSAI2Source)
000032  2801              CMP      r0,#1
000034  d009              BEQ      |L21.74|
000036  2802              CMP      r0,#2
000038  d00a              BEQ      |L21.80|
00003a  2803              CMP      r0,#3
00003c  d1f7              BNE      |L21.46|
;;;3114       {
;;;3115       case RCC_PLLSOURCE_MSI:
;;;3116         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
;;;3117         {
;;;3118           status = HAL_ERROR;
;;;3119         }
;;;3120         break;
;;;3121       case RCC_PLLSOURCE_HSI:
;;;3122         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
;;;3123         {
;;;3124           status = HAL_ERROR;
;;;3125         }
;;;3126         break;
;;;3127       case RCC_PLLSOURCE_HSE:
;;;3128         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
00003e  6831              LDR      r1,[r6,#0]
000040  0389              LSLS     r1,r1,#14
000042  d409              BMI      |L21.88|
;;;3129         {
;;;3130           if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
000044  6831              LDR      r1,[r6,#0]
000046  0349              LSLS     r1,r1,#13
000048  e004              B        |L21.84|
                  |L21.74|
00004a  6831              LDR      r1,[r6,#0]            ;3116
00004c  0789              LSLS     r1,r1,#30             ;3116
00004e  e001              B        |L21.84|
                  |L21.80|
000050  6831              LDR      r1,[r6,#0]            ;3122
000052  0549              LSLS     r1,r1,#21             ;3122
                  |L21.84|
000054  2900              CMP      r1,#0                 ;3116
000056  daea              BGE      |L21.46|
                  |L21.88|
;;;3131           {
;;;3132             status = HAL_ERROR;
;;;3133           }
;;;3134         }
;;;3135         break;
;;;3136       default:
;;;3137         status = HAL_ERROR;
;;;3138         break;
;;;3139       }
;;;3140   
;;;3141       if(status == HAL_OK)
;;;3142       {
;;;3143   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3144         /* Set PLLSAI2 clock source */
;;;3145         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
;;;3146   #else
;;;3147         /* Set PLLSAI2 clock source and divider M */
;;;3148         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
000058  68f1              LDR      r1,[r6,#0xc]
00005a  686a              LDR      r2,[r5,#4]
00005c  f06f030f          MVN      r3,#0xf
000060  f0210173          BIC      r1,r1,#0x73
000064  eb031202          ADD      r2,r3,r2,LSL #4
000068  4311              ORRS     r1,r1,r2
00006a  4301              ORRS     r1,r1,r0
00006c  60f1              STR      r1,[r6,#0xc]
                  |L21.110|
;;;3149   #endif
;;;3150       }
;;;3151     }
;;;3152   
;;;3153     if(status == HAL_OK)
;;;3154     {
;;;3155       /* Disable the PLLSAI2 */
;;;3156       __HAL_RCC_PLLSAI2_DISABLE();
00006e  6830              LDR      r0,[r6,#0]
000070  f0205080          BIC      r0,r0,#0x10000000
000074  6030              STR      r0,[r6,#0]
;;;3157   
;;;3158       /* Get Start Tick*/
;;;3159       tickstart = HAL_GetTick();
000076  f7fffffe          BL       HAL_GetTick
00007a  4607              MOV      r7,r0
;;;3160   
;;;3161       /* Wait till PLLSAI2 is ready to be updated */
;;;3162       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
00007c  e004              B        |L21.136|
                  |L21.126|
;;;3163       {
;;;3164         if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
00007e  f7fffffe          BL       HAL_GetTick
000082  1bc0              SUBS     r0,r0,r7
000084  2802              CMP      r0,#2
000086  d82d              BHI      |L21.228|
                  |L21.136|
000088  6830              LDR      r0,[r6,#0]            ;3162
00008a  0080              LSLS     r0,r0,#2              ;3162
00008c  d4f7              BMI      |L21.126|
;;;3165         {
;;;3166           status = HAL_TIMEOUT;
;;;3167           break;
;;;3168         }
;;;3169       }
;;;3170   
;;;3171       if(status == HAL_OK)
00008e  bb54              CBNZ     r4,|L21.230|
;;;3172       {
;;;3173         if(Divider == DIVIDER_P_UPDATE)
000090  f1b80f00          CMP      r8,#0
000094  d015              BEQ      |L21.194|
;;;3174         {
;;;3175           assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
;;;3176   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3177   
;;;3178           /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
;;;3179   #if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
;;;3180           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3181                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3182                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3183                      (PllSai2->PLLSAI2P << RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos) |
;;;3184                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3185   #else
;;;3186           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3187                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2P | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3188                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3189                      ((PllSai2->PLLSAI2P >> 4U) << RCC_PLLSAI2CFGR_PLLSAI2P_Pos) |
;;;3190                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3191   #endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
;;;3192   
;;;3193   #else
;;;3194           /* Configure the PLLSAI2 Division factor P and Multiplication factor N*/
;;;3195   #if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
;;;3196           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3197                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV,
;;;3198                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3199                      (PllSai2->PLLSAI2P << RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos));
;;;3200   #else
;;;3201           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3202                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2P,
;;;3203                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3204                      ((PllSai2->PLLSAI2P >> 4U) << RCC_PLLSAI2CFGR_PLLSAI2P_Pos));
;;;3205   #endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
;;;3206   
;;;3207   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;3208         }
;;;3209   #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;3210         else if(Divider == DIVIDER_Q_UPDATE)
;;;3211         {
;;;3212           assert_param(IS_RCC_PLLSAI2Q_VALUE(PllSai2->PLLSAI2Q));
;;;3213   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3214           /* Configure the PLLSAI2 Division factor M, Q and Multiplication factor N*/
;;;3215           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3216                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2Q | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3217                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3218                      (((PllSai2->PLLSAI2Q >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) |
;;;3219                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3220   #else
;;;3221           /* Configure the PLLSAI2 Division factor Q and Multiplication factor N*/
;;;3222           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3223                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2Q,
;;;3224                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3225                      (((PllSai2->PLLSAI2Q >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2Q_Pos));
;;;3226   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;3227         }
;;;3228   #endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
;;;3229         else
;;;3230         {
;;;3231           assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
;;;3232   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3233           /* Configure the PLLSAI2 Division factor M, R and Multiplication factor N*/
;;;3234           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3235                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2R | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3236                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3237                      (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos) |
;;;3238                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3239   #else
;;;3240           /* Configure the PLLSAI2 Division factor R and Multiplication factor N*/
;;;3241           MODIFY_REG(RCC->PLLSAI2CFGR,
000096  7c28              LDRB     r0,[r5,#0x10]
000098  f04f417e          MOV      r1,#0xfe000000
00009c  0840              LSRS     r0,r0,#1
00009e  eb016040          ADD      r0,r1,r0,LSL #25
0000a2  68a9              LDR      r1,[r5,#8]
0000a4  ea402101          ORR      r1,r0,r1,LSL #8
0000a8  6970              LDR      r0,[r6,#0x14]
0000aa  4a16              LDR      r2,|L21.260|
0000ac  4010              ANDS     r0,r0,r2
0000ae  4301              ORRS     r1,r1,r0
0000b0  6171              STR      r1,[r6,#0x14]
                  |L21.178|
;;;3242                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2R,
;;;3243                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3244                      (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
;;;3245   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;3246         }
;;;3247   
;;;3248         /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
;;;3249         __HAL_RCC_PLLSAI2_ENABLE();
0000b2  6830              LDR      r0,[r6,#0]
0000b4  f0405080          ORR      r0,r0,#0x10000000
0000b8  6030              STR      r0,[r6,#0]
;;;3250   
;;;3251         /* Get Start Tick*/
;;;3252         tickstart = HAL_GetTick();
0000ba  f7fffffe          BL       HAL_GetTick
0000be  4607              MOV      r7,r0
;;;3253   
;;;3254         /* Wait till PLLSAI2 is ready */
;;;3255         while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
0000c0  e012              B        |L21.232|
                  |L21.194|
0000c2  68a8              LDR      r0,[r5,#8]            ;3201
0000c4  68e9              LDR      r1,[r5,#0xc]          ;3201
0000c6  0200              LSLS     r0,r0,#8              ;3201
0000c8  0909              LSRS     r1,r1,#4              ;3201
0000ca  ea404041          ORR      r0,r0,r1,LSL #17      ;3201
0000ce  6971              LDR      r1,[r6,#0x14]         ;3201
0000d0  4a0d              LDR      r2,|L21.264|
0000d2  4011              ANDS     r1,r1,r2              ;3201
0000d4  4308              ORRS     r0,r0,r1              ;3201
0000d6  6170              STR      r0,[r6,#0x14]         ;3201
0000d8  e7eb              B        |L21.178|
                  |L21.218|
;;;3256         {
;;;3257           if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
0000da  f7fffffe          BL       HAL_GetTick
0000de  1bc0              SUBS     r0,r0,r7
0000e0  2802              CMP      r0,#2
0000e2  d901              BLS      |L21.232|
                  |L21.228|
;;;3258           {
;;;3259             status = HAL_TIMEOUT;
0000e4  2403              MOVS     r4,#3
                  |L21.230|
;;;3260             break;
0000e6  e007              B        |L21.248|
                  |L21.232|
0000e8  6830              LDR      r0,[r6,#0]            ;3255
0000ea  0080              LSLS     r0,r0,#2              ;3255
0000ec  d5f5              BPL      |L21.218|
;;;3261           }
;;;3262         }
;;;3263   
;;;3264         if(status == HAL_OK)
0000ee  b91c              CBNZ     r4,|L21.248|
;;;3265         {
;;;3266           /* Configure the PLLSAI2 Clock output(s) */
;;;3267           __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
0000f0  6970              LDR      r0,[r6,#0x14]
0000f2  6969              LDR      r1,[r5,#0x14]
0000f4  4308              ORRS     r0,r0,r1
0000f6  6170              STR      r0,[r6,#0x14]
                  |L21.248|
;;;3268         }
;;;3269       }
;;;3270     }
;;;3271   
;;;3272     return status;
0000f8  4620              MOV      r0,r4
;;;3273   }
0000fa  e8bd81f0          POP      {r4-r8,pc}
;;;3274   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L21.256|
                          DCD      0x40021000
                  |L21.260|
                          DCD      0xf9ff80ff
                  |L21.264|
                          DCD      0xfffd80ff

;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
