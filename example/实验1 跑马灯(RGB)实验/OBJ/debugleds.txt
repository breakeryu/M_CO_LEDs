; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\debugleds.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\debugleds.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\debugleds.crf ..\App\src\debugLEDs.c]
                          THUMB

                          AREA ||i.debugLEDsSEM_GetOutput||, CODE, READONLY, ALIGN=2

                  debugLEDsSEM_GetOutput PROC
;;;175    
;;;176    static VSResult debugLEDsSEM_GetOutput (void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;177    {
;;;178    #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
;;;179      uint_fast8_t iFirstR;
;;;180      uint_fast8_t iLastR;
;;;181    #else
;;;182      SEM_RULE_TABLE_INDEX_TYPE iFirstR;
;;;183      SEM_RULE_TABLE_INDEX_TYPE iLastR;
;;;184    #endif
;;;185      for(;;)
;;;186      {
;;;187        switch (SEM.State)
000004  492b              LDR      r1,|L1.180|
000006  7808              LDRB     r0,[r1,#0]  ; SEMdebugLEDs
000008  2802              CMP      r0,#2
00000a  d004              BEQ      |L1.22|
00000c  2803              CMP      r0,#3
00000e  d04e              BEQ      |L1.174|
;;;188        {
;;;189        case STATE_SEM_PREPARE:
;;;190          iFirstR = VS.RuleTableIndex[SEM.EventNo];
;;;191          iLastR = VS.RuleTableIndex[SEM.EventNo + 1U];
;;;192          while (iFirstR < iLastR)
;;;193          {
;;;194    #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
;;;195            uint_fast8_t i;
;;;196            uint_fast8_t nNo;
;;;197            uint_fast8_t nPos;
;;;198            uint_fast8_t nNxt;
;;;199            uint_fast8_t iRI;
;;;200            uint_fast8_t nAction;
;;;201    #else
;;;202            SEM_INTERNAL_TYPE i;
;;;203            uint8_t nNo;
;;;204            uint8_t nPos;
;;;205            uint8_t nNxt;
;;;206            SEM_RULE_INDEX_TYPE iRI;
;;;207            uint8_t nAction;
;;;208    #endif
;;;209    
;;;210            iRI = VS.RuleIndex[iFirstR];
;;;211            ++iFirstR;
;;;212            i = VS.RuleData[iRI];
;;;213            ++iRI;
;;;214            nNxt = (unsigned char)(i & 0x0FU);
;;;215            nAction = (unsigned char)(i >> 4U);
;;;216            i = VS.RuleData[iRI];
;;;217            ++iRI;
;;;218            nPos = (unsigned char)(i & 0x0FU);
;;;219    
;;;220            for (nNo = 0U; nNo < nPos; ++nNo)
;;;221            {
;;;222              SEM_STATE_TYPE sa;
;;;223              sa = (SEM_STATE_TYPE)(VS.RuleData[iRI]);
;;;224              if (sa != SEM.CSV[VS.StateMachineIndex[sa]])
;;;225              {
;;;226                goto NextRule;
;;;227              }
;;;228              else
;;;229              {
;;;230                ++iRI;
;;;231              }
;;;232            }
;;;233    
;;;234    
;;;235            for (nNo = 0U; nNo < nNxt; ++nNo)
;;;236            {
;;;237              SEM_STATE_TYPE sa;
;;;238              sa = (SEM_STATE_TYPE)(VS.RuleData[iRI]);
;;;239              ++iRI;
;;;240              i = VS.StateMachineIndex[sa];
;;;241              if (SEM.WSV[i] == STATE_UNDEFINED)
;;;242              {
;;;243                SEM.WSV[i] = sa;
;;;244              }
;;;245              else if (SEM.WSV[i] != sa)
;;;246              {
;;;247                return (SES_CONTRADICTION);
;;;248              }
;;;249            }
;;;250            while (nAction != 0U)
;;;251            {
;;;252              SEM_ACTION_EXPRESSION_TYPE actionNo;
;;;253              actionNo = (SEM_ACTION_EXPRESSION_TYPE)(VS.RuleData[iRI]);
;;;254              ++iRI;
;;;255              nAction--;
;;;256              (*debugLEDsVSAction[actionNo])();
;;;257            }
;;;258    NextRule:
;;;259            ;
;;;260          }
;;;261          SEMdebugLEDs.State = STATE_SEM_OKAY;
;;;262          return (SES_OKAY);
;;;263    
;;;264        case STATE_SEM_OKAY:
;;;265          return (SES_OKAY);
;;;266    
;;;267        default:
;;;268          return (SES_EMPTY);
000010  2007              MOVS     r0,#7
                  |L1.18|
;;;269        }
;;;270      }
;;;271    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L1.22|
000016  468a              MOV      r10,r1                ;190
000018  7848              LDRB     r0,[r1,#1]            ;190  ; SEMdebugLEDs
00001a  4927              LDR      r1,|L1.184|
00001c  5c46              LDRB     r6,[r0,r1]            ;190
00001e  1c49              ADDS     r1,r1,#1              ;191
000020  f1a10712          SUB      r7,r1,#0x12           ;190
000024  f8109001          LDRB     r9,[r0,r1]            ;191
000028  e03c              B        |L1.164|
                  |L1.42|
00002a  19b8              ADDS     r0,r7,r6              ;210
00002c  4b21              LDR      r3,|L1.180|
00002e  7b84              LDRB     r4,[r0,#0xe]          ;210
000030  1c9b              ADDS     r3,r3,#2              ;187
000032  1938              ADDS     r0,r7,r4              ;212
000034  1c64              ADDS     r4,r4,#1              ;215
000036  7880              LDRB     r0,[r0,#2]            ;212
000038  f0000c0f          AND      r12,r0,#0xf           ;214
00003c  0905              LSRS     r5,r0,#4              ;215
00003e  1938              ADDS     r0,r7,r4              ;216
000040  1c64              ADDS     r4,r4,#1              ;187
000042  7880              LDRB     r0,[r0,#2]            ;216
000044  f000080f          AND      r8,r0,#0xf            ;218
000048  2000              MOVS     r0,#0                 ;220
00004a  1c76              ADDS     r6,r6,#1              ;187
00004c  e007              B        |L1.94|
                  |L1.78|
00004e  1939              ADDS     r1,r7,r4              ;223
000050  7889              LDRB     r1,[r1,#2]            ;223
000052  5c7a              LDRB     r2,[r7,r1]            ;224
000054  5cd2              LDRB     r2,[r2,r3]            ;224
000056  428a              CMP      r2,r1                 ;224
000058  d124              BNE      |L1.164|
00005a  1c40              ADDS     r0,r0,#1              ;224
00005c  1c64              ADDS     r4,r4,#1              ;224
                  |L1.94|
00005e  4540              CMP      r0,r8                 ;220
000060  d3f5              BCC      |L1.78|
000062  2100              MOVS     r1,#0                 ;235
000064  46d0              MOV      r8,r10                ;187
000066  e00e              B        |L1.134|
                  |L1.104|
000068  1938              ADDS     r0,r7,r4              ;238
00006a  1c64              ADDS     r4,r4,#1              ;241
00006c  7880              LDRB     r0,[r0,#2]            ;238
00006e  5c3a              LDRB     r2,[r7,r0]            ;240
000070  eb080302          ADD      r3,r8,r2              ;241
000074  78da              LDRB     r2,[r3,#3]            ;241
000076  2aff              CMP      r2,#0xff              ;241
000078  d003              BEQ      |L1.130|
00007a  4282              CMP      r2,r0                 ;245
00007c  d002              BEQ      |L1.132|
00007e  2003              MOVS     r0,#3                 ;247
000080  e7c7              B        |L1.18|
                  |L1.130|
000082  70d8              STRB     r0,[r3,#3]            ;243
                  |L1.132|
000084  1c49              ADDS     r1,r1,#1              ;243
                  |L1.134|
000086  4561              CMP      r1,r12                ;235
000088  d3ee              BCC      |L1.104|
00008a  f8df802c          LDR      r8,|L1.184|
00008e  f1a80815          SUB      r8,r8,#0x15           ;256
                  |L1.146|
000092  b13d              CBZ      r5,|L1.164|
000094  1938              ADDS     r0,r7,r4              ;253
000096  1c64              ADDS     r4,r4,#1              ;256
000098  7880              LDRB     r0,[r0,#2]            ;253
00009a  1e6d              SUBS     r5,r5,#1              ;256
00009c  f8580020          LDR      r0,[r8,r0,LSL #2]     ;256
0000a0  4780              BLX      r0                    ;256
0000a2  e7f6              B        |L1.146|
                  |L1.164|
0000a4  454e              CMP      r6,r9                 ;192
0000a6  d3c0              BCC      |L1.42|
0000a8  2103              MOVS     r1,#3                 ;261
0000aa  f88a1000          STRB     r1,[r10,#0]           ;261
                  |L1.174|
0000ae  2000              MOVS     r0,#0                 ;265
0000b0  e7af              B        |L1.18|
;;;272    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L1.180|
                          DCD      ||.data||
                  |L1.184|
                          DCD      ||.constdata||+0x15

                          AREA ||i.debugLEDsSEM_Init||, CODE, READONLY, ALIGN=2

                  debugLEDsSEM_Init PROC
;;;124    
;;;125    void debugLEDsSEM_Init (void)
000000  2000              MOVS     r0,#0
;;;126    {
;;;127      {
;;;128        SEM_STATE_MACHINE_TYPE i;
;;;129        for (i = 0U; i < 1U; ++i)
;;;130        {
;;;131          SEM.WSV[i] = STATE_UNDEFINED;
000002  4b06              LDR      r3,|L2.28|
000004  22ff              MOVS     r2,#0xff
                  |L2.6|
000006  1819              ADDS     r1,r3,r0
;;;132          SEM.CSV[i] = STATE_UNDEFINED;
000008  1c40              ADDS     r0,r0,#1
00000a  70ca              STRB     r2,[r1,#3]            ;131
00000c  708a              STRB     r2,[r1,#2]
00000e  f01000ff          ANDS     r0,r0,#0xff           ;129
000012  d0f8              BEQ      |L2.6|
;;;133        }
;;;134      }
;;;135      SEM.State = STATE_SEM_INITIALIZED;
000014  2001              MOVS     r0,#1
000016  7018              STRB     r0,[r3,#0]
;;;136    }
000018  4770              BX       lr
;;;137    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.debugLEDsSEM_State||, CODE, READONLY, ALIGN=2

                  debugLEDsSEM_State PROC
;;;299    
;;;300    VSResult debugLEDsSEM_State (SEM_STATE_MACHINE_TYPE StateMachineNo,
000000  b108              CBZ      r0,|L3.6|
;;;301      SEM_STATE_TYPE *StateNo)
;;;302    {
;;;303      if (1U <= StateMachineNo)
;;;304      {
;;;305        return (SES_RANGE_ERR);
000002  2004              MOVS     r0,#4
;;;306      }
;;;307      *StateNo = SEM.CSV[StateMachineNo];
;;;308      return (SES_FOUND);
;;;309    }
000004  4770              BX       lr
                  |L3.6|
000006  4802              LDR      r0,|L3.16|
000008  7880              LDRB     r0,[r0,#2]            ;307
00000a  7008              STRB     r0,[r1,#0]            ;307
00000c  2001              MOVS     r0,#1                 ;308
00000e  4770              BX       lr
                          ENDP

                  |L3.16|
                          DCD      ||.data||

                          AREA ||i.debugLEDsVSDeduct||, CODE, READONLY, ALIGN=2

                  debugLEDsVSDeduct PROC
;;;152    
;;;153    VSResult debugLEDsVSDeduct (SEM_EVENT_TYPE EventNo)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
;;;155      VSResult cc;
;;;156      if (SEM.State == STATE_SEM_NOT_INITIALIZED)
000002  4c0f              LDR      r4,|L4.64|
000004  7821              LDRB     r1,[r4,#0]  ; SEMdebugLEDs
000006  b119              CBZ      r1,|L4.16|
;;;157      {
;;;158        return (SES_NOT_INITIALIZED);
;;;159      }
;;;160      if (3U <= EventNo)
000008  2803              CMP      r0,#3
00000a  d303              BCC      |L4.20|
;;;161      {
;;;162        return (SES_RANGE_ERR);
00000c  2004              MOVS     r0,#4
;;;163      }
;;;164      SEM.EventNo = EventNo;
;;;165      SEM.State = STATE_SEM_PREPARE;
;;;166      cc = debugLEDsSEM_GetOutput();
;;;167      if (cc == SES_OKAY)
;;;168      {
;;;169        debugLEDsDeductChangeState();
;;;170        SEMdebugLEDs.State = STATE_SEM_INITIALIZED;
;;;171      }
;;;172      return cc;
;;;173    }
00000e  bd70              POP      {r4-r6,pc}
                  |L4.16|
000010  200a              MOVS     r0,#0xa               ;158
                  |L4.18|
000012  bd70              POP      {r4-r6,pc}
                  |L4.20|
000014  7060              STRB     r0,[r4,#1]            ;164
000016  2002              MOVS     r0,#2                 ;165
000018  7020              STRB     r0,[r4,#0]            ;165
00001a  f7fffffe          BL       debugLEDsSEM_GetOutput
00001e  2800              CMP      r0,#0                 ;167
000020  d1f7              BNE      |L4.18|
000022  2100              MOVS     r1,#0                 ;167
000024  25ff              MOVS     r5,#0xff              ;167
                  |L4.38|
000026  1862              ADDS     r2,r4,r1              ;167
000028  78d3              LDRB     r3,[r2,#3]            ;167
00002a  2bff              CMP      r3,#0xff              ;167
00002c  d001              BEQ      |L4.50|
00002e  7093              STRB     r3,[r2,#2]            ;167
000030  70d5              STRB     r5,[r2,#3]            ;167
                  |L4.50|
000032  1c49              ADDS     r1,r1,#1              ;167
000034  f01101ff          ANDS     r1,r1,#0xff           ;167
000038  d0f5              BEQ      |L4.38|
00003a  2101              MOVS     r1,#1                 ;170
00003c  7021              STRB     r1,[r4,#0]            ;170
00003e  bd70              POP      {r4-r6,pc}
;;;174    
                          ENDP

                  |L4.64|
                          DCD      ||.data||

                          AREA ||i.debugLEDsVSElementExpl||, CODE, READONLY, ALIGN=1

                  debugLEDsVSElementExpl PROC
;;;286    
;;;287    VSResult debugLEDsVSElementExpl (IdentifierType IdentType, SEM_EXPLANATION_TYPE IdentNo, char const * * Text)
000000  2006              MOVS     r0,#6
;;;288    {
;;;289      VSResult ret = SES_OKAY;
;;;290      switch (IdentType)
;;;291      {
;;;292      default:
;;;293        ret = SES_TYPE_ERR;
;;;294        break;
;;;295      }
;;;296      return ret;
;;;297    }
000002  4770              BX       lr
;;;298    
                          ENDP


                          AREA ||i.debugLEDsVSElementName||, CODE, READONLY, ALIGN=1

                  debugLEDsVSElementName PROC
;;;273    
;;;274    VSResult debugLEDsVSElementName (IdentifierType IdentType, SEM_EXPLANATION_TYPE IdentNo, char const * * Text)
000000  2006              MOVS     r0,#6
;;;275    {
;;;276      VSResult ret = SES_OKAY;
;;;277      switch (IdentType)
;;;278      {
;;;279      default:
;;;280        ret = SES_TYPE_ERR;
;;;281        break;
;;;282      }
;;;283      return ret;
;;;284    }
000002  4770              BX       lr
;;;285    
                          ENDP


                          AREA ||i.debugLEDsVSInitAll||, CODE, READONLY, ALIGN=1

                  debugLEDsVSInitAll PROC
;;;118    
;;;119    void debugLEDsVSInitAll (void)
000000  f7ffbffe          B.W      debugLEDsSEM_Init
;;;120    {
;;;121      debugLEDsSEM_Init();
;;;122    }
;;;123    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  debugLEDsVSAction
                          DCD      aLedsRun
                  debugLEDs
000004  00000100          DCB      0x00,0x00,0x01,0x00
000008  00010100          DCB      0x00,0x01,0x01,0x00
00000c  01110101          DCB      0x01,0x11,0x01,0x01
000010  01000003          DCB      0x01,0x00,0x00,0x03
000014  07000102          DCB      0x07,0x00,0x01,0x02
000018  03                DCB      0x03

                          AREA ||.data||, DATA, ALIGN=0

                  SEMdebugLEDs
                          DCDU     0x00000000
