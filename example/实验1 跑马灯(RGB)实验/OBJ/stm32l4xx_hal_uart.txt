; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal_uart.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal_uart.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2650     */
;;;2651   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;2652   {
;;;2653     /* Process Locked */
;;;2654     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d016              BEQ      |L1.54|
000008  2101              MOVS     r1,#1
00000a  f8001f70          STRB     r1,[r0,#0x70]!
;;;2655     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2656   
;;;2657     /* Clear TE and RE bits */
;;;2658     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
000012  f8501c70          LDR      r1,[r0,#-0x70]
000016  680a              LDR      r2,[r1,#0]
000018  f022020c          BIC      r2,r2,#0xc
00001c  600a              STR      r2,[r1,#0]
;;;2659   
;;;2660     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2661     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
00001e  f8501c70          LDR      r1,[r0,#-0x70]
000022  680a              LDR      r2,[r1,#0]
000024  f0420204          ORR      r2,r2,#4
000028  600a              STR      r2,[r1,#0]
;;;2662   
;;;2663     huart->gState = HAL_UART_STATE_READY;
00002a  2120              MOVS     r1,#0x20
00002c  7041              STRB     r1,[r0,#1]
;;;2664   
;;;2665     /* Process Unlocked */
;;;2666     __HAL_UNLOCK(huart);
00002e  2100              MOVS     r1,#0
000030  7001              STRB     r1,[r0,#0]
;;;2667   
;;;2668     return HAL_OK;
000032  4608              MOV      r0,r1
;;;2669   }
000034  4770              BX       lr
                  |L1.54|
000036  2002              MOVS     r0,#2                 ;2654
000038  4770              BX       lr
;;;2670   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2625     */
;;;2626   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;2627   {
;;;2628     /* Process Locked */
;;;2629     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d016              BEQ      |L2.54|
000008  2101              MOVS     r1,#1
00000a  f8001f70          STRB     r1,[r0,#0x70]!
;;;2630     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2631   
;;;2632     /* Clear TE and RE bits */
;;;2633     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
000012  f8501c70          LDR      r1,[r0,#-0x70]
000016  680a              LDR      r2,[r1,#0]
000018  f022020c          BIC      r2,r2,#0xc
00001c  600a              STR      r2,[r1,#0]
;;;2634   
;;;2635     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2636     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
00001e  f8501c70          LDR      r1,[r0,#-0x70]
000022  680a              LDR      r2,[r1,#0]
000024  f0420208          ORR      r2,r2,#8
000028  600a              STR      r2,[r1,#0]
;;;2637   
;;;2638     huart->gState = HAL_UART_STATE_READY;
00002a  2120              MOVS     r1,#0x20
00002c  7041              STRB     r1,[r0,#1]
;;;2639   
;;;2640     /* Process Unlocked */
;;;2641     __HAL_UNLOCK(huart);
00002e  2100              MOVS     r1,#0
000030  7001              STRB     r1,[r0,#0]
;;;2642   
;;;2643     return HAL_OK;
000032  4608              MOV      r0,r1
;;;2644   }
000034  4770              BX       lr
                  |L2.54|
000036  2002              MOVS     r0,#2                 ;2629
000038  4770              BX       lr
;;;2645   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;403    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L3.14|
;;;404      /* Check the UART handle allocation */
;;;405      if (huart == NULL)
;;;406      {
;;;407        return HAL_ERROR;
;;;408      }
;;;409    
;;;410      /* Check UART instance */
;;;411      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;412    
;;;413      if (huart->gState == HAL_UART_STATE_RESET)
000006  f8940071          LDRB     r0,[r4,#0x71]
00000a  b110              CBZ      r0,|L3.18|
00000c  e007              B        |L3.30|
                  |L3.14|
00000e  2001              MOVS     r0,#1                 ;407
                  |L3.16|
;;;414      {
;;;415        /* Allocate lock resource and initialize it */
;;;416        huart->Lock = HAL_UNLOCKED;
;;;417    
;;;418    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;419        UART_InitCallbacksToDefault(huart);
;;;420    
;;;421        if (huart->MspInitCallback == NULL)
;;;422        {
;;;423          huart->MspInitCallback = HAL_UART_MspInit;
;;;424        }
;;;425    
;;;426        /* Init the low level hardware */
;;;427        huart->MspInitCallback(huart);
;;;428    #else
;;;429        /* Init the low level hardware : GPIO, CLOCK */
;;;430        HAL_UART_MspInit(huart);
;;;431    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;432      }
;;;433    
;;;434      huart->gState = HAL_UART_STATE_BUSY;
;;;435    
;;;436      /* Disable the Peripheral */
;;;437      __HAL_UART_DISABLE(huart);
;;;438    
;;;439      /* Set the UART Communication parameters */
;;;440      if (UART_SetConfig(huart) == HAL_ERROR)
;;;441      {
;;;442        return HAL_ERROR;
;;;443      }
;;;444    
;;;445      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;446      {
;;;447        UART_AdvFeatureConfig(huart);
;;;448      }
;;;449    
;;;450      /* In half-duplex mode, the following bits must be kept cleared:
;;;451      - LINEN and CLKEN bits in the USART_CR2 register,
;;;452      - SCEN and IREN bits in the USART_CR3 register.*/
;;;453      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;454      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;455    
;;;456      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;457      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;458    
;;;459      /* Enable the Peripheral */
;;;460      __HAL_UART_ENABLE(huart);
;;;461    
;;;462      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;463      return (UART_CheckIdleState(huart));
;;;464    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;416
000014  f8840070          STRB     r0,[r4,#0x70]         ;416
000018  4620              MOV      r0,r4                 ;430
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L3.30|
00001e  2024              MOVS     r0,#0x24              ;434
000020  f8840071          STRB     r0,[r4,#0x71]         ;434
000024  6820              LDR      r0,[r4,#0]            ;437
000026  6801              LDR      r1,[r0,#0]            ;437
000028  f0210101          BIC      r1,r1,#1              ;437
00002c  6001              STR      r1,[r0,#0]            ;437
00002e  4620              MOV      r0,r4                 ;440
000030  f7fffffe          BL       UART_SetConfig
000034  2801              CMP      r0,#1                 ;440
000036  d0eb              BEQ      |L3.16|
000038  6a60              LDR      r0,[r4,#0x24]         ;445
00003a  b110              CBZ      r0,|L3.66|
00003c  4620              MOV      r0,r4                 ;447
00003e  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.66|
000042  6820              LDR      r0,[r4,#0]            ;453
000044  6841              LDR      r1,[r0,#4]            ;453
000046  f4214190          BIC      r1,r1,#0x4800         ;453
00004a  6041              STR      r1,[r0,#4]            ;453
00004c  6820              LDR      r0,[r4,#0]            ;454
00004e  6881              LDR      r1,[r0,#8]            ;454
000050  f0210122          BIC      r1,r1,#0x22           ;454
000054  6081              STR      r1,[r0,#8]            ;454
000056  6820              LDR      r0,[r4,#0]            ;457
000058  6881              LDR      r1,[r0,#8]            ;457
00005a  f0410108          ORR      r1,r1,#8              ;457
00005e  6081              STR      r1,[r0,#8]            ;457
000060  6820              LDR      r0,[r4,#0]            ;460
000062  6801              LDR      r1,[r0,#0]            ;460
000064  f0410101          ORR      r1,r1,#1              ;460
000068  6001              STR      r1,[r0,#0]            ;460
00006a  4620              MOV      r0,r4                 ;463
00006c  e8bd4010          POP      {r4,lr}               ;463
000070  f7ffbffe          B.W      UART_CheckIdleState
;;;465    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;476      */
;;;477    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;478    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d005              BEQ      |L4.20|
;;;479      /* Check the UART handle allocation */
;;;480      if (huart == NULL)
;;;481      {
;;;482        return HAL_ERROR;
;;;483      }
;;;484    
;;;485      /* Check the LIN UART instance */
;;;486      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;487      /* Check the Break detection length parameter */
;;;488      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;489    
;;;490      /* LIN mode limited to 16-bit oversampling only */
;;;491      if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000008  69e0              LDR      r0,[r4,#0x1c]
00000a  f5b04f00          CMP      r0,#0x8000
00000e  d001              BEQ      |L4.20|
;;;492      {
;;;493        return HAL_ERROR;
;;;494      }
;;;495      /* LIN mode limited to 8-bit data length */
;;;496      if (huart->Init.WordLength != UART_WORDLENGTH_8B)
000010  68a0              LDR      r0,[r4,#8]
000012  b108              CBZ      r0,|L4.24|
                  |L4.20|
;;;497      {
;;;498        return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L4.22|
;;;499      }
;;;500    
;;;501      if (huart->gState == HAL_UART_STATE_RESET)
;;;502      {
;;;503        /* Allocate lock resource and initialize it */
;;;504        huart->Lock = HAL_UNLOCKED;
;;;505    
;;;506    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;507        UART_InitCallbacksToDefault(huart);
;;;508    
;;;509        if (huart->MspInitCallback == NULL)
;;;510        {
;;;511          huart->MspInitCallback = HAL_UART_MspInit;
;;;512        }
;;;513    
;;;514        /* Init the low level hardware */
;;;515        huart->MspInitCallback(huart);
;;;516    #else
;;;517        /* Init the low level hardware : GPIO, CLOCK */
;;;518        HAL_UART_MspInit(huart);
;;;519    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;520      }
;;;521    
;;;522      huart->gState = HAL_UART_STATE_BUSY;
;;;523    
;;;524      /* Disable the Peripheral */
;;;525      __HAL_UART_DISABLE(huart);
;;;526    
;;;527      /* Set the UART Communication parameters */
;;;528      if (UART_SetConfig(huart) == HAL_ERROR)
;;;529      {
;;;530        return HAL_ERROR;
;;;531      }
;;;532    
;;;533      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;534      {
;;;535        UART_AdvFeatureConfig(huart);
;;;536      }
;;;537    
;;;538      /* In LIN mode, the following bits must be kept cleared:
;;;539      - LINEN and CLKEN bits in the USART_CR2 register,
;;;540      - SCEN and IREN bits in the USART_CR3 register.*/
;;;541      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;542      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;543    
;;;544      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;545      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;546    
;;;547      /* Set the USART LIN Break detection length. */
;;;548      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;549    
;;;550      /* Enable the Peripheral */
;;;551      __HAL_UART_ENABLE(huart);
;;;552    
;;;553      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;554      return (UART_CheckIdleState(huart));
;;;555    }
000016  bd70              POP      {r4-r6,pc}
                  |L4.24|
000018  f8940071          LDRB     r0,[r4,#0x71]         ;501
00001c  b928              CBNZ     r0,|L4.42|
00001e  2000              MOVS     r0,#0                 ;504
000020  f8840070          STRB     r0,[r4,#0x70]         ;504
000024  4620              MOV      r0,r4                 ;518
000026  f7fffffe          BL       HAL_UART_MspInit
                  |L4.42|
00002a  2024              MOVS     r0,#0x24              ;522
00002c  f8840071          STRB     r0,[r4,#0x71]         ;522
000030  6820              LDR      r0,[r4,#0]            ;525
000032  6801              LDR      r1,[r0,#0]            ;525
000034  f0210101          BIC      r1,r1,#1              ;525
000038  6001              STR      r1,[r0,#0]            ;525
00003a  4620              MOV      r0,r4                 ;528
00003c  f7fffffe          BL       UART_SetConfig
000040  2801              CMP      r0,#1                 ;528
000042  d0e8              BEQ      |L4.22|
000044  6a60              LDR      r0,[r4,#0x24]         ;533
000046  b110              CBZ      r0,|L4.78|
000048  4620              MOV      r0,r4                 ;535
00004a  f7fffffe          BL       UART_AdvFeatureConfig
                  |L4.78|
00004e  6820              LDR      r0,[r4,#0]            ;541
000050  6841              LDR      r1,[r0,#4]            ;541
000052  f4216100          BIC      r1,r1,#0x800          ;541
000056  6041              STR      r1,[r0,#4]            ;541
000058  6820              LDR      r0,[r4,#0]            ;542
00005a  6881              LDR      r1,[r0,#8]            ;542
00005c  f021012a          BIC      r1,r1,#0x2a           ;542
000060  6081              STR      r1,[r0,#8]            ;542
000062  6820              LDR      r0,[r4,#0]            ;545
000064  6841              LDR      r1,[r0,#4]            ;545
000066  f4414180          ORR      r1,r1,#0x4000         ;545
00006a  6041              STR      r1,[r0,#4]            ;545
00006c  6820              LDR      r0,[r4,#0]            ;548
00006e  6841              LDR      r1,[r0,#4]            ;548
000070  f0210120          BIC      r1,r1,#0x20           ;548
000074  4329              ORRS     r1,r1,r5              ;548
000076  6041              STR      r1,[r0,#4]            ;548
000078  6820              LDR      r0,[r4,#0]            ;551
00007a  6801              LDR      r1,[r0,#0]            ;551
00007c  f0410101          ORR      r1,r1,#1              ;551
000080  6001              STR      r1,[r0,#0]            ;551
000082  4620              MOV      r0,r4                 ;554
000084  e8bd4070          POP      {r4-r6,lr}            ;554
000088  f7ffbffe          B.W      UART_CheckIdleState
;;;556    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2676     */
;;;2677   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;2678   {
;;;2679     /* Check the parameters */
;;;2680     assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;2681   
;;;2682     /* Process Locked */
;;;2683     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8001f70          STRB     r1,[r0,#0x70]!
;;;2684   
;;;2685     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2686   
;;;2687     /* Send break characters */
;;;2688     SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
000012  f8501c70          LDR      r1,[r0,#-0x70]
000016  8b0a              LDRH     r2,[r1,#0x18]
000018  f0420202          ORR      r2,r2,#2
00001c  830a              STRH     r2,[r1,#0x18]
;;;2689   
;;;2690     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2691   
;;;2692     /* Process Unlocked */
;;;2693     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2694   
;;;2695     return HAL_OK;
000026  4608              MOV      r0,r1
;;;2696   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;2683
00002c  4770              BX       lr
;;;2697   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;2594     */
;;;2595   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;2596   {
;;;2597     /* Process Locked */
;;;2598     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00f              BEQ      |L6.40|
000008  2101              MOVS     r1,#1
00000a  f8801070          STRB     r1,[r0,#0x70]
;;;2599   
;;;2600     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  f8801071          STRB     r1,[r0,#0x71]
;;;2601   
;;;2602     /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;2603     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f4225200          BIC      r2,r2,#0x2000
00001c  600a              STR      r2,[r1,#0]
;;;2604   
;;;2605     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  f8801071          STRB     r1,[r0,#0x71]
;;;2606   
;;;2607     return (UART_CheckIdleState(huart));
000024  f7ffbffe          B.W      UART_CheckIdleState
                  |L6.40|
000028  2002              MOVS     r0,#2                 ;2598
;;;2608   }
00002a  4770              BX       lr
;;;2609   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;2573     */
;;;2574   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;2575   {
;;;2576     /* Process Locked */
;;;2577     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00f              BEQ      |L7.40|
000008  2101              MOVS     r1,#1
00000a  f8801070          STRB     r1,[r0,#0x70]
;;;2578   
;;;2579     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  f8801071          STRB     r1,[r0,#0x71]
;;;2580   
;;;2581     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;2582     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f4425200          ORR      r2,r2,#0x2000
00001c  600a              STR      r2,[r1,#0]
;;;2583   
;;;2584     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  f8801071          STRB     r1,[r0,#0x71]
;;;2585   
;;;2586     return (UART_CheckIdleState(huart));
000024  f7ffbffe          B.W      UART_CheckIdleState
                  |L7.40|
000028  2002              MOVS     r0,#2                 ;2577
;;;2587   }
00002a  4770              BX       lr
;;;2588   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2615     */
;;;2616   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;2617   {
;;;2618     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  8b01              LDRH     r1,[r0,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  8301              STRH     r1,[r0,#0x18]
;;;2619   }
00000a  4770              BX       lr
;;;2620   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;575      */
;;;576    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;577    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d003              BEQ      |L9.18|
;;;578      /* Check the UART handle allocation */
;;;579      if (huart == NULL)
;;;580      {
;;;581        return HAL_ERROR;
;;;582      }
;;;583    
;;;584      /* Check the wake up method parameter */
;;;585      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;586    
;;;587      if (huart->gState == HAL_UART_STATE_RESET)
00000a  f8940071          LDRB     r0,[r4,#0x71]
00000e  b110              CBZ      r0,|L9.22|
000010  e007              B        |L9.34|
                  |L9.18|
000012  2001              MOVS     r0,#1                 ;581
                  |L9.20|
;;;588      {
;;;589        /* Allocate lock resource and initialize it */
;;;590        huart->Lock = HAL_UNLOCKED;
;;;591    
;;;592    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;593        UART_InitCallbacksToDefault(huart);
;;;594    
;;;595        if (huart->MspInitCallback == NULL)
;;;596        {
;;;597          huart->MspInitCallback = HAL_UART_MspInit;
;;;598        }
;;;599    
;;;600        /* Init the low level hardware */
;;;601        huart->MspInitCallback(huart);
;;;602    #else
;;;603        /* Init the low level hardware : GPIO, CLOCK */
;;;604        HAL_UART_MspInit(huart);
;;;605    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;606      }
;;;607    
;;;608      huart->gState = HAL_UART_STATE_BUSY;
;;;609    
;;;610      /* Disable the Peripheral */
;;;611      __HAL_UART_DISABLE(huart);
;;;612    
;;;613      /* Set the UART Communication parameters */
;;;614      if (UART_SetConfig(huart) == HAL_ERROR)
;;;615      {
;;;616        return HAL_ERROR;
;;;617      }
;;;618    
;;;619      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;620      {
;;;621        UART_AdvFeatureConfig(huart);
;;;622      }
;;;623    
;;;624      /* In multiprocessor mode, the following bits must be kept cleared:
;;;625      - LINEN and CLKEN bits in the USART_CR2 register,
;;;626      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;627      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;628      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;629    
;;;630      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;631      {
;;;632        /* If address mark wake up method is chosen, set the USART address node */
;;;633        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;634      }
;;;635    
;;;636      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;637      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;638    
;;;639      /* Enable the Peripheral */
;;;640      __HAL_UART_ENABLE(huart);
;;;641    
;;;642      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;643      return (UART_CheckIdleState(huart));
;;;644    }
000014  bd70              POP      {r4-r6,pc}
                  |L9.22|
000016  2000              MOVS     r0,#0                 ;590
000018  f8840070          STRB     r0,[r4,#0x70]         ;590
00001c  4620              MOV      r0,r4                 ;604
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L9.34|
000022  2024              MOVS     r0,#0x24              ;608
000024  f8840071          STRB     r0,[r4,#0x71]         ;608
000028  6820              LDR      r0,[r4,#0]            ;611
00002a  6801              LDR      r1,[r0,#0]            ;611
00002c  f0210101          BIC      r1,r1,#1              ;611
000030  6001              STR      r1,[r0,#0]            ;611
000032  4620              MOV      r0,r4                 ;614
000034  f7fffffe          BL       UART_SetConfig
000038  2801              CMP      r0,#1                 ;614
00003a  d0eb              BEQ      |L9.20|
00003c  6a60              LDR      r0,[r4,#0x24]         ;619
00003e  b110              CBZ      r0,|L9.70|
000040  4620              MOV      r0,r4                 ;621
000042  f7fffffe          BL       UART_AdvFeatureConfig
                  |L9.70|
000046  6820              LDR      r0,[r4,#0]            ;627
000048  6841              LDR      r1,[r0,#4]            ;627
00004a  f4214190          BIC      r1,r1,#0x4800         ;627
00004e  6041              STR      r1,[r0,#4]            ;627
000050  6820              LDR      r0,[r4,#0]            ;628
000052  6881              LDR      r1,[r0,#8]            ;628
000054  f021012a          BIC      r1,r1,#0x2a           ;628
000058  6081              STR      r1,[r0,#8]            ;628
00005a  f5b56f00          CMP      r5,#0x800             ;630
00005e  d104              BNE      |L9.106|
000060  6820              LDR      r0,[r4,#0]            ;633
000062  6841              LDR      r1,[r0,#4]            ;633
000064  f366611f          BFI      r1,r6,#24,#8          ;633
000068  6041              STR      r1,[r0,#4]            ;633
                  |L9.106|
00006a  6820              LDR      r0,[r4,#0]            ;637
00006c  6801              LDR      r1,[r0,#0]            ;637
00006e  f4216100          BIC      r1,r1,#0x800          ;637
000072  4329              ORRS     r1,r1,r5              ;637
000074  6001              STR      r1,[r0,#0]            ;637
000076  6820              LDR      r0,[r4,#0]            ;640
000078  6801              LDR      r1,[r0,#0]            ;640
00007a  f0410101          ORR      r1,r1,#1              ;640
00007e  6001              STR      r1,[r0,#0]            ;640
000080  4620              MOV      r0,r4                 ;643
000082  e8bd4070          POP      {r4-r6,lr}            ;643
000086  f7ffbffe          B.W      UART_CheckIdleState
;;;645    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1644   */
;;;1645   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1646   {
000002  4604              MOV      r4,r0
;;;1647   #if defined(USART_CR1_FIFOEN)
;;;1648     /* Disable TXE, TC, RXNE, PE, RXFT, TXFT and ERR (Frame error, noise error, overrun error) interrupts */
;;;1649     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
;;;1650     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE);
;;;1651   #else
;;;1652     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1653     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  6001              STR      r1,[r0,#0]
;;;1654     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;1655   #endif
;;;1656   
;;;1657     /* Disable the UART DMA Tx request if enabled */
;;;1658     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6881              LDR      r1,[r0,#8]
00001c  f04f0500          MOV      r5,#0
000020  0609              LSLS     r1,r1,#24
000022  d509              BPL      |L10.56|
;;;1659     {
;;;1660       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000024  6881              LDR      r1,[r0,#8]
000026  f0210180          BIC      r1,r1,#0x80
00002a  6081              STR      r1,[r0,#8]
;;;1661   
;;;1662       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1663       if (huart->hdmatx != NULL)
00002c  6ea0              LDR      r0,[r4,#0x68]
00002e  b118              CBZ      r0,|L10.56|
;;;1664       {
;;;1665         /* Set the UART DMA Abort callback to Null.
;;;1666            No call back execution at end of DMA abort procedure */
;;;1667         huart->hdmatx->XferAbortCallback = NULL;
;;;1668   
;;;1669         HAL_DMA_Abort(huart->hdmatx);
000030  6385              STR      r5,[r0,#0x38]
000032  6ea0              LDR      r0,[r4,#0x68]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L10.56|
;;;1670       }
;;;1671     }
;;;1672   
;;;1673     /* Disable the UART DMA Rx request if enabled */
;;;1674     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000038  6820              LDR      r0,[r4,#0]
00003a  6881              LDR      r1,[r0,#8]
00003c  0649              LSLS     r1,r1,#25
00003e  d509              BPL      |L10.84|
;;;1675     {
;;;1676       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6881              LDR      r1,[r0,#8]
000042  f0210140          BIC      r1,r1,#0x40
000046  6081              STR      r1,[r0,#8]
;;;1677   
;;;1678       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1679       if (huart->hdmarx != NULL)
000048  6ee0              LDR      r0,[r4,#0x6c]
00004a  b118              CBZ      r0,|L10.84|
;;;1680       {
;;;1681         /* Set the UART DMA Abort callback to Null.
;;;1682            No call back execution at end of DMA abort procedure */
;;;1683         huart->hdmarx->XferAbortCallback = NULL;
;;;1684   
;;;1685         HAL_DMA_Abort(huart->hdmarx);
00004c  6385              STR      r5,[r0,#0x38]
00004e  6ee0              LDR      r0,[r4,#0x6c]
000050  f7fffffe          BL       HAL_DMA_Abort
                  |L10.84|
;;;1686       }
;;;1687     }
;;;1688   
;;;1689     /* Reset Tx and Rx transfer counters */
;;;1690     huart->TxXferCount = 0U;
000054  f8a45052          STRH     r5,[r4,#0x52]
;;;1691     huart->RxXferCount = 0U;
000058  f8a4505a          STRH     r5,[r4,#0x5a]
;;;1692   
;;;1693     /* Clear the Error flags in the ICR register */
;;;1694     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00005c  6821              LDR      r1,[r4,#0]
00005e  200f              MOVS     r0,#0xf
000060  6208              STR      r0,[r1,#0x20]
;;;1695   
;;;1696   #if defined(USART_CR1_FIFOEN)
;;;1697     /* Flush the whole TX FIFO (if needed) */
;;;1698     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1699     {
;;;1700       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;1701     }
;;;1702   #endif
;;;1703   
;;;1704     /* Discard the received data */
;;;1705     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000062  6820              LDR      r0,[r4,#0]
000064  8b01              LDRH     r1,[r0,#0x18]
000066  f0410108          ORR      r1,r1,#8
00006a  8301              STRH     r1,[r0,#0x18]
;;;1706   
;;;1707     /* Restore huart->gState and huart->RxState to Ready */
;;;1708     huart->gState  = HAL_UART_STATE_READY;
00006c  2020              MOVS     r0,#0x20
00006e  f8840071          STRB     r0,[r4,#0x71]
;;;1709     huart->RxState = HAL_UART_STATE_READY;
000072  f8840072          STRB     r0,[r4,#0x72]
;;;1710   
;;;1711     /* Reset Handle ErrorCode to No Error */
;;;1712     huart->ErrorCode = HAL_UART_ERROR_NONE;
000076  6765              STR      r5,[r4,#0x74]
;;;1713   
;;;1714     return HAL_OK;
000078  2000              MOVS     r0,#0
;;;1715   }
00007a  bd70              POP      {r4-r6,pc}
;;;1716   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2499     */
;;;2500   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2501   {
;;;2502     /* Prevent unused argument(s) compilation warning */
;;;2503     UNUSED(huart);
;;;2504   
;;;2505     /* NOTE : This function should not be modified, when the callback is needed,
;;;2506               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2507      */
;;;2508   }
;;;2509   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1784   */
;;;1785   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1786   {
000002  4604              MOV      r4,r0
;;;1787   #if defined(USART_CR1_FIFOEN)
;;;1788     /* Disable PEIE, EIE, RXNEIE and RXFTIE interrupts */
;;;1789     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
;;;1790     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE);
;;;1791   #else
;;;1792     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1793     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f4217190          BIC      r1,r1,#0x120
00000c  6001              STR      r1,[r0,#0]
;;;1794     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;1795   #endif
;;;1796   
;;;1797     /* Disable the UART DMA Rx request if enabled */
;;;1798     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6881              LDR      r1,[r0,#8]
00001c  f04f0500          MOV      r5,#0
000020  0649              LSLS     r1,r1,#25
000022  d509              BPL      |L12.56|
;;;1799     {
;;;1800       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000024  6881              LDR      r1,[r0,#8]
000026  f0210140          BIC      r1,r1,#0x40
00002a  6081              STR      r1,[r0,#8]
;;;1801   
;;;1802       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1803       if (huart->hdmarx != NULL)
00002c  6ee0              LDR      r0,[r4,#0x6c]
00002e  b118              CBZ      r0,|L12.56|
;;;1804       {
;;;1805         /* Set the UART DMA Abort callback to Null.
;;;1806            No call back execution at end of DMA abort procedure */
;;;1807         huart->hdmarx->XferAbortCallback = NULL;
;;;1808   
;;;1809         HAL_DMA_Abort(huart->hdmarx);
000030  6385              STR      r5,[r0,#0x38]
000032  6ee0              LDR      r0,[r4,#0x6c]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L12.56|
;;;1810       }
;;;1811     }
;;;1812   
;;;1813     /* Reset Rx transfer counter */
;;;1814     huart->RxXferCount = 0U;
000038  f8a4505a          STRH     r5,[r4,#0x5a]
;;;1815   
;;;1816     /* Clear the Error flags in the ICR register */
;;;1817     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00003c  6821              LDR      r1,[r4,#0]
00003e  200f              MOVS     r0,#0xf
000040  6208              STR      r0,[r1,#0x20]
;;;1818   
;;;1819     /* Discard the received data */
;;;1820     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000042  6820              LDR      r0,[r4,#0]
000044  8b01              LDRH     r1,[r0,#0x18]
000046  f0410108          ORR      r1,r1,#8
00004a  8301              STRH     r1,[r0,#0x18]
;;;1821   
;;;1822     /* Restore huart->RxState to Ready */
;;;1823     huart->RxState = HAL_UART_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f8840072          STRB     r0,[r4,#0x72]
;;;1824   
;;;1825     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;1826   }
000054  bd70              POP      {r4-r6,pc}
;;;1827   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2529     */
;;;2530   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2531   {
;;;2532     /* Prevent unused argument(s) compilation warning */
;;;2533     UNUSED(huart);
;;;2534   
;;;2535     /* NOTE : This function should not be modified, when the callback is needed,
;;;2536               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2537      */
;;;2538   }
;;;2539   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;2088   */
;;;2089   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2090   {
000002  4604              MOV      r4,r0
;;;2091     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2092   #if defined(USART_CR1_FIFOEN)
;;;2093     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
;;;2094     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
;;;2095   #else
;;;2096     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f4217190          BIC      r1,r1,#0x120
00000c  6001              STR      r1,[r0,#0]
;;;2097     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;2098   #endif
;;;2099   
;;;2100     /* Disable the UART DMA Rx request if enabled */
;;;2101     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6881              LDR      r1,[r0,#8]
;;;2102     {
;;;2103       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2104   
;;;2105       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;2106       if (huart->hdmarx != NULL)
;;;2107       {
;;;2108         /* Set the UART DMA Abort callback :
;;;2109            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2110         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;2111   
;;;2112         /* Abort DMA RX */
;;;2113         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2114         {
;;;2115           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2116           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2117         }
;;;2118       }
;;;2119       else
;;;2120       {
;;;2121         /* Reset Rx transfer counter */
;;;2122         huart->RxXferCount = 0U;
;;;2123   
;;;2124         /* Clear RxISR function pointer */
;;;2125         huart->pRxBuffPtr = NULL;
;;;2126   
;;;2127         /* Clear the Error flags in the ICR register */
;;;2128         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00001c  f04f030f          MOV      r3,#0xf
000020  064d              LSLS     r5,r1,#25             ;2101
000022  f04f0100          MOV      r1,#0                 ;2101
;;;2129   
;;;2130         /* Discard the received data */
;;;2131         __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
;;;2132   
;;;2133         /* Restore huart->RxState to Ready */
;;;2134         huart->RxState = HAL_UART_STATE_READY;
000026  f04f0220          MOV      r2,#0x20
00002a  d520              BPL      |L14.110|
00002c  6885              LDR      r5,[r0,#8]            ;2103
00002e  f0250540          BIC      r5,r5,#0x40           ;2103
000032  6085              STR      r5,[r0,#8]            ;2103
000034  6ee0              LDR      r0,[r4,#0x6c]         ;2106
000036  b148              CBZ      r0,|L14.76|
000038  490f              LDR      r1,|L14.120|
00003a  6381              STR      r1,[r0,#0x38]         ;2113
00003c  6ee0              LDR      r0,[r4,#0x6c]         ;2113
00003e  f7fffffe          BL       HAL_DMA_Abort_IT
000042  b190              CBZ      r0,|L14.106|
000044  6ee0              LDR      r0,[r4,#0x6c]         ;2116
000046  6b81              LDR      r1,[r0,#0x38]         ;2116
000048  4788              BLX      r1                    ;2116
00004a  e00e              B        |L14.106|
                  |L14.76|
00004c  f8a4105a          STRH     r1,[r4,#0x5a]         ;2122
000050  6561              STR      r1,[r4,#0x54]         ;2128
000052  6820              LDR      r0,[r4,#0]            ;2128
000054  6203              STR      r3,[r0,#0x20]         ;2128
000056  6820              LDR      r0,[r4,#0]            ;2131
000058  8b01              LDRH     r1,[r0,#0x18]         ;2131
00005a  f0410108          ORR      r1,r1,#8              ;2131
00005e  8301              STRH     r1,[r0,#0x18]         ;2131
                  |L14.96|
000060  f8842072          STRB     r2,[r4,#0x72]
;;;2135   
;;;2136         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2137   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2138         /* Call registered Abort Receive Complete Callback */
;;;2139         huart->AbortReceiveCpltCallback(huart);
;;;2140   #else
;;;2141         /* Call legacy weak Abort Receive Complete Callback */
;;;2142         HAL_UART_AbortReceiveCpltCallback(huart);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L14.106|
;;;2143   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2144       }
;;;2145     }
;;;2146     else
;;;2147     {
;;;2148       /* Reset Rx transfer counter */
;;;2149       huart->RxXferCount = 0U;
;;;2150   
;;;2151       /* Clear RxISR function pointer */
;;;2152       huart->pRxBuffPtr = NULL;
;;;2153   
;;;2154       /* Clear the Error flags in the ICR register */
;;;2155       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
;;;2156   
;;;2157       /* Restore huart->RxState to Ready */
;;;2158       huart->RxState = HAL_UART_STATE_READY;
;;;2159   
;;;2160       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2161   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2162       /* Call registered Abort Receive Complete Callback */
;;;2163       huart->AbortReceiveCpltCallback(huart);
;;;2164   #else
;;;2165       /* Call legacy weak Abort Receive Complete Callback */
;;;2166       HAL_UART_AbortReceiveCpltCallback(huart);
;;;2167   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2168     }
;;;2169   
;;;2170     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;2171   }
00006c  bd70              POP      {r4-r6,pc}
                  |L14.110|
00006e  f8a4105a          STRH     r1,[r4,#0x5a]         ;2149
000072  6561              STR      r1,[r4,#0x54]         ;2155
000074  6203              STR      r3,[r0,#0x20]         ;2155
000076  e7f3              B        |L14.96|
;;;2172   
                          ENDP

                  |L14.120|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1728   */
;;;1729   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1730   {
000002  4604              MOV      r4,r0
;;;1731   #if defined(USART_CR1_FIFOEN)
;;;1732     /* Disable TCIE, TXEIE and TXFTIE interrupts */
;;;1733     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
;;;1734     CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
;;;1735   #else
;;;1736     /* Disable TXEIE and TCIE interrupts */
;;;1737     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  6001              STR      r1,[r0,#0]
;;;1738   #endif
;;;1739   
;;;1740     /* Disable the UART DMA Tx request if enabled */
;;;1741     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d509              BPL      |L15.46|
;;;1742     {
;;;1743       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6881              LDR      r1,[r0,#8]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6081              STR      r1,[r0,#8]
;;;1744   
;;;1745       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1746       if (huart->hdmatx != NULL)
000022  6ea0              LDR      r0,[r4,#0x68]
000024  b118              CBZ      r0,|L15.46|
;;;1747       {
;;;1748         /* Set the UART DMA Abort callback to Null.
;;;1749            No call back execution at end of DMA abort procedure */
;;;1750         huart->hdmatx->XferAbortCallback = NULL;
;;;1751   
;;;1752         HAL_DMA_Abort(huart->hdmatx);
000026  6385              STR      r5,[r0,#0x38]
000028  6ea0              LDR      r0,[r4,#0x68]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L15.46|
;;;1753       }
;;;1754     }
;;;1755   
;;;1756     /* Reset Tx transfer counter */
;;;1757     huart->TxXferCount = 0U;
00002e  f8245f52          STRH     r5,[r4,#0x52]!
;;;1758   
;;;1759   #if defined(USART_CR1_FIFOEN)
;;;1760     /* Flush the whole TX FIFO (if needed) */
;;;1761     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1762     {
;;;1763       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;1764     }
;;;1765   #endif
;;;1766   
;;;1767     /* Restore huart->gState to Ready */
;;;1768     huart->gState = HAL_UART_STATE_READY;
000032  2020              MOVS     r0,#0x20
000034  77e0              STRB     r0,[r4,#0x1f]
;;;1769   
;;;1770     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1771   }
000038  bd70              POP      {r4-r6,pc}
;;;1772   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2514     */
;;;2515   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2516   {
;;;2517     /* Prevent unused argument(s) compilation warning */
;;;2518     UNUSED(huart);
;;;2519   
;;;2520     /* NOTE : This function should not be modified, when the callback is needed,
;;;2521               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2522      */
;;;2523   }
;;;2524   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1992   */
;;;1993   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1994   {
000002  4604              MOV      r4,r0
;;;1995     /* Disable interrupts */
;;;1996   #if defined(USART_CR1_FIFOEN)
;;;1997     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
;;;1998     CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
;;;1999   #else
;;;2000     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  6001              STR      r1,[r0,#0]
;;;2001   #endif
;;;2002   
;;;2003     /* Disable the UART DMA Tx request if enabled */
;;;2004     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
;;;2005     {
;;;2006       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;2007   
;;;2008       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;2009       if (huart->hdmatx != NULL)
;;;2010       {
;;;2011         /* Set the UART DMA Abort callback :
;;;2012            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2013         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;2014   
;;;2015         /* Abort DMA TX */
;;;2016         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;2017         {
;;;2018           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;2019           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;2020         }
;;;2021       }
;;;2022       else
;;;2023       {
;;;2024         /* Reset Tx transfer counter */
;;;2025         huart->TxXferCount = 0U;
;;;2026   
;;;2027         /* Clear TxISR function pointers */
;;;2028         huart->TxISR = NULL;
;;;2029   
;;;2030         /* Restore huart->gState to Ready */
;;;2031         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;2004
000018  f04f0100          MOV      r1,#0                 ;2004
00001c  d50f              BPL      |L17.62|
00001e  6883              LDR      r3,[r0,#8]            ;2006
000020  f0230380          BIC      r3,r3,#0x80           ;2006
000024  6083              STR      r3,[r0,#8]            ;2006
000026  6ea0              LDR      r0,[r4,#0x68]         ;2009
000028  b148              CBZ      r0,|L17.62|
00002a  490a              LDR      r1,|L17.84|
00002c  6381              STR      r1,[r0,#0x38]         ;2016
00002e  6ea0              LDR      r0,[r4,#0x68]         ;2016
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b158              CBZ      r0,|L17.78|
000036  6ea0              LDR      r0,[r4,#0x68]         ;2019
000038  6b81              LDR      r1,[r0,#0x38]         ;2019
00003a  4788              BLX      r1                    ;2019
00003c  e007              B        |L17.78|
                  |L17.62|
00003e  f8a41052          STRH     r1,[r4,#0x52]         ;2025
000042  6661              STR      r1,[r4,#0x64]
000044  f8842071          STRB     r2,[r4,#0x71]
;;;2032   
;;;2033         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2034   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2035         /* Call registered Abort Transmit Complete Callback */
;;;2036         huart->AbortTransmitCpltCallback(huart);
;;;2037   #else
;;;2038         /* Call legacy weak Abort Transmit Complete Callback */
;;;2039         HAL_UART_AbortTransmitCpltCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L17.78|
;;;2040   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2041       }
;;;2042     }
;;;2043     else
;;;2044     {
;;;2045       /* Reset Tx transfer counter */
;;;2046       huart->TxXferCount = 0U;
;;;2047   
;;;2048       /* Clear TxISR function pointers */
;;;2049       huart->TxISR = NULL;
;;;2050   
;;;2051   #if defined(USART_CR1_FIFOEN)
;;;2052       /* Flush the whole TX FIFO (if needed) */
;;;2053       if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;2054       {
;;;2055         __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;2056       }
;;;2057   #endif
;;;2058   
;;;2059       /* Restore huart->gState to Ready */
;;;2060       huart->gState = HAL_UART_STATE_READY;
;;;2061   
;;;2062       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2063   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2064       /* Call registered Abort Transmit Complete Callback */
;;;2065       huart->AbortTransmitCpltCallback(huart);
;;;2066   #else
;;;2067       /* Call legacy weak Abort Transmit Complete Callback */
;;;2068       HAL_UART_AbortTransmitCpltCallback(huart);
;;;2069   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2070     }
;;;2071   
;;;2072     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;2073   }
000050  bd10              POP      {r4,pc}
;;;2074   
                          ENDP

000052  0000              DCW      0x0000
                  |L17.84|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1841   */
;;;1842   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1843   {
000002  4604              MOV      r4,r0
;;;1844     uint32_t abortcplt = 1U;
;;;1845   
;;;1846     /* Disable interrupts */
;;;1847   #if defined(USART_CR1_FIFOEN)
;;;1848     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_TCIE | USART_CR1_RXNEIE_RXFNEIE | USART_CR1_TXEIE_TXFNFIE));
;;;1849     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
;;;1850   #else
;;;1851     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1844
000008  6801              LDR      r1,[r0,#0]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  6001              STR      r1,[r0,#0]
;;;1852     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  f0210101          BIC      r1,r1,#1
000018  6081              STR      r1,[r0,#8]
00001a  6ea0              LDR      r0,[r4,#0x68]         ;1843
;;;1853   #endif
;;;1854   
;;;1855     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1856        before any call to DMA Abort functions */
;;;1857     /* DMA Tx Handle is valid */
;;;1858     if (huart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L18.48|
;;;1859     {
;;;1860       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1861          Otherwise, set it to NULL */
;;;1862       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6889              LDR      r1,[r1,#8]
000024  0609              LSLS     r1,r1,#24
000026  d502              BPL      |L18.46|
;;;1863       {
;;;1864         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000028  4924              LDR      r1,|L18.188|
00002a  6381              STR      r1,[r0,#0x38]
00002c  e000              B        |L18.48|
                  |L18.46|
;;;1865       }
;;;1866       else
;;;1867       {
;;;1868         huart->hdmatx->XferAbortCallback = NULL;
00002e  6385              STR      r5,[r0,#0x38]
                  |L18.48|
;;;1869       }
;;;1870     }
;;;1871     /* DMA Rx Handle is valid */
;;;1872     if (huart->hdmarx != NULL)
000030  6ee0              LDR      r0,[r4,#0x6c]
000032  b138              CBZ      r0,|L18.68|
;;;1873     {
;;;1874       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1875          Otherwise, set it to NULL */
;;;1876       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6889              LDR      r1,[r1,#8]
000038  0649              LSLS     r1,r1,#25
00003a  d502              BPL      |L18.66|
;;;1877       {
;;;1878         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00003c  4920              LDR      r1,|L18.192|
00003e  6381              STR      r1,[r0,#0x38]
000040  e000              B        |L18.68|
                  |L18.66|
;;;1879       }
;;;1880       else
;;;1881       {
;;;1882         huart->hdmarx->XferAbortCallback = NULL;
000042  6385              STR      r5,[r0,#0x38]
                  |L18.68|
;;;1883       }
;;;1884     }
;;;1885   
;;;1886     /* Disable the UART DMA Tx request if enabled */
;;;1887     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6881              LDR      r1,[r0,#8]
000048  0609              LSLS     r1,r1,#24
00004a  d50c              BPL      |L18.102|
;;;1888     {
;;;1889       /* Disable DMA Tx at UART level */
;;;1890       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004c  6881              LDR      r1,[r0,#8]
00004e  f0210180          BIC      r1,r1,#0x80
000052  6081              STR      r1,[r0,#8]
;;;1891   
;;;1892       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1893       if (huart->hdmatx != NULL)
000054  6ea0              LDR      r0,[r4,#0x68]
000056  b130              CBZ      r0,|L18.102|
;;;1894       {
;;;1895         /* UART Tx DMA Abort callback has already been initialised :
;;;1896            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1897   
;;;1898         /* Abort DMA TX */
;;;1899         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  b110              CBZ      r0,|L18.100|
;;;1900         {
;;;1901           huart->hdmatx->XferAbortCallback = NULL;
00005e  6ea0              LDR      r0,[r4,#0x68]
000060  6385              STR      r5,[r0,#0x38]
000062  e000              B        |L18.102|
                  |L18.100|
;;;1902         }
;;;1903         else
;;;1904         {
;;;1905           abortcplt = 0U;
000064  2600              MOVS     r6,#0
                  |L18.102|
;;;1906         }
;;;1907       }
;;;1908     }
;;;1909   
;;;1910     /* Disable the UART DMA Rx request if enabled */
;;;1911     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000066  6820              LDR      r0,[r4,#0]
000068  6881              LDR      r1,[r0,#8]
00006a  0649              LSLS     r1,r1,#25
00006c  d50b              BPL      |L18.134|
;;;1912     {
;;;1913       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00006e  6881              LDR      r1,[r0,#8]
000070  f0210140          BIC      r1,r1,#0x40
000074  6081              STR      r1,[r0,#8]
;;;1914   
;;;1915       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1916       if (huart->hdmarx != NULL)
000076  6ee0              LDR      r0,[r4,#0x6c]
000078  b128              CBZ      r0,|L18.134|
;;;1917       {
;;;1918         /* UART Rx DMA Abort callback has already been initialised :
;;;1919            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1920   
;;;1921         /* Abort DMA RX */
;;;1922         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007a  f7fffffe          BL       HAL_DMA_Abort_IT
00007e  b1d0              CBZ      r0,|L18.182|
;;;1923         {
;;;1924           huart->hdmarx->XferAbortCallback = NULL;
000080  6ee0              LDR      r0,[r4,#0x6c]
;;;1925           abortcplt = 1U;
000082  6385              STR      r5,[r0,#0x38]
000084  e000              B        |L18.136|
                  |L18.134|
;;;1926         }
;;;1927         else
;;;1928         {
;;;1929           abortcplt = 0U;
;;;1930         }
;;;1931       }
;;;1932     }
;;;1933   
;;;1934     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1935     if (abortcplt == 1U)
000086  b1b6              CBZ      r6,|L18.182|
                  |L18.136|
;;;1936     {
;;;1937       /* Reset Tx and Rx transfer counters */
;;;1938       huart->TxXferCount = 0U;
000088  f8a45052          STRH     r5,[r4,#0x52]
;;;1939       huart->RxXferCount = 0U;
00008c  f8a4505a          STRH     r5,[r4,#0x5a]
;;;1940   
;;;1941       /* Clear ISR function pointers */
;;;1942       huart->RxISR = NULL;
;;;1943       huart->TxISR = NULL;
000090  6625              STR      r5,[r4,#0x60]
;;;1944   
;;;1945       /* Reset errorCode */
;;;1946       huart->ErrorCode = HAL_UART_ERROR_NONE;
000092  6665              STR      r5,[r4,#0x64]
000094  6765              STR      r5,[r4,#0x74]
;;;1947   
;;;1948       /* Clear the Error flags in the ICR register */
;;;1949       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000096  6821              LDR      r1,[r4,#0]
000098  200f              MOVS     r0,#0xf
00009a  6208              STR      r0,[r1,#0x20]
;;;1950   
;;;1951   #if defined(USART_CR1_FIFOEN)
;;;1952       /* Flush the whole TX FIFO (if needed) */
;;;1953       if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1954       {
;;;1955         __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;1956       }
;;;1957   #endif
;;;1958   
;;;1959       /* Discard the received data */
;;;1960       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
00009c  6820              LDR      r0,[r4,#0]
00009e  8b01              LDRH     r1,[r0,#0x18]
0000a0  f0410108          ORR      r1,r1,#8
0000a4  8301              STRH     r1,[r0,#0x18]
;;;1961   
;;;1962       /* Restore huart->gState and huart->RxState to Ready */
;;;1963       huart->gState  = HAL_UART_STATE_READY;
0000a6  2020              MOVS     r0,#0x20
0000a8  f8840071          STRB     r0,[r4,#0x71]
;;;1964       huart->RxState = HAL_UART_STATE_READY;
0000ac  f8840072          STRB     r0,[r4,#0x72]
;;;1965   
;;;1966       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1967   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1968       /* Call registered Abort complete callback */
;;;1969       huart->AbortCpltCallback(huart);
;;;1970   #else
;;;1971       /* Call legacy weak Abort complete callback */
;;;1972       HAL_UART_AbortCpltCallback(huart);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L18.182|
;;;1973   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1974     }
;;;1975   
;;;1976     return HAL_OK;
0000b6  2000              MOVS     r0,#0
;;;1977   }
0000b8  bd70              POP      {r4-r6,pc}
;;;1978   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L18.188|
                          DCD      UART_DMATxAbortCallback
                  |L18.192|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1523     */
;;;1524   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;1525   {
;;;1526     /* Process Locked */
;;;1527     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d007              BEQ      |L19.24|
000008  2101              MOVS     r1,#1
00000a  f8801070          STRB     r1,[r0,#0x70]
;;;1528   
;;;1529     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
00000e  f8901071          LDRB     r1,[r0,#0x71]
000012  2921              CMP      r1,#0x21
000014  d002              BEQ      |L19.28|
000016  e009              B        |L19.44|
                  |L19.24|
000018  2002              MOVS     r0,#2                 ;1527
;;;1530         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1531     {
;;;1532       /* Disable the UART DMA Tx request */
;;;1533       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1534     }
;;;1535     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1536         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1537     {
;;;1538       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1539       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1540       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1541   
;;;1542       /* Disable the UART DMA Rx request */
;;;1543       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1544     }
;;;1545   
;;;1546     /* Process Unlocked */
;;;1547     __HAL_UNLOCK(huart);
;;;1548   
;;;1549     return HAL_OK;
;;;1550   }
00001a  4770              BX       lr
                  |L19.28|
00001c  6801              LDR      r1,[r0,#0]            ;1530
00001e  688a              LDR      r2,[r1,#8]            ;1530
000020  0612              LSLS     r2,r2,#24             ;1530
000022  d503              BPL      |L19.44|
000024  688a              LDR      r2,[r1,#8]            ;1533
000026  f0220280          BIC      r2,r2,#0x80           ;1533
00002a  608a              STR      r2,[r1,#8]            ;1533
                  |L19.44|
00002c  f8901072          LDRB     r1,[r0,#0x72]         ;1535
000030  2922              CMP      r1,#0x22              ;1535
000032  d111              BNE      |L19.88|
000034  6801              LDR      r1,[r0,#0]            ;1536
000036  688a              LDR      r2,[r1,#8]            ;1536
000038  0652              LSLS     r2,r2,#25             ;1536
00003a  d50d              BPL      |L19.88|
00003c  680a              LDR      r2,[r1,#0]            ;1539
00003e  f4227280          BIC      r2,r2,#0x100          ;1539
000042  600a              STR      r2,[r1,#0]            ;1539
000044  6801              LDR      r1,[r0,#0]            ;1540
000046  688a              LDR      r2,[r1,#8]            ;1540
000048  f0220201          BIC      r2,r2,#1              ;1540
00004c  608a              STR      r2,[r1,#8]            ;1540
00004e  6801              LDR      r1,[r0,#0]            ;1543
000050  688a              LDR      r2,[r1,#8]            ;1543
000052  f0220240          BIC      r2,r2,#0x40           ;1543
000056  608a              STR      r2,[r1,#8]            ;1543
                  |L19.88|
000058  2100              MOVS     r1,#0                 ;1547
00005a  f8801070          STRB     r1,[r0,#0x70]         ;1547
00005e  4608              MOV      r0,r1                 ;1549
000060  4770              BX       lr
;;;1551   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1556     */
;;;1557   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  f8901070          LDRB     r1,[r0,#0x70]
;;;1558   {
;;;1559     /* Process Locked */
;;;1560     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d007              BEQ      |L20.24|
000008  2101              MOVS     r1,#1
00000a  f8801070          STRB     r1,[r0,#0x70]
;;;1561   
;;;1562     if (huart->gState == HAL_UART_STATE_BUSY_TX)
00000e  f8901071          LDRB     r1,[r0,#0x71]
000012  2921              CMP      r1,#0x21
000014  d002              BEQ      |L20.28|
000016  e006              B        |L20.38|
                  |L20.24|
000018  2002              MOVS     r0,#2                 ;1560
;;;1563     {
;;;1564       /* Enable the UART DMA Tx request */
;;;1565       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1566     }
;;;1567     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1568     {
;;;1569       /* Clear the Overrun flag before resuming the Rx transfer */
;;;1570       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
;;;1571   
;;;1572       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1573       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1574       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1575   
;;;1576       /* Enable the UART DMA Rx request */
;;;1577       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1578     }
;;;1579   
;;;1580     /* Process Unlocked */
;;;1581     __HAL_UNLOCK(huart);
;;;1582   
;;;1583     return HAL_OK;
;;;1584   }
00001a  4770              BX       lr
                  |L20.28|
00001c  6801              LDR      r1,[r0,#0]            ;1565
00001e  688a              LDR      r2,[r1,#8]            ;1565
000020  f0420280          ORR      r2,r2,#0x80           ;1565
000024  608a              STR      r2,[r1,#8]            ;1565
                  |L20.38|
000026  f8901072          LDRB     r1,[r0,#0x72]         ;1567
00002a  2922              CMP      r1,#0x22              ;1567
00002c  d111              BNE      |L20.82|
00002e  6802              LDR      r2,[r0,#0]            ;1570
000030  2108              MOVS     r1,#8                 ;1570
000032  6211              STR      r1,[r2,#0x20]         ;1570
000034  6801              LDR      r1,[r0,#0]            ;1573
000036  680a              LDR      r2,[r1,#0]            ;1573
000038  f4427280          ORR      r2,r2,#0x100          ;1573
00003c  600a              STR      r2,[r1,#0]            ;1573
00003e  6801              LDR      r1,[r0,#0]            ;1574
000040  688a              LDR      r2,[r1,#8]            ;1574
000042  f0420201          ORR      r2,r2,#1              ;1574
000046  608a              STR      r2,[r1,#8]            ;1574
000048  6801              LDR      r1,[r0,#0]            ;1577
00004a  688a              LDR      r2,[r1,#8]            ;1577
00004c  f0420240          ORR      r2,r2,#0x40           ;1577
000050  608a              STR      r2,[r1,#8]            ;1577
                  |L20.82|
000052  2100              MOVS     r1,#0                 ;1581
000054  f8801070          STRB     r1,[r0,#0x70]         ;1581
000058  4608              MOV      r0,r1                 ;1583
00005a  4770              BX       lr
;;;1585   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1590     */
;;;1591   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1592   {
000002  4604              MOV      r4,r0
;;;1593     /* The Lock is not implemented on this API to allow the user application
;;;1594     to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1595     HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1596     indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1597     interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1598     the stream and the corresponding call back is executed. */
;;;1599   
;;;1600     /* Stop UART DMA Tx request if ongoing */
;;;1601     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  f8900071          LDRB     r0,[r0,#0x71]
000008  2821              CMP      r0,#0x21
00000a  d10e              BNE      |L21.42|
;;;1602         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  0609              LSLS     r1,r1,#24
000012  d50a              BPL      |L21.42|
;;;1603     {
;;;1604       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6881              LDR      r1,[r0,#8]
000016  f0210180          BIC      r1,r1,#0x80
00001a  6081              STR      r1,[r0,#8]
;;;1605   
;;;1606       /* Abort the UART DMA Tx channel */
;;;1607       if (huart->hdmatx != NULL)
00001c  6ea0              LDR      r0,[r4,#0x68]
00001e  b108              CBZ      r0,|L21.36|
;;;1608       {
;;;1609         HAL_DMA_Abort(huart->hdmatx);
000020  f7fffffe          BL       HAL_DMA_Abort
                  |L21.36|
;;;1610       }
;;;1611   
;;;1612       UART_EndTxTransfer(huart);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       UART_EndTxTransfer
                  |L21.42|
;;;1613     }
;;;1614   
;;;1615     /* Stop UART DMA Rx request if ongoing */
;;;1616     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
00002a  f8940072          LDRB     r0,[r4,#0x72]
00002e  2822              CMP      r0,#0x22
000030  d10e              BNE      |L21.80|
;;;1617         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000032  6820              LDR      r0,[r4,#0]
000034  6881              LDR      r1,[r0,#8]
000036  0649              LSLS     r1,r1,#25
000038  d50a              BPL      |L21.80|
;;;1618     {
;;;1619       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00003a  6881              LDR      r1,[r0,#8]
00003c  f0210140          BIC      r1,r1,#0x40
000040  6081              STR      r1,[r0,#8]
;;;1620   
;;;1621       /* Abort the UART DMA Rx channel */
;;;1622       if (huart->hdmarx != NULL)
000042  6ee0              LDR      r0,[r4,#0x6c]
000044  b108              CBZ      r0,|L21.74|
;;;1623       {
;;;1624         HAL_DMA_Abort(huart->hdmarx);
000046  f7fffffe          BL       HAL_DMA_Abort
                  |L21.74|
;;;1625       }
;;;1626   
;;;1627       UART_EndRxTransfer(huart);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       UART_EndRxTransfer
                  |L21.80|
;;;1628     }
;;;1629   
;;;1630     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1631   }
000052  bd10              POP      {r4,pc}
;;;1632   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;651      */
;;;652    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;653    {
000002  0004              MOVS     r4,r0
000004  d01a              BEQ      |L22.60|
;;;654      /* Check the UART handle allocation */
;;;655      if (huart == NULL)
;;;656      {
;;;657        return HAL_ERROR;
;;;658      }
;;;659    
;;;660      /* Check the parameters */
;;;661      assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
;;;662    
;;;663      huart->gState = HAL_UART_STATE_BUSY;
000006  2024              MOVS     r0,#0x24
000008  f8840071          STRB     r0,[r4,#0x71]
;;;664    
;;;665      /* Disable the Peripheral */
;;;666      __HAL_UART_DISABLE(huart);
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0210101          BIC      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;667    
;;;668      huart->Instance->CR1 = 0x0U;
000016  6820              LDR      r0,[r4,#0]
000018  2500              MOVS     r5,#0
00001a  6005              STR      r5,[r0,#0]
;;;669      huart->Instance->CR2 = 0x0U;
00001c  6820              LDR      r0,[r4,#0]
00001e  6045              STR      r5,[r0,#4]
;;;670      huart->Instance->CR3 = 0x0U;
000020  6820              LDR      r0,[r4,#0]
000022  6085              STR      r5,[r0,#8]
;;;671    
;;;672    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;673      if (huart->MspDeInitCallback == NULL)
;;;674      {
;;;675        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;676      }
;;;677      /* DeInit the low level hardware */
;;;678      huart->MspDeInitCallback(huart);
;;;679    #else
;;;680      /* DeInit the low level hardware */
;;;681      HAL_UART_MspDeInit(huart);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_UART_MspDeInit
;;;682    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;683    
;;;684      huart->ErrorCode = HAL_UART_ERROR_NONE;
00002a  6765              STR      r5,[r4,#0x74]
;;;685      huart->gState = HAL_UART_STATE_RESET;
00002c  f8845071          STRB     r5,[r4,#0x71]
;;;686      huart->RxState = HAL_UART_STATE_RESET;
000030  f8845072          STRB     r5,[r4,#0x72]
;;;687    
;;;688      /* Process Unlock */
;;;689      __HAL_UNLOCK(huart);
000034  f8845070          STRB     r5,[r4,#0x70]
;;;690    
;;;691      return HAL_OK;
000038  2000              MOVS     r0,#0
;;;692    }
00003a  bd70              POP      {r4-r6,pc}
                  |L22.60|
00003c  2001              MOVS     r0,#1                 ;657
00003e  bd70              POP      {r4-r6,pc}
;;;693    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2484     */
;;;2485   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2486   {
;;;2487     /* Prevent unused argument(s) compilation warning */
;;;2488     UNUSED(huart);
;;;2489   
;;;2490     /* NOTE : This function should not be modified, when the callback is needed,
;;;2491               the HAL_UART_ErrorCallback can be implemented in the user file.
;;;2492      */
;;;2493   }
;;;2494   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2738   */
;;;2739   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6f40              LDR      r0,[r0,#0x74]
;;;2740   {
;;;2741     return huart->ErrorCode;
;;;2742   }
000002  4770              BX       lr
;;;2743   /**
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2723     */
;;;2724   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  f8101f71          LDRB     r1,[r0,#0x71]!
;;;2725   {
;;;2726     uint32_t temp1 = 0x00U, temp2 = 0x00U;
;;;2727     temp1 = huart->gState;
;;;2728     temp2 = huart->RxState;
000004  7840              LDRB     r0,[r0,#1]
;;;2729   
;;;2730     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000006  4308              ORRS     r0,r0,r1
;;;2731   }
000008  4770              BX       lr
;;;2732   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2177     */
;;;2178   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2179   {
;;;2180     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000004  6802              LDR      r2,[r0,#0]
000006  4604              MOV      r4,r0                 ;2179
000008  69d0              LDR      r0,[r2,#0x1c]
;;;2181     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6811              LDR      r1,[r2,#0]
;;;2182     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000c  6893              LDR      r3,[r2,#8]
;;;2183     uint32_t errorflags;
;;;2184   
;;;2185     /* If no error occurs */
;;;2186     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000e  f0100f0f          TST      r0,#0xf
000012  f04f0500          MOV      r5,#0
000016  d05b              BEQ      |L26.208|
;;;2187     if (errorflags == RESET)
;;;2188     {
;;;2189       /* UART in mode Receiver ---------------------------------------------------*/
;;;2190   #if defined(USART_CR1_FIFOEN)
;;;2191       if (((isrflags & USART_ISR_RXNE_RXFNE) != RESET)
;;;2192           && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != RESET)
;;;2193               || ((cr3its & USART_CR3_RXFTIE) != RESET)))
;;;2194   #else
;;;2195       if (((isrflags & USART_ISR_RXNE) != RESET)
;;;2196           && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;2197   #endif
;;;2198       {
;;;2199         if (huart->RxISR != NULL)
;;;2200         {
;;;2201           huart->RxISR(huart);
;;;2202         }
;;;2203         return;
;;;2204       }
;;;2205     }
;;;2206   
;;;2207     /* If some errors occur */
;;;2208   #if defined(USART_CR1_FIFOEN)
;;;2209     if ((errorflags != RESET)
;;;2210         && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != RESET)
;;;2211              || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE)) != RESET))))
;;;2212   #else
;;;2213     if ((errorflags != RESET)
;;;2214         && (((cr3its & USART_CR3_EIE) != RESET)
000018  f0030601          AND      r6,r3,#1
00001c  f4017790          AND      r7,r1,#0x120
000020  4337              ORRS     r7,r7,r6
000022  d069              BEQ      |L26.248|
;;;2215             || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
;;;2216   #endif
;;;2217     {
;;;2218       /* UART parity error interrupt occurred -------------------------------------*/
;;;2219       if (((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000024  07c7              LSLS     r7,r0,#31
000026  d007              BEQ      |L26.56|
000028  05cf              LSLS     r7,r1,#23
00002a  d505              BPL      |L26.56|
;;;2220       {
;;;2221         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
00002c  2701              MOVS     r7,#1
00002e  6217              STR      r7,[r2,#0x20]
;;;2222   
;;;2223         huart->ErrorCode |= HAL_UART_ERROR_PE;
000030  6f62              LDR      r2,[r4,#0x74]
000032  f0420201          ORR      r2,r2,#1
000036  6762              STR      r2,[r4,#0x74]
                  |L26.56|
;;;2224       }
;;;2225   
;;;2226       /* UART frame error interrupt occurred --------------------------------------*/
;;;2227       if (((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000038  0782              LSLS     r2,r0,#30
00003a  d508              BPL      |L26.78|
00003c  07da              LSLS     r2,r3,#31
00003e  d006              BEQ      |L26.78|
;;;2228       {
;;;2229         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
000040  6827              LDR      r7,[r4,#0]
000042  2202              MOVS     r2,#2
000044  623a              STR      r2,[r7,#0x20]
;;;2230   
;;;2231         huart->ErrorCode |= HAL_UART_ERROR_FE;
000046  6f62              LDR      r2,[r4,#0x74]
000048  f0420204          ORR      r2,r2,#4
00004c  6762              STR      r2,[r4,#0x74]
                  |L26.78|
;;;2232       }
;;;2233   
;;;2234       /* UART noise error interrupt occurred --------------------------------------*/
;;;2235       if (((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00004e  0742              LSLS     r2,r0,#29
000050  d508              BPL      |L26.100|
000052  07da              LSLS     r2,r3,#31
000054  d006              BEQ      |L26.100|
;;;2236       {
;;;2237         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
000056  6823              LDR      r3,[r4,#0]
000058  2204              MOVS     r2,#4
00005a  621a              STR      r2,[r3,#0x20]
;;;2238   
;;;2239         huart->ErrorCode |= HAL_UART_ERROR_NE;
00005c  6f62              LDR      r2,[r4,#0x74]
00005e  f0420202          ORR      r2,r2,#2
000062  6762              STR      r2,[r4,#0x74]
                  |L26.100|
;;;2240       }
;;;2241   
;;;2242       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;2243   #if defined(USART_CR1_FIFOEN)
;;;2244       if (((isrflags & USART_ISR_ORE) != RESET)
;;;2245           && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != RESET) ||
;;;2246               ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != RESET)))
;;;2247   #else
;;;2248       if (((isrflags & USART_ISR_ORE) != RESET)
000064  0702              LSLS     r2,r0,#28
000066  d50a              BPL      |L26.126|
;;;2249           && (((cr1its & USART_CR1_RXNEIE) != RESET) ||
000068  f0010220          AND      r2,r1,#0x20
00006c  4332              ORRS     r2,r2,r6
00006e  d006              BEQ      |L26.126|
;;;2250               ((cr3its & USART_CR3_EIE) != RESET)))
;;;2251   #endif
;;;2252       {
;;;2253         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
000070  6823              LDR      r3,[r4,#0]
000072  2208              MOVS     r2,#8
000074  621a              STR      r2,[r3,#0x20]
;;;2254   
;;;2255         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000076  6f62              LDR      r2,[r4,#0x74]
000078  f0420208          ORR      r2,r2,#8
00007c  6762              STR      r2,[r4,#0x74]
                  |L26.126|
;;;2256       }
;;;2257   
;;;2258       /* Call UART Error Call back function if need be --------------------------*/
;;;2259       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
00007e  6f62              LDR      r2,[r4,#0x74]
000080  2a00              CMP      r2,#0
000082  d032              BEQ      |L26.234|
;;;2260       {
;;;2261         /* UART in mode Receiver ---------------------------------------------------*/
;;;2262   #if defined(USART_CR1_FIFOEN)
;;;2263         if (((isrflags & USART_ISR_RXNE_RXFNE) != RESET)
;;;2264             && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != RESET)
;;;2265                 || ((cr3its & USART_CR3_RXFTIE) != RESET)))
;;;2266   #else
;;;2267         if (((isrflags & USART_ISR_RXNE) != RESET)
000084  0680              LSLS     r0,r0,#26
000086  d505              BPL      |L26.148|
;;;2268             && ((cr1its & USART_CR1_RXNEIE) != RESET))
000088  0688              LSLS     r0,r1,#26
00008a  d503              BPL      |L26.148|
;;;2269   #endif
;;;2270         {
;;;2271           if (huart->RxISR != NULL)
00008c  6e21              LDR      r1,[r4,#0x60]
00008e  b109              CBZ      r1,|L26.148|
;;;2272           {
;;;2273             huart->RxISR(huart);
000090  4620              MOV      r0,r4
000092  4788              BLX      r1
                  |L26.148|
;;;2274           }
;;;2275         }
;;;2276   
;;;2277         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2278            consider error as blocking */
;;;2279         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
000094  6f60              LDR      r0,[r4,#0x74]
000096  0700              LSLS     r0,r0,#28
000098  d403              BMI      |L26.162|
;;;2280             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
00009a  6820              LDR      r0,[r4,#0]
00009c  6880              LDR      r0,[r0,#8]
00009e  0640              LSLS     r0,r0,#25
0000a0  d525              BPL      |L26.238|
                  |L26.162|
;;;2281         {
;;;2282           /* Blocking error : transfer is aborted
;;;2283              Set the UART state ready to be able to start again the process,
;;;2284              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2285           UART_EndRxTransfer(huart);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       UART_EndRxTransfer
;;;2286   
;;;2287           /* Disable the UART DMA Rx request if enabled */
;;;2288           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6881              LDR      r1,[r0,#8]
0000ac  0649              LSLS     r1,r1,#25
0000ae  d519              BPL      |L26.228|
;;;2289           {
;;;2290             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000b0  6881              LDR      r1,[r0,#8]
0000b2  f0210140          BIC      r1,r1,#0x40
0000b6  6081              STR      r1,[r0,#8]
;;;2291   
;;;2292             /* Abort the UART DMA Rx channel */
;;;2293             if (huart->hdmarx != NULL)
0000b8  6ee0              LDR      r0,[r4,#0x6c]
0000ba  b198              CBZ      r0,|L26.228|
;;;2294             {
;;;2295               /* Set the UART DMA Abort callback :
;;;2296                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2297               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000bc  4920              LDR      r1,|L26.320|
;;;2298   
;;;2299               /* Abort DMA RX */
;;;2300               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000be  6381              STR      r1,[r0,#0x38]
0000c0  6ee0              LDR      r0,[r4,#0x6c]
0000c2  f7fffffe          BL       HAL_DMA_Abort_IT
0000c6  2800              CMP      r0,#0
0000c8  d00f              BEQ      |L26.234|
;;;2301               {
;;;2302                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2303                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000ca  6ee0              LDR      r0,[r4,#0x6c]
0000cc  6b81              LDR      r1,[r0,#0x38]
0000ce  e006              B        |L26.222|
                  |L26.208|
0000d0  0686              LSLS     r6,r0,#26             ;2195
0000d2  d511              BPL      |L26.248|
0000d4  068e              LSLS     r6,r1,#26             ;2196
0000d6  d50f              BPL      |L26.248|
0000d8  6e21              LDR      r1,[r4,#0x60]         ;2199
0000da  e01e              B        |L26.282|
                  |L26.220|
0000dc  4620              MOV      r0,r4                 ;2201
                  |L26.222|
;;;2304               }
;;;2305             }
;;;2306             else
;;;2307             {
;;;2308               /* Call user error callback */
;;;2309   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2310               /*Call registered error callback*/
;;;2311               huart->ErrorCallback(huart);
;;;2312   #else
;;;2313               /*Call legacy weak error callback*/
;;;2314               HAL_UART_ErrorCallback(huart);
;;;2315   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2316   
;;;2317             }
;;;2318           }
;;;2319           else
;;;2320           {
;;;2321             /* Call user error callback */
;;;2322   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2323             /*Call registered error callback*/
;;;2324             huart->ErrorCallback(huart);
;;;2325   #else
;;;2326             /*Call legacy weak error callback*/
;;;2327             HAL_UART_ErrorCallback(huart);
;;;2328   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2329           }
;;;2330         }
;;;2331         else
;;;2332         {
;;;2333           /* Non Blocking error : transfer could go on.
;;;2334              Error is notified to user through user error callback */
;;;2335   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2336           /*Call registered error callback*/
;;;2337           huart->ErrorCallback(huart);
;;;2338   #else
;;;2339           /*Call legacy weak error callback*/
;;;2340           HAL_UART_ErrorCallback(huart);
;;;2341   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2342           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2343         }
;;;2344       }
;;;2345       return;
;;;2346   
;;;2347     } /* End if some error occurs */
;;;2348   
;;;2349     /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
;;;2350     if (((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
;;;2351     {
;;;2352       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
;;;2353   
;;;2354       /* UART Rx state is not reset as a reception process might be ongoing.
;;;2355          If UART handle state fields need to be reset to READY, this could be done in Wakeup callback */
;;;2356   
;;;2357   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2358       /* Call registered Wakeup Callback */
;;;2359       huart->WakeupCallback(huart);
;;;2360   #else
;;;2361       /* Call legacy weak Wakeup Callback */
;;;2362       HAL_UARTEx_WakeupCallback(huart);
;;;2363   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2364       return;
;;;2365     }
;;;2366   
;;;2367     /* UART in mode Transmitter ------------------------------------------------*/
;;;2368   #if defined(USART_CR1_FIFOEN)
;;;2369     if (((isrflags & USART_ISR_TXE_TXFNF) != RESET)
;;;2370         && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != RESET)
;;;2371             || ((cr3its & USART_CR3_TXFTIE) != RESET)))
;;;2372   #else
;;;2373     if (((isrflags & USART_ISR_TXE) != RESET)
;;;2374         && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2375   #endif
;;;2376     {
;;;2377       if (huart->TxISR != NULL)
;;;2378       {
;;;2379         huart->TxISR(huart);
0000de  e8bd41f0          POP      {r4-r8,lr}
0000e2  4708              BX       r1
                  |L26.228|
0000e4  4620              MOV      r0,r4                 ;2327
0000e6  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L26.234|
;;;2380       }
;;;2381       return;
;;;2382     }
;;;2383   
;;;2384     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;2385     if (((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2386     {
;;;2387       UART_EndTransmit_IT(huart);
;;;2388       return;
;;;2389     }
;;;2390   
;;;2391   #if defined(USART_CR1_FIFOEN)
;;;2392     /* UART TX Fifo Empty occurred ----------------------------------------------*/
;;;2393     if (((isrflags & USART_ISR_TXFE) != RESET) && ((cr1its & USART_CR1_TXFEIE) != RESET))
;;;2394     {
;;;2395   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2396       /* Call registered Tx Fifo Empty Callback */
;;;2397       huart->TxFifoEmptyCallback(huart);
;;;2398   #else
;;;2399       /* Call legacy weak Tx Fifo Empty Callback */
;;;2400       HAL_UARTEx_TxFifoEmptyCallback(huart);
;;;2401   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2402       return;
;;;2403     }
;;;2404   
;;;2405     /* UART RX Fifo Full occurred ----------------------------------------------*/
;;;2406     if (((isrflags & USART_ISR_RXFF) != RESET) && ((cr1its & USART_CR1_RXFFIE) != RESET))
;;;2407     {
;;;2408   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2409       /* Call registered Rx Fifo Full Callback */
;;;2410       huart->RxFifoFullCallback(huart);
;;;2411   #else
;;;2412       /* Call legacy weak Rx Fifo Full Callback */
;;;2413       HAL_UARTEx_RxFifoFullCallback(huart);
;;;2414   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2415       return;
;;;2416     }
;;;2417   #endif
;;;2418   }
0000ea  e8bd81f0          POP      {r4-r8,pc}
                  |L26.238|
0000ee  4620              MOV      r0,r4                 ;2340
0000f0  f7fffffe          BL       HAL_UART_ErrorCallback
0000f4  6765              STR      r5,[r4,#0x74]         ;2342
0000f6  e7f8              B        |L26.234|
                  |L26.248|
0000f8  02c6              LSLS     r6,r0,#11             ;2350
0000fa  d509              BPL      |L26.272|
0000fc  025b              LSLS     r3,r3,#9              ;2350
0000fe  d507              BPL      |L26.272|
000100  f44f1080          MOV      r0,#0x100000          ;2352
000104  6210              STR      r0,[r2,#0x20]         ;2352
000106  4620              MOV      r0,r4                 ;2362
000108  e8bd41f0          POP      {r4-r8,lr}            ;2362
00010c  f7ffbffe          B.W      HAL_UARTEx_WakeupCallback
                  |L26.272|
000110  0603              LSLS     r3,r0,#24             ;2373
000112  d505              BPL      |L26.288|
000114  060b              LSLS     r3,r1,#24             ;2374
000116  d503              BPL      |L26.288|
000118  6e61              LDR      r1,[r4,#0x64]         ;2377
                  |L26.282|
00011a  2900              CMP      r1,#0                 ;2377
00011c  d1de              BNE      |L26.220|
00011e  e7e4              B        |L26.234|
                  |L26.288|
000120  0640              LSLS     r0,r0,#25             ;2385
000122  d5e2              BPL      |L26.234|
000124  0648              LSLS     r0,r1,#25             ;2385
000126  d5e0              BPL      |L26.234|
000128  6811              LDR      r1,[r2,#0]            ;2385
00012a  4620              MOV      r0,r4                 ;2387
00012c  f0210140          BIC      r1,r1,#0x40           ;2387
000130  6011              STR      r1,[r2,#0]            ;2387
000132  2120              MOVS     r1,#0x20              ;2387
000134  f8841071          STRB     r1,[r4,#0x71]         ;2387
000138  6665              STR      r5,[r4,#0x64]         ;2387
00013a  f7fffffe          BL       HAL_UART_TxCpltCallback
00013e  e7d4              B        |L26.234|
;;;2419   
                          ENDP

                  |L26.320|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;326      */
;;;327    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;328    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L27.14|
;;;329      /* Check the UART handle allocation */
;;;330      if (huart == NULL)
;;;331      {
;;;332        return HAL_ERROR;
;;;333      }
;;;334    
;;;335      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;336      {
;;;337        /* Check the parameters */
;;;338        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;339      }
;;;340      else
;;;341      {
;;;342        /* Check the parameters */
;;;343        assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
;;;344      }
;;;345    
;;;346      if (huart->gState == HAL_UART_STATE_RESET)
000006  f8940071          LDRB     r0,[r4,#0x71]
00000a  b110              CBZ      r0,|L27.18|
00000c  e007              B        |L27.30|
                  |L27.14|
00000e  2001              MOVS     r0,#1                 ;332
                  |L27.16|
;;;347      {
;;;348        /* Allocate lock resource and initialize it */
;;;349        huart->Lock = HAL_UNLOCKED;
;;;350    
;;;351    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;352        UART_InitCallbacksToDefault(huart);
;;;353    
;;;354        if (huart->MspInitCallback == NULL)
;;;355        {
;;;356          huart->MspInitCallback = HAL_UART_MspInit;
;;;357        }
;;;358    
;;;359        /* Init the low level hardware */
;;;360        huart->MspInitCallback(huart);
;;;361    #else
;;;362        /* Init the low level hardware : GPIO, CLOCK */
;;;363        HAL_UART_MspInit(huart);
;;;364    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;365      }
;;;366    
;;;367      huart->gState = HAL_UART_STATE_BUSY;
;;;368    
;;;369      /* Disable the Peripheral */
;;;370      __HAL_UART_DISABLE(huart);
;;;371    
;;;372      /* Set the UART Communication parameters */
;;;373      if (UART_SetConfig(huart) == HAL_ERROR)
;;;374      {
;;;375        return HAL_ERROR;
;;;376      }
;;;377    
;;;378      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;379      {
;;;380        UART_AdvFeatureConfig(huart);
;;;381      }
;;;382    
;;;383      /* In asynchronous mode, the following bits must be kept cleared:
;;;384      - LINEN and CLKEN bits in the USART_CR2 register,
;;;385      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;386      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;387      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;388    
;;;389      /* Enable the Peripheral */
;;;390      __HAL_UART_ENABLE(huart);
;;;391    
;;;392      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;393      return (UART_CheckIdleState(huart));
;;;394    }
000010  bd10              POP      {r4,pc}
                  |L27.18|
000012  2000              MOVS     r0,#0                 ;349
000014  f8840070          STRB     r0,[r4,#0x70]         ;349
000018  4620              MOV      r0,r4                 ;363
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L27.30|
00001e  2024              MOVS     r0,#0x24              ;367
000020  f8840071          STRB     r0,[r4,#0x71]         ;367
000024  6820              LDR      r0,[r4,#0]            ;370
000026  6801              LDR      r1,[r0,#0]            ;370
000028  f0210101          BIC      r1,r1,#1              ;370
00002c  6001              STR      r1,[r0,#0]            ;370
00002e  4620              MOV      r0,r4                 ;373
000030  f7fffffe          BL       UART_SetConfig
000034  2801              CMP      r0,#1                 ;373
000036  d0eb              BEQ      |L27.16|
000038  6a60              LDR      r0,[r4,#0x24]         ;378
00003a  b110              CBZ      r0,|L27.66|
00003c  4620              MOV      r0,r4                 ;380
00003e  f7fffffe          BL       UART_AdvFeatureConfig
                  |L27.66|
000042  6820              LDR      r0,[r4,#0]            ;386
000044  6841              LDR      r1,[r0,#4]            ;386
000046  f4214190          BIC      r1,r1,#0x4800         ;386
00004a  6041              STR      r1,[r0,#4]            ;386
00004c  6820              LDR      r0,[r4,#0]            ;387
00004e  6881              LDR      r1,[r0,#8]            ;387
000050  f021012a          BIC      r1,r1,#0x2a           ;387
000054  6081              STR      r1,[r0,#8]            ;387
000056  6820              LDR      r0,[r4,#0]            ;390
000058  6801              LDR      r1,[r0,#0]            ;390
00005a  f0410101          ORR      r1,r1,#1              ;390
00005e  6001              STR      r1,[r0,#0]            ;390
000060  4620              MOV      r0,r4                 ;393
000062  e8bd4010          POP      {r4,lr}               ;393
000066  f7ffbffe          B.W      UART_CheckIdleState
;;;395    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;713      */
;;;714    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;715    {
;;;716      /* Prevent unused argument(s) compilation warning */
;;;717      UNUSED(huart);
;;;718    
;;;719      /* NOTE : This function should not be modified, when the callback is needed,
;;;720                the HAL_UART_MspDeInit can be implemented in the user file
;;;721       */
;;;722    }
;;;723    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;698      */
;;;699    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;700    {
;;;701      /* Prevent unused argument(s) compilation warning */
;;;702      UNUSED(huart);
;;;703    
;;;704      /* NOTE : This function should not be modified, when the callback is needed,
;;;705                the HAL_UART_MspInit can be implemented in the user file
;;;706       */
;;;707    }
;;;708    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1163     */
;;;1164   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1165   {
000004  4604              MOV      r4,r0
;;;1166     uint16_t *tmp;
;;;1167     uint16_t uhMask;
;;;1168     uint32_t tickstart = 0;
;;;1169   
;;;1170     /* Check that a Rx process is not already ongoing */
;;;1171     if (huart->RxState == HAL_UART_STATE_READY)
000006  f8900072          LDRB     r0,[r0,#0x72]
00000a  4698              MOV      r8,r3                 ;1165
00000c  4616              MOV      r6,r2                 ;1165
00000e  460d              MOV      r5,r1                 ;1165
000010  2820              CMP      r0,#0x20
000012  d167              BNE      |L30.228|
;;;1172     {
;;;1173       if ((pData == NULL) || (Size == 0U))
000014  b1fd              CBZ      r5,|L30.86|
000016  b1f6              CBZ      r6,|L30.86|
;;;1174       {
;;;1175         return  HAL_ERROR;
;;;1176       }
;;;1177   
;;;1178       /* Process Locked */
;;;1179       __HAL_LOCK(huart);
000018  f8940070          LDRB     r0,[r4,#0x70]
00001c  2801              CMP      r0,#1
00001e  d061              BEQ      |L30.228|
000020  2001              MOVS     r0,#1
000022  f8840070          STRB     r0,[r4,#0x70]
;;;1180   
;;;1181       huart->ErrorCode = HAL_UART_ERROR_NONE;
000026  f04f0900          MOV      r9,#0
00002a  f8c49074          STR      r9,[r4,#0x74]
;;;1182       huart->RxState = HAL_UART_STATE_BUSY_RX;
00002e  2022              MOVS     r0,#0x22
000030  f8840072          STRB     r0,[r4,#0x72]
000034  3454              ADDS     r4,r4,#0x54
;;;1183   
;;;1184       /* Init tickstart for timeout managment*/
;;;1185       tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
;;;1186   
;;;1187       huart->RxXferSize  = Size;
00003a  80a6              STRH     r6,[r4,#4]
00003c  4682              MOV      r10,r0                ;1185
;;;1188       huart->RxXferCount = Size;
00003e  80e6              STRH     r6,[r4,#6]
;;;1189   
;;;1190       /* Computation of UART mask to apply to RDR register */
;;;1191       UART_MASK_COMPUTATION(huart);
000040  f8540c4c          LDR      r0,[r4,#-0x4c]
000044  f44f5780          MOV      r7,#0x1000
000048  21ff              MOVS     r1,#0xff
00004a  3c54              SUBS     r4,r4,#0x54
00004c  42b8              CMP      r0,r7
00004e  d108              BNE      |L30.98|
000050  6920              LDR      r0,[r4,#0x10]
000052  b118              CBZ      r0,|L30.92|
000054  e00d              B        |L30.114|
                  |L30.86|
000056  2001              MOVS     r0,#1                 ;1175
                  |L30.88|
;;;1192       uhMask = huart->Mask;
;;;1193   
;;;1194       /* as long as data have to be received */
;;;1195       while (huart->RxXferCount > 0U)
;;;1196       {
;;;1197         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1198         {
;;;1199           return HAL_TIMEOUT;
;;;1200         }
;;;1201         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1202         {
;;;1203           tmp = (uint16_t *) pData ;
;;;1204           *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;1205           pData += 2U;
;;;1206         }
;;;1207         else
;;;1208         {
;;;1209           *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;1210         }
;;;1211         huart->RxXferCount--;
;;;1212       }
;;;1213   
;;;1214       /* At end of Rx process, restore huart->RxState to Ready */
;;;1215       huart->RxState = HAL_UART_STATE_READY;
;;;1216   
;;;1217       /* Process Unlocked */
;;;1218       __HAL_UNLOCK(huart);
;;;1219   
;;;1220       return HAL_OK;
;;;1221     }
;;;1222     else
;;;1223     {
;;;1224       return HAL_BUSY;
;;;1225     }
;;;1226   }
000058  e8bd8ff8          POP      {r3-r11,pc}
                  |L30.92|
00005c  f24010ff          MOV      r0,#0x1ff             ;1191
000060  e00d              B        |L30.126|
                  |L30.98|
000062  227f              MOVS     r2,#0x7f              ;1191
000064  b118              CBZ      r0,|L30.110|
000066  f1b05f80          CMP      r0,#0x10000000        ;1191
00006a  d005              BEQ      |L30.120|
00006c  e009              B        |L30.130|
                  |L30.110|
00006e  6920              LDR      r0,[r4,#0x10]         ;1191
000070  b950              CBNZ     r0,|L30.136|
                  |L30.114|
000072  f8a4105c          STRH     r1,[r4,#0x5c]         ;1191
000076  e004              B        |L30.130|
                  |L30.120|
000078  6920              LDR      r0,[r4,#0x10]         ;1191
00007a  b128              CBZ      r0,|L30.136|
00007c  203f              MOVS     r0,#0x3f              ;1191
                  |L30.126|
00007e  f8a4005c          STRH     r0,[r4,#0x5c]         ;1191
                  |L30.130|
000082  f8b4605c          LDRH     r6,[r4,#0x5c]         ;1192
000086  e01c              B        |L30.194|
                  |L30.136|
000088  f8a4205c          STRH     r2,[r4,#0x5c]         ;1191
00008c  e7f9              B        |L30.130|
                  |L30.142|
00008e  4653              MOV      r3,r10                ;1197
000090  2200              MOVS     r2,#0                 ;1197
000092  2120              MOVS     r1,#0x20              ;1197
000094  4620              MOV      r0,r4                 ;1197
000096  f8cd8000          STR      r8,[sp,#0]            ;1197
00009a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00009e  b108              CBZ      r0,|L30.164|
0000a0  2003              MOVS     r0,#3                 ;1199
0000a2  e7d9              B        |L30.88|
                  |L30.164|
0000a4  68a0              LDR      r0,[r4,#8]            ;1201
0000a6  42b8              CMP      r0,r7                 ;1201
0000a8  d101              BNE      |L30.174|
0000aa  6920              LDR      r0,[r4,#0x10]         ;1201
0000ac  b1a0              CBZ      r0,|L30.216|
                  |L30.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1209
0000b0  8c80              LDRH     r0,[r0,#0x24]         ;1209
0000b2  4030              ANDS     r0,r0,r6              ;1209
0000b4  f8050b01          STRB     r0,[r5],#1            ;1209
                  |L30.184|
0000b8  f8b4005a          LDRH     r0,[r4,#0x5a]         ;1211
0000bc  1e40              SUBS     r0,r0,#1              ;1211
0000be  f8a4005a          STRH     r0,[r4,#0x5a]         ;1211
                  |L30.194|
0000c2  f8b4005a          LDRH     r0,[r4,#0x5a]         ;1195
0000c6  2800              CMP      r0,#0                 ;1195
0000c8  d1e1              BNE      |L30.142|
0000ca  2020              MOVS     r0,#0x20              ;1215
0000cc  f8840072          STRB     r0,[r4,#0x72]         ;1215
0000d0  f8849070          STRB     r9,[r4,#0x70]         ;1218
0000d4  2000              MOVS     r0,#0                 ;1220
0000d6  e7bf              B        |L30.88|
                  |L30.216|
0000d8  6820              LDR      r0,[r4,#0]            ;1204
0000da  8c80              LDRH     r0,[r0,#0x24]         ;1204
0000dc  4030              ANDS     r0,r0,r6              ;1204
0000de  f8250b02          STRH     r0,[r5],#2            ;1204
0000e2  e7e9              B        |L30.184|
                  |L30.228|
0000e4  2002              MOVS     r0,#2                 ;1224
0000e6  e7b7              B        |L30.88|
;;;1227   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1463     */
;;;1464   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1465   {
000002  4604              MOV      r4,r0
;;;1466     /* Check that a Rx process is not already ongoing */
;;;1467     if (huart->RxState == HAL_UART_STATE_READY)
000004  f8900072          LDRB     r0,[r0,#0x72]
000008  2820              CMP      r0,#0x20
00000a  d13a              BNE      |L31.130|
;;;1468     {
;;;1469       if ((pData == NULL) || (Size == 0U))
00000c  b3b1              CBZ      r1,|L31.124|
00000e  b3aa              CBZ      r2,|L31.124|
;;;1470       {
;;;1471         return HAL_ERROR;
;;;1472       }
;;;1473   
;;;1474       /* Process Locked */
;;;1475       __HAL_LOCK(huart);
000010  f8940070          LDRB     r0,[r4,#0x70]
000014  2801              CMP      r0,#1
000016  d034              BEQ      |L31.130|
000018  2001              MOVS     r0,#1
00001a  f8840070          STRB     r0,[r4,#0x70]
;;;1476   
;;;1477       huart->pRxBuffPtr = pData;
;;;1478       huart->RxXferSize = Size;
00001e  6561              STR      r1,[r4,#0x54]
000020  f8a42058          STRH     r2,[r4,#0x58]
;;;1479   
;;;1480       huart->ErrorCode = HAL_UART_ERROR_NONE;
000024  2500              MOVS     r5,#0
000026  6765              STR      r5,[r4,#0x74]
;;;1481       huart->RxState = HAL_UART_STATE_BUSY_RX;
000028  2022              MOVS     r0,#0x22
00002a  f8840072          STRB     r0,[r4,#0x72]
;;;1482   
;;;1483       /* Set the UART DMA transfer complete callback */
;;;1484       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
00002e  6ee1              LDR      r1,[r4,#0x6c]
000030  4815              LDR      r0,|L31.136|
;;;1485   
;;;1486       /* Set the UART DMA Half transfer complete callback */
;;;1487       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1488   
;;;1489       /* Set the DMA error callback */
;;;1490       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1491   
;;;1492       /* Set the DMA abort callback */
;;;1493       huart->hdmarx->XferAbortCallback = NULL;
;;;1494   
;;;1495       /* Enable the DMA channel */
;;;1496       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size);
000032  4613              MOV      r3,r2
000034  62c8              STR      r0,[r1,#0x2c]         ;1487
000036  6ee1              LDR      r1,[r4,#0x6c]         ;1487
000038  4814              LDR      r0,|L31.140|
00003a  6308              STR      r0,[r1,#0x30]         ;1490
00003c  6ee1              LDR      r1,[r4,#0x6c]         ;1490
00003e  4814              LDR      r0,|L31.144|
000040  6348              STR      r0,[r1,#0x34]         ;1493
000042  6ee0              LDR      r0,[r4,#0x6c]         ;1493
000044  6385              STR      r5,[r0,#0x38]
000046  6d60              LDR      r0,[r4,#0x54]
000048  6ee6              LDR      r6,[r4,#0x6c]
00004a  6821              LDR      r1,[r4,#0]
00004c  4602              MOV      r2,r0
00004e  4630              MOV      r0,r6
000050  3124              ADDS     r1,r1,#0x24
000052  f7fffffe          BL       HAL_DMA_Start_IT
;;;1497   
;;;1498       /* Process Unlocked */
;;;1499       __HAL_UNLOCK(huart);
000056  f8845070          STRB     r5,[r4,#0x70]
;;;1500   
;;;1501       /* Enable the UART Parity Error Interrupt */
;;;1502       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
00005a  6820              LDR      r0,[r4,#0]
00005c  6801              LDR      r1,[r0,#0]
00005e  f4417180          ORR      r1,r1,#0x100
000062  6001              STR      r1,[r0,#0]
;;;1503   
;;;1504       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1505       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
000064  6820              LDR      r0,[r4,#0]
000066  6881              LDR      r1,[r0,#8]
000068  f0410101          ORR      r1,r1,#1
00006c  6081              STR      r1,[r0,#8]
;;;1506   
;;;1507       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1508       in the UART CR3 register */
;;;1509       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00006e  6820              LDR      r0,[r4,#0]
000070  6881              LDR      r1,[r0,#8]
000072  f0410140          ORR      r1,r1,#0x40
000076  6081              STR      r1,[r0,#8]
;;;1510   
;;;1511       return HAL_OK;
000078  2000              MOVS     r0,#0
                  |L31.122|
;;;1512     }
;;;1513     else
;;;1514     {
;;;1515       return HAL_BUSY;
;;;1516     }
;;;1517   }
00007a  bd70              POP      {r4-r6,pc}
                  |L31.124|
00007c  e7ff              B        |L31.126|
                  |L31.126|
00007e  2001              MOVS     r0,#1                 ;1471
000080  e7fb              B        |L31.122|
                  |L31.130|
000082  2002              MOVS     r0,#2                 ;1515
000084  e7f9              B        |L31.122|
;;;1518   
                          ENDP

000086  0000              DCW      0x0000
                  |L31.136|
                          DCD      UART_DMAReceiveCplt
                  |L31.140|
                          DCD      UART_DMARxHalfCplt
                  |L31.144|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_IT PROC
;;;1314     */
;;;1315   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;1316   {
;;;1317     /* Check that a Rx process is not already ongoing */
;;;1318     if (huart->RxState == HAL_UART_STATE_READY)
000002  f8903072          LDRB     r3,[r0,#0x72]
000006  2b20              CMP      r3,#0x20
000008  d14a              BNE      |L32.160|
;;;1319     {
;;;1320       if ((pData == NULL) || (Size == 0U))
00000a  b1b1              CBZ      r1,|L32.58|
00000c  b1aa              CBZ      r2,|L32.58|
;;;1321       {
;;;1322         return HAL_ERROR;
;;;1323       }
;;;1324   
;;;1325       /* Process Locked */
;;;1326       __HAL_LOCK(huart);
00000e  f8903070          LDRB     r3,[r0,#0x70]
000012  2b01              CMP      r3,#1
000014  d044              BEQ      |L32.160|
000016  2301              MOVS     r3,#1
000018  f8803070          STRB     r3,[r0,#0x70]
;;;1327   
;;;1328       huart->pRxBuffPtr  = pData;
;;;1329       huart->RxXferSize  = Size;
00001c  6541              STR      r1,[r0,#0x54]
00001e  f8a02058          STRH     r2,[r0,#0x58]
;;;1330       huart->RxXferCount = Size;
000022  f8a0205a          STRH     r2,[r0,#0x5a]
;;;1331       huart->RxISR       = NULL;
000026  2200              MOVS     r2,#0
;;;1332   
;;;1333       /* Computation of UART mask to apply to RDR register */
;;;1334       UART_MASK_COMPUTATION(huart);
000028  6602              STR      r2,[r0,#0x60]
00002a  031d              LSLS     r5,r3,#12
00002c  6881              LDR      r1,[r0,#8]
00002e  23ff              MOVS     r3,#0xff
000030  42a9              CMP      r1,r5
000032  d107              BNE      |L32.68|
000034  6901              LDR      r1,[r0,#0x10]
000036  b111              CBZ      r1,|L32.62|
000038  e00c              B        |L32.84|
                  |L32.58|
00003a  2001              MOVS     r0,#1                 ;1322
;;;1335   
;;;1336       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1337       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1338   
;;;1339       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1340       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1341   
;;;1342   #if defined(USART_CR1_FIFOEN)
;;;1343       /* Configure Rx interrupt processing*/
;;;1344       if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
;;;1345       {
;;;1346         /* Set the Rx ISR function pointer according to the data word length */
;;;1347         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1348         {
;;;1349           huart->RxISR = UART_RxISR_16BIT_FIFOEN;
;;;1350         }
;;;1351         else
;;;1352         {
;;;1353           huart->RxISR = UART_RxISR_8BIT_FIFOEN;
;;;1354         }
;;;1355   
;;;1356         /* Process Unlocked */
;;;1357         __HAL_UNLOCK(huart);
;;;1358   
;;;1359         /* Enable the UART Parity Error interrupt and RX FIFO Threshold interrupt */
;;;1360         SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1361         SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
;;;1362       }
;;;1363       else
;;;1364   #endif
;;;1365       {
;;;1366         /* Set the Rx ISR function pointer according to the data word length */
;;;1367         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1368         {
;;;1369           huart->RxISR = UART_RxISR_16BIT;
;;;1370         }
;;;1371         else
;;;1372         {
;;;1373           huart->RxISR = UART_RxISR_8BIT;
;;;1374         }
;;;1375   
;;;1376         /* Process Unlocked */
;;;1377         __HAL_UNLOCK(huart);
;;;1378   
;;;1379         /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
;;;1380   #if defined(USART_CR1_FIFOEN)
;;;1381         SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
;;;1382   #else
;;;1383         SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;1384   #endif
;;;1385       }
;;;1386   
;;;1387       return HAL_OK;
;;;1388     }
;;;1389     else
;;;1390     {
;;;1391       return HAL_BUSY;
;;;1392     }
;;;1393   }
00003c  bd30              POP      {r4,r5,pc}
                  |L32.62|
00003e  f24011ff          MOV      r1,#0x1ff             ;1334
000042  e00d              B        |L32.96|
                  |L32.68|
000044  247f              MOVS     r4,#0x7f              ;1334
000046  b119              CBZ      r1,|L32.80|
000048  f1b15f80          CMP      r1,#0x10000000        ;1334
00004c  d005              BEQ      |L32.90|
00004e  e009              B        |L32.100|
                  |L32.80|
000050  6901              LDR      r1,[r0,#0x10]         ;1334
000052  bb01              CBNZ     r1,|L32.150|
                  |L32.84|
000054  f8a0305c          STRH     r3,[r0,#0x5c]         ;1334
000058  e004              B        |L32.100|
                  |L32.90|
00005a  6901              LDR      r1,[r0,#0x10]         ;1334
00005c  b1d9              CBZ      r1,|L32.150|
00005e  213f              MOVS     r1,#0x3f              ;1334
                  |L32.96|
000060  f8a0105c          STRH     r1,[r0,#0x5c]         ;1334
                  |L32.100|
000064  6742              STR      r2,[r0,#0x74]         ;1336
000066  2122              MOVS     r1,#0x22              ;1337
000068  f8801072          STRB     r1,[r0,#0x72]         ;1337
00006c  6801              LDR      r1,[r0,#0]            ;1340
00006e  688b              LDR      r3,[r1,#8]            ;1340
000070  f0430301          ORR      r3,r3,#1              ;1340
000074  608b              STR      r3,[r1,#8]            ;1340
000076  6881              LDR      r1,[r0,#8]            ;1367
000078  42a9              CMP      r1,r5                 ;1367
00007a  d101              BNE      |L32.128|
00007c  6901              LDR      r1,[r0,#0x10]         ;1367
00007e  b169              CBZ      r1,|L32.156|
                  |L32.128|
000080  4908              LDR      r1,|L32.164|
                  |L32.130|
000082  6601              STR      r1,[r0,#0x60]         ;1377
000084  f8802070          STRB     r2,[r0,#0x70]         ;1377
000088  6800              LDR      r0,[r0,#0]            ;1383
00008a  6801              LDR      r1,[r0,#0]            ;1383
00008c  f4417190          ORR      r1,r1,#0x120          ;1383
000090  6001              STR      r1,[r0,#0]            ;1383
000092  2000              MOVS     r0,#0                 ;1387
000094  bd30              POP      {r4,r5,pc}
                  |L32.150|
000096  f8a0405c          STRH     r4,[r0,#0x5c]         ;1334
00009a  e7e3              B        |L32.100|
                  |L32.156|
00009c  4902              LDR      r1,|L32.168|
00009e  e7f0              B        |L32.130|
                  |L32.160|
0000a0  2002              MOVS     r0,#2                 ;1391
0000a2  bd30              POP      {r4,r5,pc}
;;;1394   
                          ENDP

                  |L32.164|
                          DCD      UART_RxISR_8BIT
                  |L32.168|
                          DCD      UART_RxISR_16BIT

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2454     */
;;;2455   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2456   {
;;;2457     /* Prevent unused argument(s) compilation warning */
;;;2458     UNUSED(huart);
;;;2459   
;;;2460     /* NOTE : This function should not be modified, when the callback is needed,
;;;2461               the HAL_UART_RxCpltCallback can be implemented in the user file.
;;;2462      */
;;;2463   }
;;;2464   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2469     */
;;;2470   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2471   {
;;;2472     /* Prevent unused argument(s) compilation warning */
;;;2473     UNUSED(huart);
;;;2474   
;;;2475     /* NOTE: This function should not be modified, when the callback is needed,
;;;2476              the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
;;;2477      */
;;;2478   }
;;;2479   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1088     */
;;;1089   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1090   {
000004  4604              MOV      r4,r0
;;;1091     uint16_t *tmp;
;;;1092     uint32_t tickstart = 0U;
;;;1093   
;;;1094     /* Check that a Tx process is not already ongoing */
;;;1095     if (huart->gState == HAL_UART_STATE_READY)
000006  f8900071          LDRB     r0,[r0,#0x71]
00000a  461e              MOV      r6,r3                 ;1090
00000c  4617              MOV      r7,r2                 ;1090
00000e  460d              MOV      r5,r1                 ;1090
000010  2820              CMP      r0,#0x20
000012  d14b              BNE      |L35.172|
;;;1096     {
;;;1097       if ((pData == NULL) || (Size == 0U))
000014  b1c5              CBZ      r5,|L35.72|
000016  b1bf              CBZ      r7,|L35.72|
;;;1098       {
;;;1099         return  HAL_ERROR;
;;;1100       }
;;;1101   
;;;1102       /* Process Locked */
;;;1103       __HAL_LOCK(huart);
000018  f8940070          LDRB     r0,[r4,#0x70]
00001c  2801              CMP      r0,#1
00001e  d045              BEQ      |L35.172|
000020  2001              MOVS     r0,#1
000022  f8840070          STRB     r0,[r4,#0x70]
;;;1104   
;;;1105       huart->ErrorCode = HAL_UART_ERROR_NONE;
000026  f04f0800          MOV      r8,#0
00002a  f8c48074          STR      r8,[r4,#0x74]
;;;1106       huart->gState = HAL_UART_STATE_BUSY_TX;
00002e  2021              MOVS     r0,#0x21
000030  f8840071          STRB     r0,[r4,#0x71]
;;;1107   
;;;1108       /* Init tickstart for timeout managment*/
;;;1109       tickstart = HAL_GetTick();
000034  f7fffffe          BL       HAL_GetTick
;;;1110   
;;;1111       huart->TxXferSize  = Size;
000038  f8a47050          STRH     r7,[r4,#0x50]
00003c  4681              MOV      r9,r0                 ;1109
;;;1112       huart->TxXferCount = Size;
00003e  f8a47052          STRH     r7,[r4,#0x52]
;;;1113   
;;;1114       while (huart->TxXferCount > 0U)
;;;1115       {
;;;1116         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1117         {
;;;1118           return HAL_TIMEOUT;
;;;1119         }
;;;1120         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000042  f44f5780          MOV      r7,#0x1000
000046  e015              B        |L35.116|
                  |L35.72|
000048  2001              MOVS     r0,#1                 ;1099
                  |L35.74|
;;;1121         {
;;;1122           tmp = (uint16_t *) pData;
;;;1123           huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;1124           pData += 2U;
;;;1125         }
;;;1126         else
;;;1127         {
;;;1128           huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;1129         }
;;;1130         huart->TxXferCount--;
;;;1131       }
;;;1132   
;;;1133       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1134       {
;;;1135         return HAL_TIMEOUT;
;;;1136       }
;;;1137   
;;;1138       /* At end of Tx process, restore huart->gState to Ready */
;;;1139       huart->gState = HAL_UART_STATE_READY;
;;;1140   
;;;1141       /* Process Unlocked */
;;;1142       __HAL_UNLOCK(huart);
;;;1143   
;;;1144       return HAL_OK;
;;;1145     }
;;;1146     else
;;;1147     {
;;;1148       return HAL_BUSY;
;;;1149     }
;;;1150   }
00004a  e8bd83f8          POP      {r3-r9,pc}
                  |L35.78|
00004e  2180              MOVS     r1,#0x80              ;1116
000050  4620              MOV      r0,r4                 ;1116
000052  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000056  b9d8              CBNZ     r0,|L35.144|
000058  68a0              LDR      r0,[r4,#8]            ;1120
00005a  42b8              CMP      r0,r7                 ;1120
00005c  d101              BNE      |L35.98|
00005e  6920              LDR      r0,[r4,#0x10]         ;1120
000060  b1c0              CBZ      r0,|L35.148|
                  |L35.98|
000062  f8150b01          LDRB     r0,[r5],#1            ;1128
                  |L35.102|
000066  6821              LDR      r1,[r4,#0]            ;1128
000068  8508              STRH     r0,[r1,#0x28]         ;1128
00006a  f8b40052          LDRH     r0,[r4,#0x52]         ;1130
00006e  1e40              SUBS     r0,r0,#1              ;1130
000070  f8a40052          STRH     r0,[r4,#0x52]         ;1130
                  |L35.116|
000074  f8b40052          LDRH     r0,[r4,#0x52]         ;1114
000078  464b              MOV      r3,r9                 ;1133
00007a  f04f0200          MOV      r2,#0                 ;1133
00007e  9600              STR      r6,[sp,#0]            ;1114
000080  2800              CMP      r0,#0                 ;1114
000082  d1e4              BNE      |L35.78|
000084  f04f0140          MOV      r1,#0x40              ;1133
000088  4620              MOV      r0,r4                 ;1133
00008a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00008e  b130              CBZ      r0,|L35.158|
                  |L35.144|
000090  2003              MOVS     r0,#3                 ;1135
000092  e7da              B        |L35.74|
                  |L35.148|
000094  f8350b02          LDRH     r0,[r5],#2            ;1123
000098  f3c00008          UBFX     r0,r0,#0,#9           ;1123
00009c  e7e3              B        |L35.102|
                  |L35.158|
00009e  2020              MOVS     r0,#0x20              ;1139
0000a0  f8840071          STRB     r0,[r4,#0x71]         ;1139
0000a4  f8848070          STRB     r8,[r4,#0x70]         ;1142
0000a8  2000              MOVS     r0,#0                 ;1144
0000aa  e7ce              B        |L35.74|
                  |L35.172|
0000ac  2002              MOVS     r0,#2                 ;1148
0000ae  e7cc              B        |L35.74|
;;;1151   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1401     */
;;;1402   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1403   {
000002  4604              MOV      r4,r0
;;;1404     /* Check that a Tx process is not already ongoing */
;;;1405     if (huart->gState == HAL_UART_STATE_READY)
000004  f8900071          LDRB     r0,[r0,#0x71]
000008  2820              CMP      r0,#0x20
00000a  d134              BNE      |L36.118|
;;;1406     {
;;;1407       if ((pData == NULL) || (Size == 0U))
00000c  b381              CBZ      r1,|L36.112|
00000e  b37a              CBZ      r2,|L36.112|
;;;1408       {
;;;1409         return HAL_ERROR;
;;;1410       }
;;;1411   
;;;1412       /* Process Locked */
;;;1413       __HAL_LOCK(huart);
000010  f8940070          LDRB     r0,[r4,#0x70]
000014  2801              CMP      r0,#1
000016  d02e              BEQ      |L36.118|
000018  2001              MOVS     r0,#1
00001a  f8840070          STRB     r0,[r4,#0x70]
;;;1414   
;;;1415       huart->pTxBuffPtr  = pData;
;;;1416       huart->TxXferSize  = Size;
00001e  64e1              STR      r1,[r4,#0x4c]
000020  f8a42050          STRH     r2,[r4,#0x50]
;;;1417       huart->TxXferCount = Size;
000024  f8a42052          STRH     r2,[r4,#0x52]
;;;1418   
;;;1419       huart->ErrorCode = HAL_UART_ERROR_NONE;
000028  2500              MOVS     r5,#0
00002a  6765              STR      r5,[r4,#0x74]
;;;1420       huart->gState = HAL_UART_STATE_BUSY_TX;
00002c  2021              MOVS     r0,#0x21
00002e  f8840071          STRB     r0,[r4,#0x71]
;;;1421   
;;;1422       /* Set the UART DMA transfer complete callback */
;;;1423       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
000032  6ea1              LDR      r1,[r4,#0x68]
000034  4811              LDR      r0,|L36.124|
;;;1424   
;;;1425       /* Set the UART DMA Half transfer complete callback */
;;;1426       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1427   
;;;1428       /* Set the DMA error callback */
;;;1429       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1430   
;;;1431       /* Set the DMA abort callback */
;;;1432       huart->hdmatx->XferAbortCallback = NULL;
;;;1433   
;;;1434       /* Enable the UART transmit DMA channel */
;;;1435       HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size);
000036  4613              MOV      r3,r2
000038  62c8              STR      r0,[r1,#0x2c]         ;1426
00003a  6ea1              LDR      r1,[r4,#0x68]         ;1426
00003c  4810              LDR      r0,|L36.128|
00003e  6308              STR      r0,[r1,#0x30]         ;1429
000040  6ea1              LDR      r1,[r4,#0x68]         ;1429
000042  4810              LDR      r0,|L36.132|
000044  6348              STR      r0,[r1,#0x34]         ;1432
000046  6ea0              LDR      r0,[r4,#0x68]         ;1432
000048  6385              STR      r5,[r0,#0x38]
00004a  6826              LDR      r6,[r4,#0]
00004c  6ce1              LDR      r1,[r4,#0x4c]
00004e  f1060228          ADD      r2,r6,#0x28
000052  6ea0              LDR      r0,[r4,#0x68]
000054  f7fffffe          BL       HAL_DMA_Start_IT
;;;1436   
;;;1437       /* Clear the TC flag in the ICR register */
;;;1438       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
000058  6821              LDR      r1,[r4,#0]
00005a  2040              MOVS     r0,#0x40
00005c  6208              STR      r0,[r1,#0x20]
;;;1439   
;;;1440       /* Process Unlocked */
;;;1441       __HAL_UNLOCK(huart);
00005e  f8845070          STRB     r5,[r4,#0x70]
;;;1442   
;;;1443       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1444       in the UART CR3 register */
;;;1445       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000062  6820              LDR      r0,[r4,#0]
000064  6881              LDR      r1,[r0,#8]
000066  f0410180          ORR      r1,r1,#0x80
00006a  6081              STR      r1,[r0,#8]
;;;1446   
;;;1447       return HAL_OK;
00006c  2000              MOVS     r0,#0
                  |L36.110|
;;;1448     }
;;;1449     else
;;;1450     {
;;;1451       return HAL_BUSY;
;;;1452     }
;;;1453   }
00006e  bd70              POP      {r4-r6,pc}
                  |L36.112|
000070  e7ff              B        |L36.114|
                  |L36.114|
000072  2001              MOVS     r0,#1                 ;1409
000074  e7fb              B        |L36.110|
                  |L36.118|
000076  2002              MOVS     r0,#2                 ;1451
000078  e7f9              B        |L36.110|
;;;1454   
                          ENDP

00007a  0000              DCW      0x0000
                  |L36.124|
                          DCD      UART_DMATransmitCplt
                  |L36.128|
                          DCD      UART_DMATxHalfCplt
                  |L36.132|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_IT PROC
;;;1234     */
;;;1235   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903071          LDRB     r3,[r0,#0x71]
;;;1236   {
;;;1237     /* Check that a Tx process is not already ongoing */
;;;1238     if (huart->gState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d129              BNE      |L37.92|
;;;1239     {
;;;1240       if ((pData == NULL) || (Size == 0U))
000008  b1b9              CBZ      r1,|L37.58|
00000a  b1b2              CBZ      r2,|L37.58|
;;;1241       {
;;;1242         return HAL_ERROR;
;;;1243       }
;;;1244   
;;;1245       /* Process Locked */
;;;1246       __HAL_LOCK(huart);
00000c  f8903070          LDRB     r3,[r0,#0x70]
000010  2b01              CMP      r3,#1
000012  d023              BEQ      |L37.92|
000014  2301              MOVS     r3,#1
000016  f8803070          STRB     r3,[r0,#0x70]
;;;1247   
;;;1248       huart->pTxBuffPtr  = pData;
;;;1249       huart->TxXferSize  = Size;
00001a  64c1              STR      r1,[r0,#0x4c]
00001c  f8a02050          STRH     r2,[r0,#0x50]
;;;1250       huart->TxXferCount = Size;
000020  f8a02052          STRH     r2,[r0,#0x52]
;;;1251       huart->TxISR       = NULL;
000024  2100              MOVS     r1,#0
;;;1252   
;;;1253       huart->ErrorCode = HAL_UART_ERROR_NONE;
000026  6641              STR      r1,[r0,#0x64]
000028  6741              STR      r1,[r0,#0x74]
;;;1254       huart->gState = HAL_UART_STATE_BUSY_TX;
00002a  2221              MOVS     r2,#0x21
00002c  f8802071          STRB     r2,[r0,#0x71]
;;;1255   
;;;1256   #if defined(USART_CR1_FIFOEN)
;;;1257       /* Configure Tx interrupt processing */
;;;1258       if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1259       {
;;;1260         /* Set the Tx ISR function pointer according to the data word length */
;;;1261         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1262         {
;;;1263           huart->TxISR = UART_TxISR_16BIT_FIFOEN;
;;;1264         }
;;;1265         else
;;;1266         {
;;;1267           huart->TxISR = UART_TxISR_8BIT_FIFOEN;
;;;1268         }
;;;1269   
;;;1270         /* Process Unlocked */
;;;1271         __HAL_UNLOCK(huart);
;;;1272   
;;;1273         /* Enable the TX FIFO threshold interrupt */
;;;1274         SET_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
;;;1275       }
;;;1276       else
;;;1277   #endif
;;;1278       {
;;;1279         /* Set the Tx ISR function pointer according to the data word length */
;;;1280         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000030  6882              LDR      r2,[r0,#8]
000032  f5b25f80          CMP      r2,#0x1000
000036  d002              BEQ      |L37.62|
000038  e003              B        |L37.66|
                  |L37.58|
00003a  2001              MOVS     r0,#1                 ;1242
;;;1281         {
;;;1282           huart->TxISR = UART_TxISR_16BIT;
;;;1283         }
;;;1284         else
;;;1285         {
;;;1286           huart->TxISR = UART_TxISR_8BIT;
;;;1287         }
;;;1288   
;;;1289         /* Process Unlocked */
;;;1290         __HAL_UNLOCK(huart);
;;;1291   
;;;1292         /* Enable the Transmit Data Register Empty interrupt */
;;;1293   #if defined(USART_CR1_FIFOEN)
;;;1294         SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;1295   #else
;;;1296         SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;1297   #endif
;;;1298       }
;;;1299   
;;;1300       return HAL_OK;
;;;1301     }
;;;1302     else
;;;1303     {
;;;1304       return HAL_BUSY;
;;;1305     }
;;;1306   }
00003c  4770              BX       lr
                  |L37.62|
00003e  6902              LDR      r2,[r0,#0x10]         ;1280
000040  b152              CBZ      r2,|L37.88|
                  |L37.66|
000042  4a07              LDR      r2,|L37.96|
                  |L37.68|
000044  6642              STR      r2,[r0,#0x64]         ;1290
000046  f8801070          STRB     r1,[r0,#0x70]         ;1290
00004a  6800              LDR      r0,[r0,#0]            ;1296
00004c  6801              LDR      r1,[r0,#0]            ;1296
00004e  f0410180          ORR      r1,r1,#0x80           ;1296
000052  6001              STR      r1,[r0,#0]            ;1296
000054  2000              MOVS     r0,#0                 ;1300
000056  4770              BX       lr
                  |L37.88|
000058  4a02              LDR      r2,|L37.100|
00005a  e7f3              B        |L37.68|
                  |L37.92|
00005c  2002              MOVS     r0,#2                 ;1304
00005e  4770              BX       lr
;;;1307   
                          ENDP

                  |L37.96|
                          DCD      UART_TxISR_8BIT
                  |L37.100|
                          DCD      UART_TxISR_16BIT

                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2424     */
;;;2425   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2426   {
;;;2427     /* Prevent unused argument(s) compilation warning */
;;;2428     UNUSED(huart);
;;;2429   
;;;2430     /* NOTE : This function should not be modified, when the callback is needed,
;;;2431               the HAL_UART_TxCpltCallback can be implemented in the user file.
;;;2432      */
;;;2433   }
;;;2434   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2439     */
;;;2440   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2441   {
;;;2442     /* Prevent unused argument(s) compilation warning */
;;;2443     UNUSED(huart);
;;;2444   
;;;2445     /* NOTE: This function should not be modified, when the callback is needed,
;;;2446              the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
;;;2447      */
;;;2448   }
;;;2449   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;3088     */
;;;3089   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;3090   {
;;;3091     /* Check whether the set of advanced features to configure is properly set */
;;;3092     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;3093   
;;;3094     /* if required, configure TX pin active level inversion */
;;;3095     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  07c9              LSLS     r1,r1,#31
000006  d006              BEQ      |L40.22|
;;;3096     {
;;;3097       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;3098       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
000008  6801              LDR      r1,[r0,#0]
00000a  684a              LDR      r2,[r1,#4]
00000c  6a83              LDR      r3,[r0,#0x28]
00000e  f4223200          BIC      r2,r2,#0x20000
000012  431a              ORRS     r2,r2,r3
000014  604a              STR      r2,[r1,#4]
                  |L40.22|
;;;3099     }
;;;3100   
;;;3101     /* if required, configure RX pin active level inversion */
;;;3102     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000016  f8901024          LDRB     r1,[r0,#0x24]
00001a  0789              LSLS     r1,r1,#30
00001c  d506              BPL      |L40.44|
;;;3103     {
;;;3104       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;3105       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
00001e  6801              LDR      r1,[r0,#0]
000020  684a              LDR      r2,[r1,#4]
000022  6ac3              LDR      r3,[r0,#0x2c]
000024  f4223280          BIC      r2,r2,#0x10000
000028  431a              ORRS     r2,r2,r3
00002a  604a              STR      r2,[r1,#4]
                  |L40.44|
;;;3106     }
;;;3107   
;;;3108     /* if required, configure data inversion */
;;;3109     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
00002c  f8901024          LDRB     r1,[r0,#0x24]
000030  0749              LSLS     r1,r1,#29
000032  d506              BPL      |L40.66|
;;;3110     {
;;;3111       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;3112       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
000034  6801              LDR      r1,[r0,#0]
000036  684a              LDR      r2,[r1,#4]
000038  6b03              LDR      r3,[r0,#0x30]
00003a  f4222280          BIC      r2,r2,#0x40000
00003e  431a              ORRS     r2,r2,r3
000040  604a              STR      r2,[r1,#4]
                  |L40.66|
;;;3113     }
;;;3114   
;;;3115     /* if required, configure RX/TX pins swap */
;;;3116     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000042  f8901024          LDRB     r1,[r0,#0x24]
000046  0709              LSLS     r1,r1,#28
000048  d506              BPL      |L40.88|
;;;3117     {
;;;3118       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;3119       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
00004a  6801              LDR      r1,[r0,#0]
00004c  684a              LDR      r2,[r1,#4]
00004e  6b43              LDR      r3,[r0,#0x34]
000050  f4224200          BIC      r2,r2,#0x8000
000054  431a              ORRS     r2,r2,r3
000056  604a              STR      r2,[r1,#4]
                  |L40.88|
;;;3120     }
;;;3121   
;;;3122     /* if required, configure RX overrun detection disabling */
;;;3123     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000058  f8901024          LDRB     r1,[r0,#0x24]
00005c  06c9              LSLS     r1,r1,#27
00005e  d506              BPL      |L40.110|
;;;3124     {
;;;3125       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;3126       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000060  6801              LDR      r1,[r0,#0]
000062  688a              LDR      r2,[r1,#8]
000064  6b83              LDR      r3,[r0,#0x38]
000066  f4225280          BIC      r2,r2,#0x1000
00006a  431a              ORRS     r2,r2,r3
00006c  608a              STR      r2,[r1,#8]
                  |L40.110|
;;;3127     }
;;;3128   
;;;3129     /* if required, configure DMA disabling on reception error */
;;;3130     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
00006e  f8901024          LDRB     r1,[r0,#0x24]
000072  0689              LSLS     r1,r1,#26
000074  d506              BPL      |L40.132|
;;;3131     {
;;;3132       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;3133       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000076  6801              LDR      r1,[r0,#0]
000078  688a              LDR      r2,[r1,#8]
00007a  6bc3              LDR      r3,[r0,#0x3c]
00007c  f4225200          BIC      r2,r2,#0x2000
000080  431a              ORRS     r2,r2,r3
000082  608a              STR      r2,[r1,#8]
                  |L40.132|
;;;3134     }
;;;3135   
;;;3136     /* if required, configure auto Baud rate detection scheme */
;;;3137     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000084  f8901024          LDRB     r1,[r0,#0x24]
000088  0649              LSLS     r1,r1,#25
00008a  d511              BPL      |L40.176|
;;;3138     {
;;;3139       assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
;;;3140       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;3141       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00008c  6801              LDR      r1,[r0,#0]
00008e  684a              LDR      r2,[r1,#4]
000090  6c03              LDR      r3,[r0,#0x40]
000092  f4221280          BIC      r2,r2,#0x100000
000096  431a              ORRS     r2,r2,r3
000098  604a              STR      r2,[r1,#4]
;;;3142       /* set auto Baudrate detection parameters if detection is enabled */
;;;3143       if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
00009a  6c01              LDR      r1,[r0,#0x40]
00009c  f5b11f80          CMP      r1,#0x100000
0000a0  d106              BNE      |L40.176|
;;;3144       {
;;;3145         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;3146         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000a2  6801              LDR      r1,[r0,#0]
0000a4  684a              LDR      r2,[r1,#4]
0000a6  6c43              LDR      r3,[r0,#0x44]
0000a8  f42202c0          BIC      r2,r2,#0x600000
0000ac  431a              ORRS     r2,r2,r3
0000ae  604a              STR      r2,[r1,#4]
                  |L40.176|
;;;3147       }
;;;3148     }
;;;3149   
;;;3150     /* if required, configure MSB first on communication line */
;;;3151     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000b0  f8901024          LDRB     r1,[r0,#0x24]
0000b4  0609              LSLS     r1,r1,#24
0000b6  d506              BPL      |L40.198|
;;;3152     {
;;;3153       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;3154       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000b8  6801              LDR      r1,[r0,#0]
0000ba  684a              LDR      r2,[r1,#4]
0000bc  6c80              LDR      r0,[r0,#0x48]
0000be  f4222200          BIC      r2,r2,#0x80000
0000c2  4302              ORRS     r2,r2,r0
0000c4  604a              STR      r2,[r1,#4]
                  |L40.198|
;;;3155     }
;;;3156   }
0000c6  4770              BX       lr
;;;3157   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;3162     */
;;;3163   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3164   {
;;;3165     uint32_t tickstart = 0U;
;;;3166   
;;;3167     /* Initialize the UART ErrorCode */
;;;3168     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;3164
000006  6745              STR      r5,[r0,#0x74]
;;;3169   
;;;3170     /* Init tickstart for timeout managment*/
;;;3171     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;3172   
;;;3173     /* Check if the Transmitter is enabled */
;;;3174     if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
;;;3175     {
;;;3176       /* Wait until TEACK flag is set */
;;;3177       if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000012  f06f467e          MVN      r6,#0xfe000000
000016  0700              LSLS     r0,r0,#28             ;3174
000018  d508              BPL      |L41.44|
00001a  463b              MOV      r3,r7
00001c  2200              MOVS     r2,#0
00001e  f44f1100          MOV      r1,#0x200000
000022  4620              MOV      r0,r4
000024  9600              STR      r6,[sp,#0]
000026  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00002a  b960              CBNZ     r0,|L41.70|
                  |L41.44|
;;;3178       {
;;;3179         /* Timeout occurred */
;;;3180         return HAL_TIMEOUT;
;;;3181       }
;;;3182     }
;;;3183     /* Check if the Receiver is enabled */
;;;3184     if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
00002c  6820              LDR      r0,[r4,#0]
00002e  6800              LDR      r0,[r0,#0]
000030  0740              LSLS     r0,r0,#29
000032  d50a              BPL      |L41.74|
;;;3185     {
;;;3186       /* Wait until REACK flag is set */
;;;3187       if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000034  463b              MOV      r3,r7
000036  2200              MOVS     r2,#0
000038  f44f0180          MOV      r1,#0x400000
00003c  4620              MOV      r0,r4
00003e  9600              STR      r6,[sp,#0]
000040  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000044  b108              CBZ      r0,|L41.74|
                  |L41.70|
;;;3188       {
;;;3189         /* Timeout occurred */
;;;3190         return HAL_TIMEOUT;
000046  2003              MOVS     r0,#3
;;;3191       }
;;;3192     }
;;;3193   
;;;3194     /* Initialize the UART State */
;;;3195     huart->gState = HAL_UART_STATE_READY;
;;;3196     huart->RxState = HAL_UART_STATE_READY;
;;;3197   
;;;3198     /* Process Unlocked */
;;;3199     __HAL_UNLOCK(huart);
;;;3200   
;;;3201     return HAL_OK;
;;;3202   }
000048  bdf8              POP      {r3-r7,pc}
                  |L41.74|
00004a  2020              MOVS     r0,#0x20              ;3195
00004c  f8840071          STRB     r0,[r4,#0x71]         ;3195
000050  f8840072          STRB     r0,[r4,#0x72]         ;3196
000054  f8845070          STRB     r5,[r4,#0x70]         ;3199
000058  2000              MOVS     r0,#0                 ;3201
00005a  bdf8              POP      {r3-r7,pc}
;;;3203   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;3436     */
;;;3437   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3438   {
;;;3439     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3440     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a0105a          STRH     r1,[r0,#0x5a]
;;;3441     huart->TxXferCount = 0U;
00000a  f8a01052          STRH     r1,[r0,#0x52]
;;;3442   
;;;3443   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3444     /*Call registered error callback*/
;;;3445     huart->ErrorCallback(huart);
;;;3446   #else
;;;3447     /*Call legacy weak error callback*/
;;;3448     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3449   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3450   }
000012  bd10              POP      {r4,pc}
;;;3451   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;3399     */
;;;3400   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3401   {
;;;3402     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
;;;3403   
;;;3404     /* Stop UART DMA Tx request if ongoing */
;;;3405     if ((huart->gState == HAL_UART_STATE_BUSY_TX)
000002  6a84              LDR      r4,[r0,#0x28]
000004  f8940071          LDRB     r0,[r4,#0x71]
000008  2500              MOVS     r5,#0
00000a  2821              CMP      r0,#0x21
00000c  d108              BNE      |L43.32|
;;;3406         && (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  0600              LSLS     r0,r0,#24
000014  d504              BPL      |L43.32|
;;;3407     {
;;;3408       huart->TxXferCount = 0U;
000016  f8a45052          STRH     r5,[r4,#0x52]
;;;3409       UART_EndTxTransfer(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       UART_EndTxTransfer
                  |L43.32|
;;;3410     }
;;;3411   
;;;3412     /* Stop UART DMA Rx request if ongoing */
;;;3413     if ((huart->RxState == HAL_UART_STATE_BUSY_RX)
000020  f8940072          LDRB     r0,[r4,#0x72]
000024  2822              CMP      r0,#0x22
000026  d108              BNE      |L43.58|
;;;3414         && (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000028  6820              LDR      r0,[r4,#0]
00002a  6880              LDR      r0,[r0,#8]
00002c  0640              LSLS     r0,r0,#25
00002e  d504              BPL      |L43.58|
;;;3415     {
;;;3416       huart->RxXferCount = 0U;
000030  f8a4505a          STRH     r5,[r4,#0x5a]
;;;3417       UART_EndRxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndRxTransfer
                  |L43.58|
;;;3418     }
;;;3419   
;;;3420     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00003a  6f60              LDR      r0,[r4,#0x74]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6760              STR      r0,[r4,#0x74]
;;;3421   
;;;3422   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3423     /*Call registered error callback*/
;;;3424     huart->ErrorCallback(huart);
;;;3425   #else
;;;3426     /*Call legacy weak error callback*/
;;;3427     HAL_UART_ErrorCallback(huart);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3428   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3429   }
000048  bd70              POP      {r4-r6,pc}
;;;3430   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;3346     */
;;;3347   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3348   {
000002  4601              MOV      r1,r0
;;;3349     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000004  6a80              LDR      r0,[r0,#0x28]
;;;3350   
;;;3351     /* DMA Normal mode */
;;;3352     if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d414              BMI      |L44.56|
;;;3353     {
;;;3354       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  f8a0105a          STRH     r1,[r0,#0x5a]
;;;3355   
;;;3356       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3357       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f4227280          BIC      r2,r2,#0x100
00001c  600a              STR      r2,[r1,#0]
;;;3358       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  6801              LDR      r1,[r0,#0]
000020  688a              LDR      r2,[r1,#8]
000022  f0220201          BIC      r2,r2,#1
000026  608a              STR      r2,[r1,#8]
;;;3359   
;;;3360       /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;3361          in the UART CR3 register */
;;;3362       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6801              LDR      r1,[r0,#0]
00002a  688a              LDR      r2,[r1,#8]
00002c  f0220240          BIC      r2,r2,#0x40
000030  608a              STR      r2,[r1,#8]
;;;3363   
;;;3364       /* At end of Rx process, restore huart->RxState to Ready */
;;;3365       huart->RxState = HAL_UART_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  f8801072          STRB     r1,[r0,#0x72]
                  |L44.56|
;;;3366     }
;;;3367   
;;;3368   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3369     /*Call registered Rx complete callback*/
;;;3370     huart->RxCpltCallback(huart);
;;;3371   #else
;;;3372     /*Call legacy weak Rx complete callback*/
;;;3373     HAL_UART_RxCpltCallback(huart);
000038  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;3374   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3375   }
00003c  bd10              POP      {r4,pc}
;;;3376   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;3515     */
;;;3516   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3517   {
;;;3518     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3519   
;;;3520     huart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6ec1              LDR      r1,[r0,#0x6c]
;;;3521   
;;;3522     /* Check if an Abort process is still ongoing */
;;;3523     if (huart->hdmatx != NULL)
000008  638a              STR      r2,[r1,#0x38]
00000a  6e81              LDR      r1,[r0,#0x68]         ;3517
00000c  b111              CBZ      r1,|L45.20|
;;;3524     {
;;;3525       if (huart->hdmatx->XferAbortCallback != NULL)
00000e  6b89              LDR      r1,[r1,#0x38]
000010  2900              CMP      r1,#0
000012  d113              BNE      |L45.60|
                  |L45.20|
;;;3526       {
;;;3527         return;
;;;3528       }
;;;3529     }
;;;3530   
;;;3531     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3532     huart->TxXferCount = 0U;
000014  f8a02052          STRH     r2,[r0,#0x52]
;;;3533     huart->RxXferCount = 0U;
000018  f8a0205a          STRH     r2,[r0,#0x5a]
;;;3534   
;;;3535     /* Reset errorCode */
;;;3536     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001c  6742              STR      r2,[r0,#0x74]
;;;3537   
;;;3538     /* Clear the Error flags in the ICR register */
;;;3539     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00001e  6802              LDR      r2,[r0,#0]
000020  210f              MOVS     r1,#0xf
000022  6211              STR      r1,[r2,#0x20]
;;;3540   
;;;3541     /* Discard the received data */
;;;3542     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000024  6801              LDR      r1,[r0,#0]
000026  8b0a              LDRH     r2,[r1,#0x18]
000028  f0420208          ORR      r2,r2,#8
00002c  830a              STRH     r2,[r1,#0x18]
;;;3543   
;;;3544     /* Restore huart->gState and huart->RxState to Ready */
;;;3545     huart->gState  = HAL_UART_STATE_READY;
00002e  2120              MOVS     r1,#0x20
000030  f8801071          STRB     r1,[r0,#0x71]
;;;3546     huart->RxState = HAL_UART_STATE_READY;
000034  f8801072          STRB     r1,[r0,#0x72]
;;;3547   
;;;3548     /* Call user Abort complete callback */
;;;3549   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3550     /* Call registered Abort complete callback */
;;;3551     huart->AbortCpltCallback(huart);
;;;3552   #else
;;;3553     /* Call legacy weak Abort complete callback */
;;;3554     HAL_UART_AbortCpltCallback(huart);
000038  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L45.60|
;;;3555   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3556   }
00003c  bd10              POP      {r4,pc}
;;;3557   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;3381     */
;;;3382   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3383   {
;;;3384     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3385   
;;;3386   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3387     /*Call registered Rx Half complete callback*/
;;;3388     huart->RxHalfCpltCallback(huart);
;;;3389   #else
;;;3390     /*Call legacy weak Rx Half complete callback*/
;;;3391     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;3392   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3393   }
000008  bd10              POP      {r4,pc}
;;;3394   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;3601     */
;;;3602   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3603   {
;;;3604     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;3605   
;;;3606     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a0105a          STRH     r1,[r0,#0x5a]
;;;3607   
;;;3608     /* Clear the Error flags in the ICR register */
;;;3609     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00000a  6802              LDR      r2,[r0,#0]
00000c  210f              MOVS     r1,#0xf
00000e  6211              STR      r1,[r2,#0x20]
;;;3610   
;;;3611     /* Discard the received data */
;;;3612     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  6801              LDR      r1,[r0,#0]
000012  8b0a              LDRH     r2,[r1,#0x18]
000014  f0420208          ORR      r2,r2,#8
000018  830a              STRH     r2,[r1,#0x18]
;;;3613   
;;;3614     /* Restore huart->RxState to Ready */
;;;3615     huart->RxState = HAL_UART_STATE_READY;
00001a  2120              MOVS     r1,#0x20
00001c  f8801072          STRB     r1,[r0,#0x72]
;;;3616   
;;;3617     /* Call user Abort complete callback */
;;;3618   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3619     /* Call registered Abort Receive Complete Callback */
;;;3620     huart->AbortReceiveCpltCallback(huart);
;;;3621   #else
;;;3622     /* Call legacy weak Abort Receive Complete Callback */
;;;3623     HAL_UART_AbortReceiveCpltCallback(huart);
000020  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;3624   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3625   }
000024  bd10              POP      {r4,pc}
;;;3626   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;3294     */
;;;3295   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3296   {
000002  4601              MOV      r1,r0
;;;3297     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000004  6a80              LDR      r0,[r0,#0x28]
;;;3298   
;;;3299     /* DMA Normal mode */
;;;3300     if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40d              BMI      |L48.42|
;;;3301     {
;;;3302       huart->TxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  f8a01052          STRH     r1,[r0,#0x52]
;;;3303   
;;;3304       /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;3305          in the UART CR3 register */
;;;3306       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6801              LDR      r1,[r0,#0]
000016  688a              LDR      r2,[r1,#8]
000018  f0220280          BIC      r2,r2,#0x80
00001c  608a              STR      r2,[r1,#8]
;;;3307   
;;;3308       /* Enable the UART Transmit Complete Interrupt */
;;;3309       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001e  6800              LDR      r0,[r0,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0410140          ORR      r1,r1,#0x40
000026  6001              STR      r1,[r0,#0]
;;;3310     }
;;;3311     /* DMA Circular mode */
;;;3312     else
;;;3313     {
;;;3314   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3315       /*Call registered Tx complete callback*/
;;;3316       huart->TxCpltCallback(huart);
;;;3317   #else
;;;3318       /*Call legacy weak Tx complete callback*/
;;;3319       HAL_UART_TxCpltCallback(huart);
;;;3320   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3321     }
;;;3322   }
000028  bd10              POP      {r4,pc}
                  |L48.42|
00002a  f7fffffe          BL       HAL_UART_TxCpltCallback
00002e  bd10              POP      {r4,pc}
;;;3323   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;3459     */
;;;3460   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3461   {
;;;3462     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3463   
;;;3464     huart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6e81              LDR      r1,[r0,#0x68]
;;;3465   
;;;3466     /* Check if an Abort process is still ongoing */
;;;3467     if (huart->hdmarx != NULL)
000008  638a              STR      r2,[r1,#0x38]
00000a  6ec1              LDR      r1,[r0,#0x6c]         ;3461
00000c  b111              CBZ      r1,|L49.20|
;;;3468     {
;;;3469       if (huart->hdmarx->XferAbortCallback != NULL)
00000e  6b89              LDR      r1,[r1,#0x38]
000010  2900              CMP      r1,#0
000012  d10e              BNE      |L49.50|
                  |L49.20|
;;;3470       {
;;;3471         return;
;;;3472       }
;;;3473     }
;;;3474   
;;;3475     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3476     huart->TxXferCount = 0U;
000014  f8a02052          STRH     r2,[r0,#0x52]
;;;3477     huart->RxXferCount = 0U;
000018  f8a0205a          STRH     r2,[r0,#0x5a]
;;;3478   
;;;3479     /* Reset errorCode */
;;;3480     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001c  6742              STR      r2,[r0,#0x74]
;;;3481   
;;;3482     /* Clear the Error flags in the ICR register */
;;;3483     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00001e  6802              LDR      r2,[r0,#0]
000020  210f              MOVS     r1,#0xf
000022  6211              STR      r1,[r2,#0x20]
;;;3484   
;;;3485   #if defined(USART_CR1_FIFOEN)
;;;3486     /* Flush the whole TX FIFO (if needed) */
;;;3487     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;3488     {
;;;3489       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;3490     }
;;;3491   #endif
;;;3492   
;;;3493     /* Restore huart->gState and huart->RxState to Ready */
;;;3494     huart->gState  = HAL_UART_STATE_READY;
000024  2120              MOVS     r1,#0x20
000026  f8801071          STRB     r1,[r0,#0x71]
;;;3495     huart->RxState = HAL_UART_STATE_READY;
00002a  f8801072          STRB     r1,[r0,#0x72]
;;;3496   
;;;3497     /* Call user Abort complete callback */
;;;3498   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3499     /* Call registered Abort complete callback */
;;;3500     huart->AbortCpltCallback(huart);
;;;3501   #else
;;;3502     /* Call legacy weak Abort complete callback */
;;;3503     HAL_UART_AbortCpltCallback(huart);
00002e  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L49.50|
;;;3504   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3505   }
000032  bd10              POP      {r4,pc}
;;;3506   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;3328     */
;;;3329   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3330   {
;;;3331     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3332   
;;;3333   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3334     /*Call registered Tx Half complete callback*/
;;;3335     huart->TxHalfCpltCallback(huart);
;;;3336   #else
;;;3337     /*Call legacy weak Tx Half complete callback*/
;;;3338     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;3339   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3340   }
000008  bd10              POP      {r4,pc}
;;;3341   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;3566     */
;;;3567   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3568   {
;;;3569     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3570   
;;;3571     huart->TxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a01052          STRH     r1,[r0,#0x52]
;;;3572   
;;;3573   #if defined(USART_CR1_FIFOEN)
;;;3574     /* Flush the whole TX FIFO (if needed) */
;;;3575     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;3576     {
;;;3577       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;3578     }
;;;3579   #endif
;;;3580   
;;;3581     /* Restore huart->gState to Ready */
;;;3582     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801071          STRB     r1,[r0,#0x71]
;;;3583   
;;;3584     /* Call user Abort complete callback */
;;;3585   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3586     /* Call registered Abort Transmit Complete Callback */
;;;3587     huart->AbortTransmitCpltCallback(huart);
;;;3588   #else
;;;3589     /* Call legacy weak Abort Transmit Complete Callback */
;;;3590     HAL_UART_AbortTransmitCpltCallback(huart);
000010  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;3591   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3592   }
000014  bd10              POP      {r4,pc}
;;;3593   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;3270     */
;;;3271   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;3272   {
;;;3273     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3274   #if defined(USART_CR1_FIFOEN)
;;;3275     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;3276     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
;;;3277   #else
;;;3278     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  680a              LDR      r2,[r1,#0]
000004  f4227290          BIC      r2,r2,#0x120
000008  600a              STR      r2,[r1,#0]
;;;3279     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  688a              LDR      r2,[r1,#8]
00000e  f0220201          BIC      r2,r2,#1
000012  608a              STR      r2,[r1,#8]
;;;3280   #endif
;;;3281   
;;;3282     /* At end of Rx process, restore huart->RxState to Ready */
;;;3283     huart->RxState = HAL_UART_STATE_READY;
000014  2120              MOVS     r1,#0x20
000016  f8801072          STRB     r1,[r0,#0x72]
;;;3284   
;;;3285     /* Reset RxIsr function pointer */
;;;3286     huart->RxISR = NULL;
00001a  2100              MOVS     r1,#0
00001c  6601              STR      r1,[r0,#0x60]
;;;3287   }
00001e  4770              BX       lr
;;;3288   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;3249     */
;;;3250   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;3251   {
;;;3252   #if defined(USART_CR1_FIFOEN)
;;;3253     /* Disable TXEIE, TCIE, TXFT interrupts */
;;;3254     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
;;;3255     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
;;;3256   #else
;;;3257     /* Disable TXEIE and TCIE interrupts */
;;;3258     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  680a              LDR      r2,[r1,#0]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  600a              STR      r2,[r1,#0]
;;;3259   #endif
;;;3260   
;;;3261     /* At end of Tx process, restore huart->gState to Ready */
;;;3262     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801071          STRB     r1,[r0,#0x71]
;;;3263   }
000010  4770              BX       lr
;;;3264   
                          ENDP


                          AREA ||i.UART_RxISR_16BIT||, CODE, READONLY, ALIGN=1

                  UART_RxISR_16BIT PROC
;;;3852     */
;;;3853   static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;3854   {
;;;3855     uint16_t *tmp;
;;;3856     uint16_t uhMask = huart->Mask;
000002  f8b0205c          LDRH     r2,[r0,#0x5c]
;;;3857     uint16_t  uhdata;
;;;3858   
;;;3859     /* Check that a Rx process is ongoing */
;;;3860     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000006  f8903072          LDRB     r3,[r0,#0x72]
00000a  6801              LDR      r1,[r0,#0]
00000c  2b22              CMP      r3,#0x22
00000e  d004              BEQ      |L54.26|
;;;3861     {
;;;3862       uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
;;;3863       tmp = (uint16_t *) huart->pRxBuffPtr ;
;;;3864       *tmp = (uint16_t)(uhdata & uhMask);
;;;3865       huart->pRxBuffPtr += 2;
;;;3866   
;;;3867       if (--huart->RxXferCount == 0)
;;;3868       {
;;;3869         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;3870   #if defined(USART_CR1_FIFOEN)
;;;3871         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;3872   #else
;;;3873         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;3874   #endif
;;;3875   
;;;3876         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3877         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;3878   
;;;3879         /* Rx process is completed, restore huart->RxState to Ready */
;;;3880         huart->RxState = HAL_UART_STATE_READY;
;;;3881   
;;;3882         /* Clear RxISR function pointer */
;;;3883         huart->RxISR = NULL;
;;;3884   
;;;3885   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3886         /*Call registered Rx complete callback*/
;;;3887         huart->RxCpltCallback(huart);
;;;3888   #else
;;;3889         /*Call legacy weak Rx complete callback*/
;;;3890         HAL_UART_RxCpltCallback(huart);
;;;3891   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3892       }
;;;3893     }
;;;3894     else
;;;3895     {
;;;3896       /* Clear RXNE interrupt flag */
;;;3897       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  8b08              LDRH     r0,[r1,#0x18]
000012  f0400008          ORR      r0,r0,#8
000016  8308              STRH     r0,[r1,#0x18]
                  |L54.24|
;;;3898     }
;;;3899   }
000018  bd10              POP      {r4,pc}
                  |L54.26|
00001a  8c89              LDRH     r1,[r1,#0x24]         ;3862
00001c  6d43              LDR      r3,[r0,#0x54]         ;3864
00001e  4011              ANDS     r1,r1,r2              ;3864
000020  8019              STRH     r1,[r3,#0]            ;3864
000022  6d41              LDR      r1,[r0,#0x54]         ;3865
000024  1c89              ADDS     r1,r1,#2              ;3865
000026  6541              STR      r1,[r0,#0x54]         ;3867
000028  f8b0105a          LDRH     r1,[r0,#0x5a]         ;3867
00002c  1e49              SUBS     r1,r1,#1              ;3867
00002e  0409              LSLS     r1,r1,#16             ;3867
000030  0c09              LSRS     r1,r1,#16             ;3867
000032  f8a0105a          STRH     r1,[r0,#0x5a]         ;3867
000036  d1ef              BNE      |L54.24|
000038  6801              LDR      r1,[r0,#0]            ;3873
00003a  680a              LDR      r2,[r1,#0]            ;3873
00003c  f4227290          BIC      r2,r2,#0x120          ;3873
000040  600a              STR      r2,[r1,#0]            ;3873
000042  6801              LDR      r1,[r0,#0]            ;3877
000044  688a              LDR      r2,[r1,#8]            ;3877
000046  f0220201          BIC      r2,r2,#1              ;3877
00004a  608a              STR      r2,[r1,#8]            ;3877
00004c  2120              MOVS     r1,#0x20              ;3880
00004e  f8801072          STRB     r1,[r0,#0x72]         ;3880
000052  2100              MOVS     r1,#0                 ;3883
000054  6601              STR      r1,[r0,#0x60]         ;3890
000056  f7fffffe          BL       HAL_UART_RxCpltCallback
00005a  bd10              POP      {r4,pc}
;;;3900   
                          ENDP


                          AREA ||i.UART_RxISR_8BIT||, CODE, READONLY, ALIGN=1

                  UART_RxISR_8BIT PROC
;;;3800     */
;;;3801   static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;3802   {
;;;3803     uint16_t uhMask = huart->Mask;
000002  f8b0305c          LDRH     r3,[r0,#0x5c]
;;;3804     uint16_t  uhdata;
;;;3805   
;;;3806     /* Check that a Rx process is ongoing */
;;;3807     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000006  f8902072          LDRB     r2,[r0,#0x72]
00000a  6801              LDR      r1,[r0,#0]
00000c  2a22              CMP      r2,#0x22
00000e  d004              BEQ      |L55.26|
;;;3808     {
;;;3809       uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
;;;3810       *huart->pRxBuffPtr++ = (uint8_t)(uhdata & (uint8_t)uhMask);
;;;3811   
;;;3812       if (--huart->RxXferCount == 0)
;;;3813       {
;;;3814         /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;3815   #if defined(USART_CR1_FIFOEN)
;;;3816         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;3817   #else
;;;3818         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;3819   #endif
;;;3820   
;;;3821         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3822         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;3823   
;;;3824         /* Rx process is completed, restore huart->RxState to Ready */
;;;3825         huart->RxState = HAL_UART_STATE_READY;
;;;3826   
;;;3827         /* Clear RxISR function pointer */
;;;3828         huart->RxISR = NULL;
;;;3829   
;;;3830   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3831         /*Call registered Rx complete callback*/
;;;3832         huart->RxCpltCallback(huart);
;;;3833   #else
;;;3834         /*Call legacy weak Rx complete callback*/
;;;3835         HAL_UART_RxCpltCallback(huart);
;;;3836   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3837       }
;;;3838     }
;;;3839     else
;;;3840     {
;;;3841       /* Clear RXNE interrupt flag */
;;;3842       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  8b08              LDRH     r0,[r1,#0x18]
000012  f0400008          ORR      r0,r0,#8
000016  8308              STRH     r0,[r1,#0x18]
                  |L55.24|
;;;3843     }
;;;3844   }
000018  bd10              POP      {r4,pc}
                  |L55.26|
00001a  8c8a              LDRH     r2,[r1,#0x24]         ;3809
00001c  6d41              LDR      r1,[r0,#0x54]         ;3810
00001e  401a              ANDS     r2,r2,r3              ;3810
000020  1c4b              ADDS     r3,r1,#1              ;3810
000022  6543              STR      r3,[r0,#0x54]         ;3810
000024  700a              STRB     r2,[r1,#0]            ;3810
000026  f8b0105a          LDRH     r1,[r0,#0x5a]         ;3812
00002a  1e49              SUBS     r1,r1,#1              ;3812
00002c  0409              LSLS     r1,r1,#16             ;3812
00002e  0c09              LSRS     r1,r1,#16             ;3812
000030  f8a0105a          STRH     r1,[r0,#0x5a]         ;3812
000034  d1f0              BNE      |L55.24|
000036  6801              LDR      r1,[r0,#0]            ;3818
000038  680a              LDR      r2,[r1,#0]            ;3818
00003a  f4227290          BIC      r2,r2,#0x120          ;3818
00003e  600a              STR      r2,[r1,#0]            ;3818
000040  6801              LDR      r1,[r0,#0]            ;3822
000042  688a              LDR      r2,[r1,#8]            ;3822
000044  f0220201          BIC      r2,r2,#1              ;3822
000048  608a              STR      r2,[r1,#8]            ;3822
00004a  2120              MOVS     r1,#0x20              ;3825
00004c  f8801072          STRB     r1,[r0,#0x72]         ;3825
000050  2100              MOVS     r1,#0                 ;3828
000052  6601              STR      r1,[r0,#0x60]         ;3835
000054  f7fffffe          BL       HAL_UART_RxCpltCallback
000058  bd10              POP      {r4,pc}
;;;3845   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2785     */
;;;2786   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2787   {
000004  4604              MOV      r4,r0
;;;2788     uint32_t tmpreg                     = 0x00000000U;
;;;2789     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
;;;2790     uint16_t brrtemp                    = 0x0000U;
;;;2791     uint32_t usartdiv                   = 0x00000000U;
;;;2792     HAL_StatusTypeDef ret               = HAL_OK;
;;;2793     uint32_t lpuart_ker_ck_pres         = 0x00000000U;
;;;2794   
;;;2795     /* Check the parameters */
;;;2796     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2797     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;2798     if (UART_INSTANCE_LOWPOWER(huart))
000006  6800              LDR      r0,[r0,#0]
;;;2799     {
;;;2800       assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
;;;2801     }
;;;2802     else
;;;2803     {
;;;2804       assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2805       assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;2806     }
;;;2807   
;;;2808     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2809     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2810     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;2811     assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;2812   #if defined(USART_PRESC_PRESCALER)
;;;2813     assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
;;;2814   #endif
;;;2815   
;;;2816     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2817     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;2818     *  the UART Word Length, Parity, Mode and oversampling:
;;;2819     *  set the M bits according to huart->Init.WordLength value
;;;2820     *  set PCE and PS bits according to huart->Init.Parity value
;;;2821     *  set TE and RE bits according to huart->Init.Mode value
;;;2822     *  set OVER8 bit according to huart->Init.OverSampling value */
;;;2823     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000008  6923              LDR      r3,[r4,#0x10]
00000a  68a1              LDR      r1,[r4,#8]
00000c  f8d4c01c          LDR      r12,[r4,#0x1c]
000010  4319              ORRS     r1,r1,r3
000012  6963              LDR      r3,[r4,#0x14]
000014  2510              MOVS     r5,#0x10              ;2789
000016  2600              MOVS     r6,#0                 ;2791
000018  ea43030c          ORR      r3,r3,r12
00001c  4319              ORRS     r1,r1,r3
00001e  4a9b              LDR      r2,|L56.652|
;;;2824   #if defined(USART_CR1_FIFOEN)
;;;2825     tmpreg |= (uint32_t)huart->FifoMode;
;;;2826   #endif
;;;2827     MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
000020  6803              LDR      r3,[r0,#0]
000022  4637              MOV      r7,r6                 ;2792
000024  f8dfc268          LDR      r12,|L56.656|
000028  ea03030c          AND      r3,r3,r12
00002c  430b              ORRS     r3,r3,r1
00002e  6003              STR      r3,[r0,#0]
;;;2828   
;;;2829     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;2830     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;2831     * to huart->Init.StopBits value */
;;;2832     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000030  6820              LDR      r0,[r4,#0]
000032  6841              LDR      r1,[r0,#4]
000034  68e3              LDR      r3,[r4,#0xc]
000036  f4215140          BIC      r1,r1,#0x3000
00003a  4319              ORRS     r1,r1,r3
00003c  6041              STR      r1,[r0,#4]
;;;2833   
;;;2834     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;2835     /* Configure
;;;2836     * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;2837     *   to huart->Init.HwFlowCtl value
;;;2838     * - one-bit sampling method versus three samples' majority rule according
;;;2839     *   to huart->Init.OneBitSampling (not applicable to LPUART) */
;;;2840     tmpreg = (uint32_t)huart->Init.HwFlowCtl;
;;;2841   
;;;2842     if (!(UART_INSTANCE_LOWPOWER(huart)))
00003e  6821              LDR      r1,[r4,#0]
000040  69a0              LDR      r0,[r4,#0x18]
000042  4291              CMP      r1,r2
000044  d001              BEQ      |L56.74|
;;;2843     {
;;;2844       tmpreg |= huart->Init.OneBitSampling;
000046  6a23              LDR      r3,[r4,#0x20]
000048  4318              ORRS     r0,r0,r3
                  |L56.74|
;;;2845     }
;;;2846     MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
00004a  688b              LDR      r3,[r1,#8]
00004c  f4236330          BIC      r3,r3,#0xb00
000050  4303              ORRS     r3,r3,r0
000052  608b              STR      r3,[r1,#8]
;;;2847   
;;;2848   #if defined(USART_PRESC_PRESCALER)
;;;2849     /*-------------------------- USART PRESC Configuration -----------------------*/
;;;2850     /* Configure
;;;2851     * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
;;;2852     MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
;;;2853   #endif
;;;2854   
;;;2855     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2856     UART_GETCLOCKSOURCE(huart, clocksource);
000054  4b8f              LDR      r3,|L56.660|
000056  6821              LDR      r1,[r4,#0]
000058  488f              LDR      r0,|L56.664|
00005a  4299              CMP      r1,r3
00005c  d10d              BNE      |L56.122|
00005e  f8d00088          LDR      r0,[r0,#0x88]
000062  f0100003          ANDS     r0,r0,#3
000066  d006              BEQ      |L56.118|
000068  2801              CMP      r0,#1
00006a  d05a              BEQ      |L56.290|
00006c  2802              CMP      r0,#2
00006e  d056              BEQ      |L56.286|
000070  2803              CMP      r0,#3
000072  d159              BNE      |L56.296|
000074  e057              B        |L56.294|
                  |L56.118|
000076  2501              MOVS     r5,#1
000078  e056              B        |L56.296|
                  |L56.122|
00007a  4b88              LDR      r3,|L56.668|
00007c  4299              CMP      r1,r3
00007e  d10b              BNE      |L56.152|
000080  f8d00088          LDR      r0,[r0,#0x88]
000084  f010000c          ANDS     r0,r0,#0xc
000088  d047              BEQ      |L56.282|
00008a  2804              CMP      r0,#4
00008c  d049              BEQ      |L56.290|
00008e  2808              CMP      r0,#8
000090  d045              BEQ      |L56.286|
000092  280c              CMP      r0,#0xc
000094  d148              BNE      |L56.296|
000096  e046              B        |L56.294|
                  |L56.152|
000098  4b81              LDR      r3,|L56.672|
00009a  4299              CMP      r1,r3
00009c  d10b              BNE      |L56.182|
00009e  f8d00088          LDR      r0,[r0,#0x88]
0000a2  f0100030          ANDS     r0,r0,#0x30
0000a6  d038              BEQ      |L56.282|
0000a8  2810              CMP      r0,#0x10
0000aa  d03a              BEQ      |L56.290|
0000ac  2820              CMP      r0,#0x20
0000ae  d036              BEQ      |L56.286|
0000b0  2830              CMP      r0,#0x30
0000b2  d139              BNE      |L56.296|
0000b4  e037              B        |L56.294|
                  |L56.182|
0000b6  4b7b              LDR      r3,|L56.676|
0000b8  4299              CMP      r1,r3
0000ba  d10b              BNE      |L56.212|
0000bc  f8d00088          LDR      r0,[r0,#0x88]
0000c0  f01000c0          ANDS     r0,r0,#0xc0
0000c4  d029              BEQ      |L56.282|
0000c6  2840              CMP      r0,#0x40
0000c8  d02b              BEQ      |L56.290|
0000ca  2880              CMP      r0,#0x80
0000cc  d027              BEQ      |L56.286|
0000ce  28c0              CMP      r0,#0xc0
0000d0  d12a              BNE      |L56.296|
0000d2  e028              B        |L56.294|
                  |L56.212|
0000d4  4b74              LDR      r3,|L56.680|
0000d6  4299              CMP      r1,r3
0000d8  d10e              BNE      |L56.248|
0000da  f8d00088          LDR      r0,[r0,#0x88]
0000de  f4107040          ANDS     r0,r0,#0x300
0000e2  d01a              BEQ      |L56.282|
0000e4  f5b07f80          CMP      r0,#0x100
0000e8  d01b              BEQ      |L56.290|
0000ea  f5b07f00          CMP      r0,#0x200
0000ee  d016              BEQ      |L56.286|
0000f0  f5b07f40          CMP      r0,#0x300
0000f4  d118              BNE      |L56.296|
0000f6  e016              B        |L56.294|
                  |L56.248|
0000f8  4291              CMP      r1,r2
0000fa  d115              BNE      |L56.296|
0000fc  f8d00088          LDR      r0,[r0,#0x88]
000100  f4106040          ANDS     r0,r0,#0xc00
000104  d009              BEQ      |L56.282|
000106  f5b06f80          CMP      r0,#0x400
00010a  d00a              BEQ      |L56.290|
00010c  f5b06f00          CMP      r0,#0x800
000110  d005              BEQ      |L56.286|
000112  f5b06f40          CMP      r0,#0xc00
000116  d107              BNE      |L56.296|
000118  e005              B        |L56.294|
                  |L56.282|
00011a  2500              MOVS     r5,#0
00011c  e004              B        |L56.296|
                  |L56.286|
00011e  2502              MOVS     r5,#2
000120  e002              B        |L56.296|
                  |L56.290|
000122  2504              MOVS     r5,#4
000124  e000              B        |L56.296|
                  |L56.294|
000126  2508              MOVS     r5,#8
                  |L56.296|
;;;2857   
;;;2858     /* Check LPUART instance */
;;;2859     if (UART_INSTANCE_LOWPOWER(huart))
;;;2860     {
;;;2861       /* Retrieve frequency clock */
;;;2862       switch (clocksource)
;;;2863       {
;;;2864         case UART_CLOCKSOURCE_PCLK1:
;;;2865   #if defined(USART_PRESC_PRESCALER)
;;;2866           lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
;;;2867   #else
;;;2868           lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
;;;2869   #endif
;;;2870           break;
;;;2871         case UART_CLOCKSOURCE_HSI:
;;;2872   #if defined(USART_PRESC_PRESCALER)
;;;2873           lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
;;;2874   #else
;;;2875           lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
000128  4b60              LDR      r3,|L56.684|
00012a  f04f0800          MOV      r8,#0
;;;2876   #endif
;;;2877           break;
;;;2878         case UART_CLOCKSOURCE_SYSCLK:
;;;2879   #if defined(USART_PRESC_PRESCALER)
;;;2880           lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
;;;2881   #else
;;;2882           lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
;;;2883   #endif
;;;2884           break;
;;;2885         case UART_CLOCKSOURCE_LSE:
;;;2886   #if defined(USART_PRESC_PRESCALER)
;;;2887           lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
;;;2888   #else
;;;2889           lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
00012e  f44f4000          MOV      r0,#0x8000
000132  4291              CMP      r1,r2                 ;2859
000134  d144              BNE      |L56.448|
000136  b135              CBZ      r5,|L56.326|
000138  2d02              CMP      r5,#2                 ;2862
00013a  d007              BEQ      |L56.332|
00013c  2d04              CMP      r5,#4                 ;2862
00013e  d007              BEQ      |L56.336|
000140  2d08              CMP      r5,#8                 ;2862
000142  d110              BNE      |L56.358|
000144  e007              B        |L56.342|
                  |L56.326|
000146  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00014a  e003              B        |L56.340|
                  |L56.332|
00014c  4618              MOV      r0,r3                 ;2875
00014e  e002              B        |L56.342|
                  |L56.336|
000150  f7fffffe          BL       HAL_RCC_GetSysClockFreq
                  |L56.340|
;;;2890   #endif
;;;2891           break;
;;;2892         case UART_CLOCKSOURCE_UNDEFINED:
;;;2893         default:
;;;2894           ret = HAL_ERROR;
;;;2895           break;
;;;2896       }
;;;2897   
;;;2898       /* if proper clock source reported */
;;;2899       if (lpuart_ker_ck_pres != 0U)
000154  b398              CBZ      r0,|L56.446|
                  |L56.342|
;;;2900       {
;;;2901         /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
;;;2902         if ((lpuart_ker_ck_pres < (3 * huart->Init.BaudRate)) ||
000156  6862              LDR      r2,[r4,#4]
000158  eb020142          ADD      r1,r2,r2,LSL #1
00015c  4281              CMP      r1,r0
00015e  d802              BHI      |L56.358|
;;;2903             (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate)))
000160  ebb03f02          CMP      r0,r2,LSL #12
000164  d901              BLS      |L56.362|
                  |L56.358|
000166  2701              MOVS     r7,#1                 ;2894
000168  e089              B        |L56.638|
                  |L56.362|
;;;2904         {
;;;2905           ret = HAL_ERROR;
;;;2906         }
;;;2907         else
;;;2908         {
;;;2909           switch (clocksource)
00016a  b165              CBZ      r5,|L56.390|
00016c  2d02              CMP      r5,#2
00016e  d00d              BEQ      |L56.396|
000170  2d04              CMP      r5,#4
000172  d013              BEQ      |L56.412|
000174  2d08              CMP      r5,#8
000176  d01b              BEQ      |L56.432|
;;;2910           {
;;;2911             case UART_CLOCKSOURCE_PCLK1:
;;;2912   #if defined(USART_PRESC_PRESCALER)
;;;2913               usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2914   #else
;;;2915               usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
;;;2916   #endif
;;;2917               break;
;;;2918             case UART_CLOCKSOURCE_HSI:
;;;2919   #if defined(USART_PRESC_PRESCALER)
;;;2920               usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2921   #else
;;;2922               usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
;;;2923   #endif
;;;2924               break;
;;;2925             case UART_CLOCKSOURCE_SYSCLK:
;;;2926   #if defined(USART_PRESC_PRESCALER)
;;;2927               usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2928   #else
;;;2929               usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
;;;2930   #endif
;;;2931               break;
;;;2932             case UART_CLOCKSOURCE_LSE:
;;;2933   #if defined(USART_PRESC_PRESCALER)
;;;2934               usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2935   #else
;;;2936               usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
;;;2937   #endif
;;;2938               break;
;;;2939             case UART_CLOCKSOURCE_UNDEFINED:
;;;2940             default:
;;;2941               ret = HAL_ERROR;
000178  2701              MOVS     r7,#1
                  |L56.378|
;;;2942               break;
;;;2943           }
;;;2944   
;;;2945           /* It is forbidden to write values lower than 0x300 in the LPUART_BRR register */
;;;2946           if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
00017a  494d              LDR      r1,|L56.688|
00017c  f5a67040          SUB      r0,r6,#0x300
000180  4288              CMP      r0,r1
000182  d97a              BLS      |L56.634|
                  |L56.388|
000184  e7ef              B        |L56.358|
                  |L56.390|
000186  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00018a  e009              B        |L56.416|
                  |L56.396|
00018c  0850              LSRS     r0,r2,#1              ;2922
00018e  4b49              LDR      r3,|L56.692|
000190  e011              B        |L56.438|
                  |L56.402|
000192  2300              MOVS     r3,#0                 ;2915
000194  f7fffffe          BL       __aeabi_uldivmod
000198  4606              MOV      r6,r0                 ;2915
00019a  e7ee              B        |L56.378|
                  |L56.412|
00019c  f7fffffe          BL       HAL_RCC_GetSysClockFreq
                  |L56.416|
0001a0  6862              LDR      r2,[r4,#4]            ;2929
0001a2  0e01              LSRS     r1,r0,#24             ;2929
0001a4  0205              LSLS     r5,r0,#8              ;2929
0001a6  0850              LSRS     r0,r2,#1              ;2929
0001a8  1828              ADDS     r0,r5,r0              ;2929
0001aa  eb410108          ADC      r1,r1,r8              ;2929
0001ae  e7f0              B        |L56.402|
                  |L56.432|
0001b0  0850              LSRS     r0,r2,#1              ;2936
0001b2  f44f0300          MOV      r3,#0x800000          ;2936
                  |L56.438|
0001b6  18c0              ADDS     r0,r0,r3              ;2936
0001b8  f1480100          ADC      r1,r8,#0              ;2936
0001bc  e7e9              B        |L56.402|
                  |L56.446|
0001be  e05e              B        |L56.638|
                  |L56.448|
;;;2947           {
;;;2948             huart->Instance->BRR = usartdiv;
;;;2949           }
;;;2950           else
;;;2951           {
;;;2952             ret = HAL_ERROR;
;;;2953           }
;;;2954         }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
;;;2955       } /* if (tmpreg != 0) */
;;;2956     }
;;;2957     /* Check UART Over Sampling to set Baud Rate Register */
;;;2958     else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
0001c0  69e1              LDR      r1,[r4,#0x1c]
;;;2959     {
;;;2960       switch (clocksource)
;;;2961       {
;;;2962         case UART_CLOCKSOURCE_PCLK1:
;;;2963   #if defined(USART_PRESC_PRESCALER)
;;;2964           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2965   #else
;;;2966           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
;;;2967   #endif
;;;2968           break;
;;;2969         case UART_CLOCKSOURCE_PCLK2:
;;;2970   #if defined(USART_PRESC_PRESCALER)
;;;2971           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2972   #else
;;;2973           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
;;;2974   #endif
;;;2975           break;
;;;2976         case UART_CLOCKSOURCE_HSI:
;;;2977   #if defined(USART_PRESC_PRESCALER)
;;;2978           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2979   #else
;;;2980           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
;;;2981   #endif
;;;2982           break;
;;;2983         case UART_CLOCKSOURCE_SYSCLK:
;;;2984   #if defined(USART_PRESC_PRESCALER)
;;;2985           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2986   #else
;;;2987           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
;;;2988   #endif
;;;2989           break;
;;;2990         case UART_CLOCKSOURCE_LSE:
;;;2991   #if defined(USART_PRESC_PRESCALER)
;;;2992           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;2993   #else
;;;2994           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
;;;2995   #endif
;;;2996           break;
;;;2997         case UART_CLOCKSOURCE_UNDEFINED:
;;;2998         default:
;;;2999           ret = HAL_ERROR;
;;;3000           break;
;;;3001       }
;;;3002   
;;;3003       /* USARTDIV must be greater than or equal to 0d16 */
;;;3004       if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
0001c2  f64f79ef          MOV      r9,#0xffef
0001c6  4281              CMP      r1,r0                 ;2958
0001c8  d12e              BNE      |L56.552|
0001ca  2d09              CMP      r5,#9                 ;2960
0001cc  d21d              BCS      |L56.522|
0001ce  e8dff005          TBB      [pc,r5]               ;2960
0001d2  0508              DCB      0x05,0x08
0001d4  121c151c          DCB      0x12,0x1c,0x15,0x1c
0001d8  1c1c1800          DCB      0x1c,0x1c,0x18,0x00
0001dc  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001e0  e001              B        |L56.486|
0001e2  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
                  |L56.486|
0001e6  0041              LSLS     r1,r0,#1              ;2966
0001e8  6860              LDR      r0,[r4,#4]            ;2966
                  |L56.490|
0001ea  eb010150          ADD      r1,r1,r0,LSR #1       ;2966
0001ee  fbb1f0f0          UDIV     r0,r1,r0              ;2966
0001f2  b286              UXTH     r6,r0                 ;2966
0001f4  e00a              B        |L56.524|
0001f6  4930              LDR      r1,|L56.696|
0001f8  6860              LDR      r0,[r4,#4]            ;2982
0001fa  e7f6              B        |L56.490|
0001fc  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000200  e7f1              B        |L56.486|
000202  f44f3180          MOV      r1,#0x10000           ;2994
000206  6860              LDR      r0,[r4,#4]            ;2996
000208  e7ef              B        |L56.490|
                  |L56.522|
00020a  2701              MOVS     r7,#1                 ;2999
                  |L56.524|
00020c  f1a60010          SUB      r0,r6,#0x10
000210  4548              CMP      r0,r9
000212  d8a8              BHI      |L56.358|
;;;3005       {
;;;3006         brrtemp = usartdiv & 0xFFF0U;
000214  f64f71f0          MOV      r1,#0xfff0
000218  ea060001          AND      r0,r6,r1
;;;3007         brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
00021c  f3c60142          UBFX     r1,r6,#1,#3
000220  4308              ORRS     r0,r0,r1
;;;3008         huart->Instance->BRR = brrtemp;
000222  6821              LDR      r1,[r4,#0]
000224  60c8              STR      r0,[r1,#0xc]
000226  e02a              B        |L56.638|
                  |L56.552|
;;;3009       }
;;;3010       else
;;;3011       {
;;;3012         ret = HAL_ERROR;
;;;3013       }
;;;3014     }
;;;3015     else
;;;3016     {
;;;3017       switch (clocksource)
000228  2d09              CMP      r5,#9
00022a  d221              BCS      |L56.624|
00022c  e8dff005          TBB      [pc,r5]
000230  05081220          DCB      0x05,0x08,0x12,0x20
000234  16202020          DCB      0x16,0x20,0x20,0x20
000238  1a00              DCB      0x1a,0x00
;;;3018       {
;;;3019         case UART_CLOCKSOURCE_PCLK1:
;;;3020   #if defined(USART_PRESC_PRESCALER)
;;;3021           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3022   #else
;;;3023           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
00023a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
;;;3024   #endif
;;;3025           break;
00023e  e001              B        |L56.580|
;;;3026         case UART_CLOCKSOURCE_PCLK2:
;;;3027   #if defined(USART_PRESC_PRESCALER)
;;;3028           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3029   #else
;;;3030           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
000240  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
                  |L56.580|
000244  4601              MOV      r1,r0                 ;3023
000246  6860              LDR      r0,[r4,#4]            ;3023
000248  eb010150          ADD      r1,r1,r0,LSR #1       ;3023
                  |L56.588|
00024c  fbb1f0f0          UDIV     r0,r1,r0              ;3023
                  |L56.592|
000250  b286              UXTH     r6,r0                 ;3023
000252  e00e              B        |L56.626|
;;;3031   #endif
;;;3032           break;
;;;3033         case UART_CLOCKSOURCE_HSI:
;;;3034   #if defined(USART_PRESC_PRESCALER)
;;;3035           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3036   #else
;;;3037           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
000254  6860              LDR      r0,[r4,#4]
000256  eb030150          ADD      r1,r3,r0,LSR #1
;;;3038   #endif
;;;3039           break;
00025a  e7f7              B        |L56.588|
;;;3040         case UART_CLOCKSOURCE_SYSCLK:
;;;3041   #if defined(USART_PRESC_PRESCALER)
;;;3042           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3043   #else
;;;3044           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
00025c  f7fffffe          BL       HAL_RCC_GetSysClockFreq
;;;3045   #endif
;;;3046           break;
000260  e7f0              B        |L56.580|
000262  e00a              B        |L56.634|
;;;3047         case UART_CLOCKSOURCE_LSE:
;;;3048   #if defined(USART_PRESC_PRESCALER)
;;;3049           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3050   #else
;;;3051           usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
000264  6861              LDR      r1,[r4,#4]
000266  eb000051          ADD      r0,r0,r1,LSR #1
00026a  fbb0f0f1          UDIV     r0,r0,r1
;;;3052   #endif
;;;3053           break;
00026e  e7ef              B        |L56.592|
                  |L56.624|
;;;3054         case UART_CLOCKSOURCE_UNDEFINED:
;;;3055         default:
;;;3056           ret = HAL_ERROR;
000270  2701              MOVS     r7,#1
                  |L56.626|
;;;3057           break;
;;;3058       }
;;;3059   
;;;3060       /* USARTDIV must be greater than or equal to 0d16 */
;;;3061       if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
000272  f1a60010          SUB      r0,r6,#0x10
000276  4548              CMP      r0,r9
000278  d884              BHI      |L56.388|
                  |L56.634|
;;;3062       {
;;;3063         huart->Instance->BRR = usartdiv;
00027a  6820              LDR      r0,[r4,#0]
00027c  60c6              STR      r6,[r0,#0xc]
                  |L56.638|
;;;3064       }
;;;3065       else
;;;3066       {
;;;3067         ret = HAL_ERROR;
;;;3068       }
;;;3069     }
;;;3070   
;;;3071   #if defined(USART_CR1_FIFOEN)
;;;3072     /* Initialize the number of data to process during RX/TX ISR execution */
;;;3073     huart->NbTxDataToProcess = 1;
;;;3074     huart->NbRxDataToProcess = 1;
;;;3075   #endif
;;;3076   
;;;3077     /* Clear ISR function pointers */
;;;3078     huart->RxISR = NULL;
;;;3079     huart->TxISR = NULL;
00027e  f8c48060          STR      r8,[r4,#0x60]
;;;3080   
;;;3081     return ret;
000282  4638              MOV      r0,r7
000284  f8c48064          STR      r8,[r4,#0x64]
;;;3082   }
000288  e8bd87f0          POP      {r4-r10,pc}
;;;3083   
                          ENDP

                  |L56.652|
                          DCD      0x40008000
                  |L56.656|
                          DCD      0xefff69f3
                  |L56.660|
                          DCD      0x40013800
                  |L56.664|
                          DCD      0x40021000
                  |L56.668|
                          DCD      0x40004400
                  |L56.672|
                          DCD      0x40004800
                  |L56.676|
                          DCD      0x40004c00
                  |L56.680|
                          DCD      0x40005000
                  |L56.684|
                          DCD      0x00f42400
                  |L56.688|
                          DCD      0x000ffcff
                  |L56.692|
                          DCD      0xf4240000
                  |L56.696|
                          DCD      0x01e84800

                          AREA ||i.UART_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  UART_TxISR_16BIT PROC
;;;3665     */
;;;3666   static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
000000  f8901071          LDRB     r1,[r0,#0x71]
;;;3667   {
;;;3668     uint16_t *tmp;
;;;3669   
;;;3670     /* Check that a Tx process is ongoing */
;;;3671     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d110              BNE      |L57.42|
;;;3672     {
;;;3673       if (huart->TxXferCount == 0)
000008  f8b01052          LDRH     r1,[r0,#0x52]
00000c  b171              CBZ      r1,|L57.44|
;;;3674       {
;;;3675         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;3676   #if defined(USART_CR1_FIFOEN)
;;;3677         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;3678   #else
;;;3679         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;3680   #endif
;;;3681   
;;;3682         /* Enable the UART Transmit Complete Interrupt */
;;;3683         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;3684       }
;;;3685       else
;;;3686       {
;;;3687         tmp = (uint16_t *) huart->pTxBuffPtr;
;;;3688         huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
00000e  6cc1              LDR      r1,[r0,#0x4c]
000010  6802              LDR      r2,[r0,#0]
000012  8809              LDRH     r1,[r1,#0]
000014  f3c10108          UBFX     r1,r1,#0,#9
000018  8511              STRH     r1,[r2,#0x28]
;;;3689         huart->pTxBuffPtr += 2;
00001a  6cc1              LDR      r1,[r0,#0x4c]
00001c  1c89              ADDS     r1,r1,#2
;;;3690         huart->TxXferCount--;
00001e  64c1              STR      r1,[r0,#0x4c]
000020  f8b01052          LDRH     r1,[r0,#0x52]
000024  1e49              SUBS     r1,r1,#1
000026  f8a01052          STRH     r1,[r0,#0x52]
                  |L57.42|
;;;3691       }
;;;3692     }
;;;3693   }
00002a  4770              BX       lr
                  |L57.44|
00002c  6801              LDR      r1,[r0,#0]            ;3679
00002e  680a              LDR      r2,[r1,#0]            ;3679
000030  f0220280          BIC      r2,r2,#0x80           ;3679
000034  600a              STR      r2,[r1,#0]            ;3679
000036  6800              LDR      r0,[r0,#0]            ;3683
000038  6801              LDR      r1,[r0,#0]            ;3683
00003a  f0410140          ORR      r1,r1,#0x40           ;3683
00003e  6001              STR      r1,[r0,#0]            ;3683
000040  4770              BX       lr
;;;3694   
                          ENDP


                          AREA ||i.UART_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  UART_TxISR_8BIT PROC
;;;3633     */
;;;3634   static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
000000  f8901071          LDRB     r1,[r0,#0x71]
;;;3635   {
;;;3636     /* Check that a Tx process is ongoing */
;;;3637     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d10d              BNE      |L58.36|
;;;3638     {
;;;3639       if (huart->TxXferCount == 0)
000008  f8b01052          LDRH     r1,[r0,#0x52]
00000c  b159              CBZ      r1,|L58.38|
;;;3640       {
;;;3641         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;3642   #if defined(USART_CR1_FIFOEN)
;;;3643         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;3644   #else
;;;3645         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;3646   #endif
;;;3647   
;;;3648         /* Enable the UART Transmit Complete Interrupt */
;;;3649         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;3650       }
;;;3651       else
;;;3652       {
;;;3653         huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFF);
00000e  6cc1              LDR      r1,[r0,#0x4c]
000010  1c4a              ADDS     r2,r1,#1
000012  64c2              STR      r2,[r0,#0x4c]
000014  6802              LDR      r2,[r0,#0]
000016  7809              LDRB     r1,[r1,#0]
000018  8511              STRH     r1,[r2,#0x28]
;;;3654         huart->TxXferCount--;
00001a  f8b01052          LDRH     r1,[r0,#0x52]
00001e  1e49              SUBS     r1,r1,#1
000020  f8a01052          STRH     r1,[r0,#0x52]
                  |L58.36|
;;;3655       }
;;;3656     }
;;;3657   }
000024  4770              BX       lr
                  |L58.38|
000026  6801              LDR      r1,[r0,#0]            ;3645
000028  680a              LDR      r2,[r1,#0]            ;3645
00002a  f0220280          BIC      r2,r2,#0x80           ;3645
00002e  600a              STR      r2,[r1,#0]            ;3645
000030  6800              LDR      r0,[r0,#0]            ;3649
000032  6801              LDR      r1,[r0,#0]            ;3649
000034  f0410140          ORR      r1,r1,#0x40           ;3649
000038  6001              STR      r1,[r0,#0]            ;3649
00003a  4770              BX       lr
;;;3658   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;3212     */
;;;3213   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3214   {
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  4688              MOV      r8,r1
00000a  4604              MOV      r4,r0
;;;3215     /* Wait until flag is set */
;;;3216     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
;;;3217     {
;;;3218       /* Check for the Timeout */
;;;3219       if (Timeout != HAL_MAX_DELAY)
;;;3220       {
;;;3221         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
;;;3222         {
;;;3223           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;3224   #if defined(USART_CR1_FIFOEN)
;;;3225           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
;;;3226   #else
;;;3227           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;3228   #endif
;;;3229           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;3230   
;;;3231           huart->gState = HAL_UART_STATE_READY;
;;;3232           huart->RxState = HAL_UART_STATE_READY;
;;;3233   
;;;3234           /* Process Unlocked */
;;;3235           __HAL_UNLOCK(huart);
;;;3236   
;;;3237           return HAL_TIMEOUT;
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  e01c              B        |L59.74|
                  |L59.16|
000010  1c68              ADDS     r0,r5,#1              ;3219
000012  d01a              BEQ      |L59.74|
000014  b125              CBZ      r5,|L59.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6              ;3221
00001c  42a8              CMP      r0,r5                 ;3221
00001e  d914              BLS      |L59.74|
                  |L59.32|
000020  6820              LDR      r0,[r4,#0]            ;3227
000022  6801              LDR      r1,[r0,#0]            ;3227
000024  f42171d0          BIC      r1,r1,#0x1a0          ;3227
000028  6001              STR      r1,[r0,#0]            ;3227
00002a  6820              LDR      r0,[r4,#0]            ;3229
00002c  6881              LDR      r1,[r0,#8]            ;3229
00002e  f0210101          BIC      r1,r1,#1              ;3229
000032  6081              STR      r1,[r0,#8]            ;3229
000034  2020              MOVS     r0,#0x20              ;3231
000036  f8840071          STRB     r0,[r4,#0x71]         ;3231
00003a  f8840072          STRB     r0,[r4,#0x72]         ;3232
00003e  2000              MOVS     r0,#0                 ;3235
000040  f8840070          STRB     r0,[r4,#0x70]         ;3235
000044  2003              MOVS     r0,#3
                  |L59.70|
;;;3238         }
;;;3239       }
;;;3240     }
;;;3241     return HAL_OK;
;;;3242   }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L59.74|
00004a  6820              LDR      r0,[r4,#0]            ;3216
00004c  69c1              LDR      r1,[r0,#0x1c]         ;3216
00004e  ea380001          BICS     r0,r8,r1              ;3216
000052  d004              BEQ      |L59.94|
000054  2000              MOVS     r0,#0                 ;3216
                  |L59.86|
000056  42b8              CMP      r0,r7                 ;3216
000058  d0da              BEQ      |L59.16|
00005a  2000              MOVS     r0,#0                 ;3241
00005c  e7f3              B        |L59.70|
                  |L59.94|
00005e  2001              MOVS     r0,#1                 ;3216
000060  e7f9              B        |L59.86|
;;;3243   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___20_stm32l4xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32l4xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32l4xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
