L 1 "..\App\src\M_CO_LEDs.c"
N/*
N * @Author: magyu
N * @Date: 2023-03-08 16:23:18
N * @LastEditors: magyu
N * @LastEditTime: 2023-03-10 20:30:46
N * @Description: M_CO_LED 使用CANOPEN协议中LED指示器部分代码
N * @Version: 0.1 2023/3/8 初步构建 
N */
N
N#include "M_CO_LEDs.h"
L 1 "..\App\src\M_CO_LEDs.h" 1
N/*
N * @Author: magyu
N * @Date: 2023-03-08 16:23:10
N * @LastEditors: magyu
N * @LastEditTime: 2023-03-10 20:30:36
N * @Description: 请填写简介
N */
N
N#ifndef M_CO_LEDS_H
N#define M_CO_LEDS_H
N
N#include "M_CO_driver.h"
L 1 "..\App\src\M_CO_driver.h" 1
N/*
N * @Author: magyu
N * @Date: 2023-03-08 17:24:26
N * @LastEditors: magyu
N * @LastEditTime: 2023-03-08 17:46:58
N * @Description: 请填写简介
N */
N
N
N#ifndef M_CO_DRIVER_H
N#define M_CO_DRIVER_H
N
N#include <string.h>
L 1 "F:\KEIL5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 14 "..\App\src\M_CO_driver.h" 2
N
N
N/* NULL is defined in stddef.h */
N/* true and false are defined in stdbool.h */
N/* int8_t to uint64_t are defined in stdint.h */
Ntypedef unsigned char           bool_t;
Ntypedef float                   float32_t;
Ntypedef double                  float64_t;
N
N
N/**
N * Internal System management state
N */
Ntypedef enum {
N    /** -1, Device state is unknown (for heartbeat consumer) */
N    CO_SMT_UNKNOWN = -1,
N    /** 0, Device is initializing */
N    CO_SMT_INITIALIZING = 0,
N    /** 127, Device is in pre-operational state */
N    CO_SMT_PRE_OPERATIONAL = 127,
N    /** 5, Device is in operational state */
N    CO_SMT_OPERATIONAL = 5,
N    /** 4, Device is stopped */
N    CO_SMT_STOPPED = 4
N} M_CO_SMT_internalState_t;
N
N
N/**
N * CAN error status bitmasks.
N *
N * CAN warning level is reached, if CAN transmit or receive error counter is
N * more or equal to 96. CAN passive level is reached, if counters are more or
N * equal to 128. Transmitter goes in error state 'bus off' if transmit error
N * counter is more or equal to 256.
N */
Ntypedef enum {
N    CO_CAN_ERRTX_WARNING = 0x0001,  /**< 0x0001, CAN transmitter warning */
N    CO_CAN_ERRTX_PASSIVE = 0x0002,  /**< 0x0002, CAN transmitter passive */
N    CO_CAN_ERRTX_BUS_OFF = 0x0004,  /**< 0x0004, CAN transmitter bus off */
N    CO_CAN_ERRTX_OVERFLOW = 0x0008, /**< 0x0008, CAN transmitter overflow */
N
N    CO_CAN_ERRTX_PDO_LATE = 0x0080, /**< 0x0080, TPDO is outside sync window */
N
N    CO_CAN_ERRRX_WARNING = 0x0100,  /**< 0x0100, CAN receiver warning */
N    CO_CAN_ERRRX_PASSIVE = 0x0200,  /**< 0x0200, CAN receiver passive */
N    CO_CAN_ERRRX_OVERFLOW = 0x0800, /**< 0x0800, CAN receiver overflow */
N
N    CO_CAN_ERR_WARN_PASSIVE = 0x0303/**< 0x0303, combination */
N} M_CO_CAN_ERR_status_t;
N
N/**
N * Return values of some CANopen functions. If function was executed
N * successfully it returns 0 otherwise it returns <0.
N */
Ntypedef enum {
N    CO_ERROR_NO = 0,                /**< Operation completed successfully */
N    CO_ERROR_ILLEGAL_ARGUMENT = -1, /**< Error in function arguments */
N    CO_ERROR_OUT_OF_MEMORY = -2,    /**< Memory allocation failed */
N    CO_ERROR_TIMEOUT = -3,          /**< Function timeout */
N    CO_ERROR_ILLEGAL_BAUDRATE = -4, /**< Illegal baudrate passed to function
N                                         CO_CANmodule_init() */
N    CO_ERROR_RX_OVERFLOW = -5,      /**< Previous message was not processed
N                                         yet */
N    CO_ERROR_RX_PDO_OVERFLOW = -6,  /**< previous PDO was not processed yet */
N    CO_ERROR_RX_MSG_LENGTH = -7,    /**< Wrong receive message length */
N    CO_ERROR_RX_PDO_LENGTH = -8,    /**< Wrong receive PDO length */
N    CO_ERROR_TX_OVERFLOW = -9,      /**< Previous message is still waiting,
N                                         buffer full */
N    CO_ERROR_TX_PDO_WINDOW = -10,   /**< Synchronous TPDO is outside window */
N    CO_ERROR_TX_UNCONFIGURED = -11, /**< Transmit buffer was not configured
N                                         properly */
N    CO_ERROR_OD_PARAMETERS = -12,   /**< Error in Object Dictionary parameters*/
N    CO_ERROR_DATA_CORRUPT = -13,    /**< Stored data are corrupt */
N    CO_ERROR_CRC = -14,             /**< CRC does not match */
N    CO_ERROR_TX_BUSY = -15,         /**< Sending rejected because driver is
N                                         busy. Try again */
N    CO_ERROR_WRONG_NMT_STATE = -16, /**< Command can't be processed in current
N                                         state */
N    CO_ERROR_SYSCALL = -17,         /**< Syscall failed */
N    CO_ERROR_INVALID_STATE = -18,   /**< Driver not ready */
N    CO_ERROR_NODE_ID_UNCONFIGURED_LSS = -19 /**< Node-id is in LSS unconfigured
N                                         state. If objects are handled properly,
N                                         this may not be an error. */
N} M_CO_ReturnError_t;
N
N
N
N
N#endif
N
L 13 "..\App\src\M_CO_LEDs.h" 2
N#include "M_CO_driver_target.h"
L 1 "..\App\src\M_CO_driver_target.h" 1
N/*
N * @Author: magyu
N * @Date: 2023-03-08 17:28:50
N * @LastEditors: magyu
N * @LastEditTime: 2023-03-10 20:56:07
N * @Description: 请填写简介
N */
N
N#ifndef M_CO_DRIVER_TARGET_H
N#define M_CO_DRIVER_TARGET_H
N
N#include <stddef.h>
L 1 "F:\KEIL5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 13 "..\App\src\M_CO_driver_target.h" 2
N#include <stdbool.h>
L 1 "F:\KEIL5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 14 "..\App\src\M_CO_driver_target.h" 2
N#include <stdint.h>
L 1 "F:\KEIL5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 15 "..\App\src\M_CO_driver_target.h" 2
N#include "M_CO_LEDs_System.h"
L 1 "..\App\src\M_CO_LEDs_System.h" 1
N#ifndef visualSTATE_M_CO_LEDS_SYSTEM_H
N#define visualSTATE_M_CO_LEDS_SYSTEM_H
N
N/*
N * Id:        M_CO_LEDs_System.h
N *
N * Function:  Project parts shared between the IAR Visual State systems
N *
N * This is an automatically generated file. It will be overwritten by the Coder.
N *
N * DO NOT EDIT THE FILE!
N */
N
N
N#include <limits.h>
L 1 "F:\KEIL5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060037
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 16 "..\App\src\M_CO_LEDs_System.h" 2
N
N
N#include <stdbool.h>
N
N
N#include <stdint.h>
N
N
Ntypedef enum
N{
N
N  /*
N   * Status code:     SES_OKAY.
N   *
N   * Explanation:     Function performed successfully.
N   *
N   * Solution:        None.
N   */
N  SES_OKAY = 0U,
N
N
N  /*
N   * Status code:     SES_FOUND.
N   *
N   * Explanation:     The called function has returned an identifier index number.
N   *
N   * Solution:        Process the returned identifier index number. If the
N   *                  function SEM_GetInput or SEM_GetOutput was called, the
N   *                  function can be called again to find more events or
N   *                  action expressions.
N   */
N  SES_FOUND = 1U,
N
N
N  /*
N   * Status code:     SES_ACTIVE.
N   *
N   * Explanation:     The completion code has one of the two expositions:
N   *                  1)  A state/event deduction is started, while an event
N   *                      inquiry is active. All inquired events have not been
N   *                      returned by the function SEM_GetInput.
N   *                  2)  An event inquiry is started, while a state/event
N   *                      deduction is active. All deduced action expressions 
N   *                      have not been returned by the function SEM_GetOutput 
N   *                      and the SEM_NextState has not been called in order to 
N   *                      complete the state/event deduction.
N   *
N   * Solution:        The completion code is a warning and perhaps the
N   *                  application program should be rewritten. An event inquiry
N   *                  and a state/event deduction should not be active at the
N   *                  same time.
N   */
N  SES_ACTIVE = 2U,
N
N
N  /*
N   * Error code:      SES_CONTRADICTION.
N   *
N   * Explanation:     A contradiction has been detected between two states in a
N   *                  state machine.
N   *
N   * Solution:        Check the VS System.
N   */
N  SES_CONTRADICTION = 3U,
N
N
N  /*
N   * Error code:      SES_RANGE_ERR.
N   *
N   * Explanation:     You are making a reference to an identifier that does not
N   *                  exist. Note that the first index number is 0. If the 
N   *                  VS System has 4 identifiers of the same type and you use a
N   *                  function with the variable parameter = 4, the function 
N   *                  will return an SES_RANGE_ERR error. In this case the 
N   *                  highest variable index number is 3.
N   *
N   * Solution:        The application program will check the index parameters 
N   *                  with one of the following symbols defined in the SEMBDef.h 
N   *                  file:
N   *
N   *                    VS_NOF_EVENTS
N   *                    VS_NOF_STATES
N   *                    VS_NOF_ACTION_FUNCTIONS
N   *                    VS_NOF_STATE_MACHINES
N   */
N  SES_RANGE_ERR = 4U,
N
N
N  /*
N   * Error code:      SES_TEXT_TOO_LONG.
N   *
N   * Explanation:     The requested text is longer than the specified maximum length.
N   *
N   * Solution:        Increase the maximum length.
N   */
N  SES_TEXT_TOO_LONG = 5U,
N
N
N  /*
N   * Error code:      SES_TYPE_ERR.
N   *
N   * Explanation:     A text function has been called with the wrong identifier
N   *                  type or the specified text is not included in the VS System.
N   *
N   * Solution:        Use the identifier type symbols (EVENT_TYPE, STATE_TYPE
N   *                  or ACTION_TYPE) defined in this file and remember
N   *                  to include wanted text in the VS System.
N   */
N  SES_TYPE_ERR = 6U,
N
N
N  /*
N   * Error code:      SES_EMPTY.
N   *
N   * Explanation:     No events have been given to the VSDeduct function before
N   *                  calling this function.
N   *
N   * Solution:        Call the VSDeduct function with an event number.
N   */
N  SES_EMPTY = 7U,
N
N
N  /*
N   * Error code:      SES_BUFFER_OVERFLOW.
N   *
N   * Explanation:     A destination buffer cannot hold the number of items found.
N   *
N   * Solution:        Call the function with an extended buffer as destination.
N   */
N  SES_BUFFER_OVERFLOW = 8U,
N
N
N  /*
N   * Error code:      SES_SIGNAL_QUEUE_FULL.
N   *
N   * Explanation:     Signal queue is full.
N   *
N   * Solution:        Increase the maximum signal queue size in the VS System or
N   *                  via the VS Coder signal queue size option.
N   */
N  SES_SIGNAL_QUEUE_FULL = 9U,
N
N
N  /*
N   * Error code:      SES_NOT_INITIALIZED.
N   *
N   * Explanation:     The system has not been initialized.
N   *
N   * Solution:        Call the initialization function for the VS System.
N   */
N  SES_NOT_INITIALIZED = 10U
N} VSResult;
N
N
N/* Identifier types, used when getting texts and explanations. */
Ntypedef enum { EVENT_TYPE = 0U, STATE_TYPE = 1U, ACTION_TYPE = 2U } IdentifierType;
N
N
Nchar const *VSGetSignature (void);
N
N
N#endif /* ifndef visualSTATE_M_CO_LEDS_SYSTEM_H */
L 16 "..\App\src\M_CO_driver_target.h" 2
N#include "debugLEDs.h"
L 1 "..\App\src\debugLEDs.h" 1
N#ifndef visualSTATE_DEBUGLEDS_H
N#define visualSTATE_DEBUGLEDS_H
N
N/*
N * Id:        debugLEDs.h
N *
N * Function:  Contains definitions needed for API functions.
N *
N * This is an automatically generated file. It will be overwritten by the Coder.
N *
N * DO NOT EDIT THE FILE!
N */
N
N
N#include <stddef.h>
N
N
N#include "M_CO_LEDs_System.h"
N
N
N/*
N * SEM Variable Types.
N */
Ntypedef uint8_t   SEM_EVENT_TYPE;
Ntypedef uint8_t   SEM_ACTION_EXPRESSION_TYPE;
Ntypedef uint8_t   SEM_GUARD_EXPRESSION_TYPE;
Ntypedef uint8_t   SEM_EXPLANATION_TYPE;
Ntypedef uint8_t   SEM_STATE_TYPE;
Ntypedef uint8_t   SEM_STATE_MACHINE_TYPE;
Ntypedef uint8_t   SEM_INSTANCE_TYPE;
Ntypedef uint8_t   SEM_RULE_INDEX_TYPE;
Ntypedef uint8_t   SEM_INTERNAL_TYPE;
Ntypedef uint8_t   SEM_SIGNAL_QUEUE_TYPE;
Ntypedef uint8_t   SEM_ACTION_FUNCTION_TYPE;
Ntypedef uint8_t   SEM_EVENT_GROUP_TYPE;
Ntypedef uint8_t   SEM_EGTI_TYPE;
Ntypedef uint8_t   SEM_RULE_TABLE_INDEX_TYPE;
N
N
N/*
N * Number of Identifiers.
N */
N#define VS_NOF_ACTION_FUNCTIONS          1U
N#define VS_NOF_EVENTS                    3U
N#define VS_NOF_INSTANCES                 1U
N#define VS_NOF_STATE_MACHINES            1U
N#define VS_NOF_STATES                    2U
N
N
N/*
N * Undefined State.
N */
N#define STATE_UNDEFINED                  255U
N
N
N/*
N * Undefined Event.
N */
N#define EVENT_UNDEFINED                  255U
N
N
N/*
N * Undefined Event Group.
N */
N#define EVENT_GROUP_UNDEFINED            255U
N
N
N/*
N * Event Termination ID.
N */
N#define EVENT_TERMINATION_ID             255U
N
N
N/*
N * Event Identifier Definitions.
N */
N#define SE_RESET 0U
N#define eDebugLedsSetupDone 1U
N#define eLedsProcessDone 2U
N
N
N/*
N * Name        : debugLEDsVSInitAll
N *
N * Description : The function is a wrapper to all initialization functions.
N *               The function calls the following functions in the listed
N *               order (provided the specific function exists):
N *                 SEM_Init
N *                 SEM_InitExternalVariables
N *                 SEM_InitInternalVariables
N *                 SEM_InitSignalQueue
N *                 SEM_InitInstances
N *
N * Argument    : None.
N *
N * Return      : None.
N */
Nvoid debugLEDsVSInitAll (void);
N
N
N/*
N * Name        : SEM_Init
N *
N * Description : Before calling any other functions this function must be
N *               called to initialize the VS System. In addition it is
N *               possible to call the initialization functions for the
N *               signal queue, internal variables and external variables.
N *
N * Argument    : None.
N *
N * Return      : None.
N */
Nvoid debugLEDsSEM_Init (void);
N
N
N/*
N * Name        : debugLEDsVSDeduct
N *
N * Description : The function prepares the reception of action expressions,
N *               that can be deduced on the basis of the given event, the
N *               internal current state vector and the rules in the VS
N *               System.
N *               All action expressions are deduced internally in VSDeduct
N *               by continuously calling the function SEM_GetOutput.
N *
N * Argument    : EventNo:
N *                 Event number to be processed.
N *
N *               Variable number of arguments:
N *                 Used if at least one event has a parameter.
N *                 The function call must include one argument for each type
N *                 name declared in the parameter list for each event.
N *                 
N *                 This sample declaration is for an event with three
N *                 parameters:
N *                 
N *                   EventName (uint8_t par1, char par2, int par3)
N *                 
N *                 How to call the VSDeduct function for the event
N *                 EventName:
N *                 
N *                   VSDeduct (EventName, par1, par2, par3);
N *
N * Return      : Completion code:
N *
N *                 SES_ACTIVE:
N *                   The function SEM_Inquiry has been called. All inquired
N *                   events have not been returned by the function
N *                   SEM_GetInput or SEM_GetInputAll. The state/event
N *                   deduction is okay, but the user should not call the
N *                   function SEM_GetInput before the functions
N *                   SEM_NextState or SEM_NextStateChg and SEM_Inquiry have
N *                   been called.
N *
N *                 SES_RANGE_ERR:
N *                   Event is out of range.
N *
N *                 SES_OKAY:
N *                   Success.
N */
NVSResult debugLEDsVSDeduct (SEM_EVENT_TYPE EventNo);
N
N
N/*
N * Name        : debugLEDsVSElementName
N *
N * Description : The function gets a pointer to the ASCII name of the
N *               specified identifier.
N *               The function must be enabled by its VS Coder option.
N *
N * Argument    : IdentType:
N *                 Must contain the identifier type of the identifier
N *                 number. It can be EVENT_TYPE, STATE_TYPE or ACTION_TYPE.
N *
N *               IdentNo:
N *                 Must contain the index number of an identifier.
N *
N *               Text:
N *                 Must be a pointer to a text string. If the function
N *                 terminates successfully, the text string contains the
N *                 name of the specified identifier.
N *
N * Return      : Completion code:
N *
N *                 SES_RANGE_ERR:
N *                   Identifier number is out of range.
N *
N *                 SES_TYPE_ERR:
N *                   The identifier type is not correct. Remember to include
N *                   the wanted text in the VS System and specify the
N *                   correct identifier type when calling this function.
N *
N *                 SES_OKAY:
N *                   Success.
N */
NVSResult debugLEDsVSElementName (IdentifierType IdentType, SEM_EXPLANATION_TYPE IdentNo, char const * * Text);
N
N
N/*
N * Name        : debugLEDsVSElementExpl
N *
N * Description : The funciton gets the absolute address of an ASCII
N *               explanation of the specified identifier.
N *               The function must be enabled by its VS Coder option.
N *
N * Argument    : IdentType:
N *                 Must contain the identifier type of the identifier
N *                 number. It can be EVENT_TYPE, STATE_TYPE or ACTION_TYPE.
N *
N *               IdentNo:
N *                 Must contain the index number of an identifier.
N *
N *               Text:
N *                 Must be a pointer to a char pointer. If the function
N *                 terminates successfully, the pointer contains the
N *                 absolute address of the name of the specified identifier.
N *
N * Return      : Completion code:
N *
N *                 SES_RANGE_ERR:
N *                   Identifier number is out of range.
N *
N *                 SES_TYPE_ERR:
N *                   The identifier type is not correct. Remember to include
N *                   the wanted text in the VS System and specify the
N *                   correct identifier type when calling this function.
N *
N *                 SES_OKAY:
N *                   Success.
N */
NVSResult debugLEDsVSElementExpl (IdentifierType IdentType, SEM_EXPLANATION_TYPE IdentNo, char const * * Text);
N
N
N/*
N * Name        : SEM_State
N *
N * Description : The function will return the current state of the specified
N *               state machine.
N *               The function must be enabled by its VS Coder option.
N *
N * Argument    : StateMachineNo:
N *                 State machine number.
N *
N *               StateNo:
N *                 Pointer to store the current state of the specified state
N *                 machine.
N *
N * Return      : Completion code:
N *
N *                 SES_RANGE_ERR:
N *                   State machine index is out of range.
N *
N *                 SES_FOUND:
N *                   Success. State number index found.
N */
NVSResult debugLEDsSEM_State (SEM_STATE_MACHINE_TYPE StateMachineNo, SEM_STATE_TYPE *StateNo);
N
N
N/*
N * Action Function Prototypes.
N */
Nvoid aLedsRun (void);
N
N
N#endif /* ifndef visualSTATE_DEBUGLEDS_H */
L 17 "..\App\src\M_CO_driver_target.h" 2
N#include "M_CO_LEDs.h"
L 1 "..\App\src\M_CO_LEDs.h" 1
N/*
N * @Author: magyu
N * @Date: 2023-03-08 16:23:10
N * @LastEditors: magyu
N * @LastEditTime: 2023-03-10 20:30:36
N * @Description: 请填写简介
N */
N
N#ifndef M_CO_LEDS_H
S#define M_CO_LEDS_H
S
S#include "M_CO_driver.h"
S#include "M_CO_driver_target.h"
S
S
S
S
S/** 
S * 无效的代码注释是不需要的! 
S * todo 这一部分需要修改！
S * @defgroup CO_LEDs LED indicators
S * Specified in standard CiA 303-3.
S *
S * @ingroup CO_CANopen_303
S * @{
S *
S * CIA 303-3 standard specifies indicator LED diodes, which reflects state of
S * the CANopen device. Green and red leds or bi-color led can be used.
S *
S * CANopen green led - run led:
S * - flickering: LSS configuration state is active
S * - blinking: device is in NMT pre-operational state
S * - single flash: device is in NMT stopped state
S * - triple flash: a software download is running in the device
S * - on: device is in NMT operational state
S *
S * CANopen red led - error led:
S * - off: no error
S * - flickering: LSS node id is not configured, CANopen is not initialized
S * - blinking: invalid configuration, general error
S * - single flash: CAN warning limit reached
S * - double flash: heartbeat consumer - error in remote monitored node
S * - triple flash: sync message reception timeout
S * - quadruple flash: PDO has not been received before the event timer elapsed
S * - on: CAN bus off
S *
S * To apply on/off state to led diode, use #CO_LED_RED and #CO_LED_GREEN macros.
S * For CANopen leds use CO_LED_BITFIELD_t CO_LED_CANopen. Other bitfields are
S * available for implementing custom leds.
S */
S
S/** Bitfield for combining with red or green led */
Stypedef enum {
S    CO_LED_flicker = 0x01,  /**< LED flickering 10Hz */
S    CO_LED_blink   = 0x02,  /**< LED blinking 2,5Hz */
S    CO_LED_flash_1 = 0x04,  /**< LED single flash */
S    CO_LED_flash_2 = 0x08,  /**< LED double flash */
S    CO_LED_flash_3 = 0x10,  /**< LED triple flash */
S    CO_LED_flash_4 = 0x20,  /**< LED quadruple flash */
S    CO_LED_CANopen = 0x80   /**< LED CANopen according to CiA 303-3 */
S} M_CO_LED_BITFIELD_t;
S
S/** Get on/off state for green led for specified bitfield */
S#define M_CO_LED_RED(LEDs, BITFIELD) (((LEDs)->LEDred & BITFIELD) ? 1 : 0)
S/** Get on/off state for green led for specified bitfield */
S#define M_CO_LED_GREEN(LEDs, BITFIELD) (((LEDs)->LEDgreen & BITFIELD) ? 1 : 0)
S
S
S/**
S * LEDs object, initialized by M_CO_LEDs_init()
S */
Stypedef struct{
S    uint32_t            LEDtmr50ms;     /**< 50ms led timer */
S    uint8_t             LEDtmr200ms;    /**< 200ms led timer */
S    uint8_t             LEDtmrflash_1;  /**< single flash led timer */
S    uint8_t             LEDtmrflash_2;  /**< double flash led timer */
S    uint8_t             LEDtmrflash_3;  /**< triple flash led timer */
S    uint8_t             LEDtmrflash_4;  /**< quadruple flash led timer */
S    uint8_t             LEDred;         /**< red led #M_CO_LED_BITFIELD_t */
S    uint8_t             LEDgreen;       /**< green led #M_CO_LED_BITFIELD_t */
S} M_CO_LEDs_t;
S
S/**
S * @brief 
S * 
S * Initialize LEDs object.
S * Function must be called in the system reset section.
S * 
S * @param LEDs This object will be initialized.
S * @return #M_CO_ReturnError_t#  CO_ERROR_NO or CO_ERROR_ILLEGAL_ARGUMENT.
S */
SM_CO_ReturnError_t M_CO_LEDs_init(M_CO_LEDs_t *LEDs);
S
S
S
S
S
S/**
S * @brief 
S * 
S * Process indicator states
S * Function must be called cyclically.
S * 
S * @param LEDs This object.
S * @param timeDifference_us Time difference from previous function call in [microseconds].
S * @param SMTstate SMT operating state.
S * @param SYSconfig System is in configuration state indication.
S * @param ErrPriority1 System Err indication (highest priority).
S * @param ErrPriority6 System Err indication (priority 6 ).
S * @param ErrPriority3 System Err indication (priority 3 ).
S * @param ErrPriority4 System Err indication (priority 4 ).
S * @param ErrPriority5 System Err indication (priority 5 ).
S * @param ErrOther System Err indication (lowest priority).
S * @param SYSotherState 
S */
S
Svoid M_CO_LEDs_process(M_CO_LEDs_t *LEDs,
S                     uint32_t timeDifference_us,
S                     M_CO_SMT_internalState_t SMTstate,
S                     bool_t SYSconfig,
S                     bool_t ErrPriority1,
S                     bool_t ErrPriority6,
S                     bool_t ErrPriority3,
S                     bool_t ErrPriority4,
S                     bool_t ErrPriority5,
S                     bool_t ErrOther,
S                     bool_t SYSotherState
S                     );
S
S                     
S
N#endif // M_CO_LEDS_H
L 18 "..\App\src\M_CO_driver_target.h" 2
N#include "M_CO_driver.h"
N
N
N
N
N/**
N * @brief 
N *  led 指示器初始化
N */
Nvoid debug_LEDs_System_Init(void);
N
N/**
N * @brief 
N * 
N *  led 指示器运行
N *  该函数要放在循环中
N */
Nvoid debug_LEDs_System_Run(void);
N
N/**
N * @brief 
N * 
N */
Nextern void aLedsRun (void) __attribute__((weak));
N
N
Nextern uint32_t M_CO_get_Time_Difference_us(void) __attribute__((weak));
Nextern M_CO_SMT_internalState_t M_CO_get_SMT_internalState_t(void) __attribute__((weak));
Nextern bool_t M_CO_get_SYSconfig(void) __attribute__((weak));
Nextern bool_t M_CO_get_ErrPriority1(void) __attribute__((weak));
Nextern bool_t M_CO_get_ErrPriority5(void) __attribute__((weak));
Nextern bool_t M_CO_get_ErrPriority4(void) __attribute__((weak));
Nextern bool_t M_CO_get_ErrPriority3(void) __attribute__((weak));
Nextern bool_t M_CO_get_ErrPriority6(void) __attribute__((weak));
Nextern bool_t M_CO_get_ErrOther(void) __attribute__((weak));
Nextern bool_t M_CO_get_SYSotherState(void) __attribute__((weak));
N
N
N
N#endif
N
L 14 "..\App\src\M_CO_LEDs.h" 2
N
N
N
N
N/** 
N * 无效的代码注释是不需要的! 
N * todo 这一部分需要修改！
N * @defgroup CO_LEDs LED indicators
N * Specified in standard CiA 303-3.
N *
N * @ingroup CO_CANopen_303
N * @{
N *
N * CIA 303-3 standard specifies indicator LED diodes, which reflects state of
N * the CANopen device. Green and red leds or bi-color led can be used.
N *
N * CANopen green led - run led:
N * - flickering: LSS configuration state is active
N * - blinking: device is in NMT pre-operational state
N * - single flash: device is in NMT stopped state
N * - triple flash: a software download is running in the device
N * - on: device is in NMT operational state
N *
N * CANopen red led - error led:
N * - off: no error
N * - flickering: LSS node id is not configured, CANopen is not initialized
N * - blinking: invalid configuration, general error
N * - single flash: CAN warning limit reached
N * - double flash: heartbeat consumer - error in remote monitored node
N * - triple flash: sync message reception timeout
N * - quadruple flash: PDO has not been received before the event timer elapsed
N * - on: CAN bus off
N *
N * To apply on/off state to led diode, use #CO_LED_RED and #CO_LED_GREEN macros.
N * For CANopen leds use CO_LED_BITFIELD_t CO_LED_CANopen. Other bitfields are
N * available for implementing custom leds.
N */
N
N/** Bitfield for combining with red or green led */
Ntypedef enum {
N    CO_LED_flicker = 0x01,  /**< LED flickering 10Hz */
N    CO_LED_blink   = 0x02,  /**< LED blinking 2,5Hz */
N    CO_LED_flash_1 = 0x04,  /**< LED single flash */
N    CO_LED_flash_2 = 0x08,  /**< LED double flash */
N    CO_LED_flash_3 = 0x10,  /**< LED triple flash */
N    CO_LED_flash_4 = 0x20,  /**< LED quadruple flash */
N    CO_LED_CANopen = 0x80   /**< LED CANopen according to CiA 303-3 */
N} M_CO_LED_BITFIELD_t;
N
N/** Get on/off state for green led for specified bitfield */
N#define M_CO_LED_RED(LEDs, BITFIELD) (((LEDs)->LEDred & BITFIELD) ? 1 : 0)
N/** Get on/off state for green led for specified bitfield */
N#define M_CO_LED_GREEN(LEDs, BITFIELD) (((LEDs)->LEDgreen & BITFIELD) ? 1 : 0)
N
N
N/**
N * LEDs object, initialized by M_CO_LEDs_init()
N */
Ntypedef struct{
N    uint32_t            LEDtmr50ms;     /**< 50ms led timer */
N    uint8_t             LEDtmr200ms;    /**< 200ms led timer */
N    uint8_t             LEDtmrflash_1;  /**< single flash led timer */
N    uint8_t             LEDtmrflash_2;  /**< double flash led timer */
N    uint8_t             LEDtmrflash_3;  /**< triple flash led timer */
N    uint8_t             LEDtmrflash_4;  /**< quadruple flash led timer */
N    uint8_t             LEDred;         /**< red led #M_CO_LED_BITFIELD_t */
N    uint8_t             LEDgreen;       /**< green led #M_CO_LED_BITFIELD_t */
N} M_CO_LEDs_t;
N
N/**
N * @brief 
N * 
N * Initialize LEDs object.
N * Function must be called in the system reset section.
N * 
N * @param LEDs This object will be initialized.
N * @return #M_CO_ReturnError_t#  CO_ERROR_NO or CO_ERROR_ILLEGAL_ARGUMENT.
N */
NM_CO_ReturnError_t M_CO_LEDs_init(M_CO_LEDs_t *LEDs);
N
N
N
N
N
N/**
N * @brief 
N * 
N * Process indicator states
N * Function must be called cyclically.
N * 
N * @param LEDs This object.
N * @param timeDifference_us Time difference from previous function call in [microseconds].
N * @param SMTstate SMT operating state.
N * @param SYSconfig System is in configuration state indication.
N * @param ErrPriority1 System Err indication (highest priority).
N * @param ErrPriority6 System Err indication (priority 6 ).
N * @param ErrPriority3 System Err indication (priority 3 ).
N * @param ErrPriority4 System Err indication (priority 4 ).
N * @param ErrPriority5 System Err indication (priority 5 ).
N * @param ErrOther System Err indication (lowest priority).
N * @param SYSotherState 
N */
N
Nvoid M_CO_LEDs_process(M_CO_LEDs_t *LEDs,
N                     uint32_t timeDifference_us,
N                     M_CO_SMT_internalState_t SMTstate,
N                     bool_t SYSconfig,
N                     bool_t ErrPriority1,
N                     bool_t ErrPriority6,
N                     bool_t ErrPriority3,
N                     bool_t ErrPriority4,
N                     bool_t ErrPriority5,
N                     bool_t ErrOther,
N                     bool_t SYSotherState
N                     );
N
N                     
N
N#endif // M_CO_LEDS_H
L 11 "..\App\src\M_CO_LEDs.c" 2
N
N
N
N
N/******************************************************************************/
NM_CO_ReturnError_t M_CO_LEDs_init(M_CO_LEDs_t *LEDs) 
N{
N    M_CO_ReturnError_t ret = CO_ERROR_NO;
N
N    /* verify arguments */
N    if (LEDs == NULL) {
X    if (LEDs == 0) {
N        return CO_ERROR_ILLEGAL_ARGUMENT;
N    }
N
N    /* clear the object */
N    memset(LEDs, 0, sizeof(M_CO_LEDs_t));
N
N    return ret;
N}
N
N
N
N/******************************************************************************/
Nvoid M_CO_LEDs_process(M_CO_LEDs_t *LEDs,
N                     uint32_t timeDifference_us,
N                     M_CO_SMT_internalState_t SMTstate,
N                     bool_t SYSconfig,
N                     bool_t ErrPriority1,
N                     bool_t ErrPriority6,
N                     bool_t ErrPriority3,
N                     bool_t ErrPriority4,
N                     bool_t ErrPriority5,
N                     bool_t ErrOther,
N                     bool_t SYSotherState
N                     )
N{
N
N    uint8_t rd = 0;
N    uint8_t gr = 0;
N    bool_t tick = false;
X    bool_t tick = 0;
N
N    LEDs->LEDtmr50ms += timeDifference_us;
N    while (LEDs->LEDtmr50ms >= 50000) {
N        bool_t rdFlickerNext = (LEDs->LEDred & CO_LED_flicker) == 0;
N
N        tick = true;
X        tick = 1;
N        LEDs->LEDtmr50ms -= 50000;
N
N        if (++LEDs->LEDtmr200ms > 3) {
N            /* calculate 2,5Hz blinking and flashing */
N            LEDs->LEDtmr200ms = 0;
N            rd = gr = 0;
N
N            if ((LEDs->LEDred & CO_LED_blink) == 0) rd |= CO_LED_blink;
N            else                                    gr |= CO_LED_blink;
N
N            switch (++LEDs->LEDtmrflash_1) {
N                case 1: rd |= CO_LED_flash_1; break;
N                case 2: gr |= CO_LED_flash_1; break;
N                case 6: LEDs->LEDtmrflash_1 = 0; break;
N                default: break;
N            }
N            switch (++LEDs->LEDtmrflash_2) {
N                case 1: case 3: rd |= CO_LED_flash_2; break;
N                case 2: case 4: gr |= CO_LED_flash_2; break;
N                case 8: LEDs->LEDtmrflash_2 = 0; break;
N                default: break;
N            }
N            switch (++LEDs->LEDtmrflash_3) {
N                case 1: case 3: case 5: rd |= CO_LED_flash_3; break;
N                case 2: case 4: case 6: gr |= CO_LED_flash_3; break;
N                case 10: LEDs->LEDtmrflash_3 = 0; break;
N                default: break;
N            }
N            switch (++LEDs->LEDtmrflash_4) {
N                case 1: case 3: case 5: case 7: rd |= CO_LED_flash_4; break;
N                case 2: case 4: case 6: case 8: gr |= CO_LED_flash_4; break;
N                case 12: LEDs->LEDtmrflash_4 = 0; break;
N                default: break;
N            }
N        }
N        else {
N            /* clear flicker and CANopen bits, keep others */
N            rd = LEDs->LEDred & (0xFF ^ (CO_LED_flicker | CO_LED_CANopen));
N            gr = LEDs->LEDgreen & (0xFF ^ (CO_LED_flicker | CO_LED_CANopen));
N        }
N
N        /* calculate 10Hz flickering */
N        if (rdFlickerNext) rd |= CO_LED_flicker;
N        else               gr |= CO_LED_flicker;
N
N    } /* while (LEDs->LEDtmr50ms >= 50000) */
N
N    if (tick) {
N        uint8_t rd_co, gr_co;
N
N        /* CANopen red ERROR LED */
N        if      (ErrPriority1)                      rd_co = 1;
N        else if (SMTstate == CO_SMT_INITIALIZING)   rd_co = rd & CO_LED_flicker;
N        else if (ErrPriority3)                      rd_co = rd & CO_LED_flash_4;
N        else if (ErrPriority4)                      rd_co = rd & CO_LED_flash_3;
N        else if (ErrPriority5)                      rd_co = rd & CO_LED_flash_2;
N        else if (ErrPriority6)                      rd_co = rd & CO_LED_flash_1;
N        else if (ErrOther)                          rd_co = rd & CO_LED_blink;
N        else                                        rd_co = 0;
N
N        /* CANopen green RUN LED */
N        if      (SYSconfig)                         gr_co = gr & CO_LED_flicker;
N        else if (SYSotherState)                     gr_co = gr & CO_LED_flash_3;
N        else if (SMTstate == CO_SMT_STOPPED)        gr_co = gr & CO_LED_flash_1;
N        else if (SMTstate == CO_SMT_PRE_OPERATIONAL)gr_co = gr & CO_LED_blink;
N        else if (SMTstate == CO_SMT_OPERATIONAL)    gr_co = 1;
N        else                                        gr_co = 0;
N
N        if (rd_co != 0) rd |= CO_LED_CANopen;
N        if (gr_co != 0) gr |= CO_LED_CANopen;
N        LEDs->LEDred = rd;
N        LEDs->LEDgreen = gr;
N    } /* if (tick) */
N
N}
