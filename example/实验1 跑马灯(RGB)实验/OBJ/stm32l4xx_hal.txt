; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;486      */
;;;487    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L1.12|
;;;488    {
;;;489      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210101          BIC      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;490    }
00000a  4770              BX       lr
;;;491    
                          ENDP

                  |L1.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;522      */
;;;523    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L2.12|
;;;524    {
;;;525      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0210104          BIC      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;526    }
00000a  4770              BX       lr
;;;527    
                          ENDP

                  |L2.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;504      */
;;;505    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L3.12|
;;;506    {
;;;507      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210102          BIC      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;508    }
00000a  4770              BX       lr
;;;509    
                          ENDP

                  |L3.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;477      */
;;;478    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L4.12|
;;;479    {
;;;480      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410101          ORR      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;481    }
00000a  4770              BX       lr
;;;482    
                          ENDP

                  |L4.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;513      */
;;;514    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L5.12|
;;;515    {
;;;516      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0410104          ORR      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;517    }
00000a  4770              BX       lr
;;;518    
                          ENDP

                  |L5.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;495      */
;;;496    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L6.12|
;;;497    {
;;;498      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410102          ORR      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;499    }
00000a  4770              BX       lr
;;;500    
                          ENDP

                  |L6.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;209      */
;;;210    HAL_StatusTypeDef HAL_DeInit(void)
000000  4809              LDR      r0,|L7.40|
;;;211    {
000002  b510              PUSH     {r4,lr}
;;;212      /* Reset of all peripherals */
;;;213      __HAL_RCC_APB1_FORCE_RESET();
000004  f04f31ff          MOV      r1,#0xffffffff
000008  6381              STR      r1,[r0,#0x38]
;;;214      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2200              MOVS     r2,#0
00000c  6382              STR      r2,[r0,#0x38]
;;;215    
;;;216      __HAL_RCC_APB2_FORCE_RESET();
00000e  6401              STR      r1,[r0,#0x40]
;;;217      __HAL_RCC_APB2_RELEASE_RESET();
000010  6402              STR      r2,[r0,#0x40]
;;;218    
;;;219      __HAL_RCC_AHB1_FORCE_RESET();
000012  6281              STR      r1,[r0,#0x28]
;;;220      __HAL_RCC_AHB1_RELEASE_RESET();
000014  6282              STR      r2,[r0,#0x28]
;;;221    
;;;222      __HAL_RCC_AHB2_FORCE_RESET();
000016  62c1              STR      r1,[r0,#0x2c]
;;;223      __HAL_RCC_AHB2_RELEASE_RESET();
000018  62c2              STR      r2,[r0,#0x2c]
;;;224    
;;;225      __HAL_RCC_AHB3_FORCE_RESET();
00001a  6301              STR      r1,[r0,#0x30]
;;;226      __HAL_RCC_AHB3_RELEASE_RESET();
00001c  6302              STR      r2,[r0,#0x30]
;;;227    
;;;228      /* De-Init the low level hardware */
;;;229      HAL_MspDeInit();
00001e  f7fffffe          BL       HAL_MspDeInit
;;;230    
;;;231      /* Return function status */
;;;232      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;233    }
000024  bd10              POP      {r4,pc}
;;;234    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40021000

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=1

                  HAL_Delay PROC
;;;351      */
;;;352    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4604              MOV      r4,r0
;;;354      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4605              MOV      r5,r0
;;;355      uint32_t wait = Delay;
;;;356    
;;;357      /* Add a period to guaranty minimum wait */
;;;358      if (wait < HAL_MAX_DELAY)
00000a  1c60              ADDS     r0,r4,#1
00000c  d000              BEQ      |L8.16|
00000e  1c64              ADDS     r4,r4,#1
                  |L8.16|
;;;359      {
;;;360        wait++;
;;;361      }
;;;362    
;;;363      while((HAL_GetTick() - tickstart) < wait)
000010  f7fffffe          BL       HAL_GetTick
000014  1b40              SUBS     r0,r0,r5
000016  42a0              CMP      r0,r4
000018  d3fa              BCC      |L8.16|
;;;364      {
;;;365      }
;;;366    }
00001a  bd70              POP      {r4-r6,pc}
;;;367    
                          ENDP


                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;421      */
;;;422    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L9.12|
;;;423    {
;;;424      return(DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;425    }
000008  4770              BX       lr
;;;426    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;403      */
;;;404    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L10.4|
;;;405    {
;;;406      return STM32L4XX_HAL_VERSION;
;;;407    }
000002  4770              BX       lr
;;;408    
                          ENDP

                  |L10.4|
                          DCD      0x01090000

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;412      */
;;;413    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L11.8|
;;;414    {
;;;415      return((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;416    }
000006  4770              BX       lr
;;;417    
                          ENDP

                  |L11.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;335      */
;;;336    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L12.8|
;;;337    {
;;;338      return uwTick;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
;;;339    }
000004  4770              BX       lr
;;;340    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetUIDw0||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw0 PROC
;;;430      */
;;;431    uint32_t HAL_GetUIDw0(void)
000000  4801              LDR      r0,|L13.8|
;;;432    {
;;;433      return(READ_REG(*((uint32_t *)UID_BASE)));
000002  6800              LDR      r0,[r0,#0]
;;;434    }
000004  4770              BX       lr
;;;435    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x1fff7590

                          AREA ||i.HAL_GetUIDw1||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw1 PROC
;;;439      */
;;;440    uint32_t HAL_GetUIDw1(void)
000000  4801              LDR      r0,|L14.8|
;;;441    {
;;;442      return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000002  6800              LDR      r0,[r0,#0]
;;;443    }
000004  4770              BX       lr
;;;444    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      0x1fff7594

                          AREA ||i.HAL_GetUIDw2||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw2 PROC
;;;448      */
;;;449    uint32_t HAL_GetUIDw2(void)
000000  4801              LDR      r0,|L15.8|
;;;450    {
;;;451      return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
000002  6800              LDR      r0,[r0,#0]
;;;452    }
000004  4770              BX       lr
;;;453    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x1fff7598

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;324      */
;;;325    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L16.12|
;;;326    {
;;;327      uwTick++;
000002  6801              LDR      r1,[r0,#0]  ; uwTick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; uwTick
;;;328    }
000008  4770              BX       lr
;;;329    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=1

                  HAL_Init PROC
;;;165      */
;;;166    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168      HAL_StatusTypeDef  status = HAL_OK;
000002  2400              MOVS     r4,#0
;;;169    
;;;170      /* Configure Flash prefetch, Instruction cache, Data cache */
;;;171      /* Default configuration at reset is:                      */
;;;172      /* - Prefetch disabled                                     */
;;;173      /* - Instruction cache enabled                             */
;;;174      /* - Data cache enabled                                    */
;;;175    #if (INSTRUCTION_CACHE_ENABLE == 0)
;;;176       __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
;;;177    #endif /* INSTRUCTION_CACHE_ENABLE */
;;;178    
;;;179    #if (DATA_CACHE_ENABLE == 0)
;;;180       __HAL_FLASH_DATA_CACHE_DISABLE();
;;;181    #endif /* DATA_CACHE_ENABLE */
;;;182    
;;;183    #if (PREFETCH_ENABLE != 0)
;;;184      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
;;;185    #endif /* PREFETCH_ENABLE */
;;;186    
;;;187      /* Set Interrupt Group Priority */
;;;188      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
000004  2005              MOVS     r0,#5
000006  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;189    
;;;190      /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
;;;191      if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       HAL_InitTick
000010  b108              CBZ      r0,|L17.22|
;;;192      {
;;;193        status = HAL_ERROR;
000012  2401              MOVS     r4,#1
000014  e001              B        |L17.26|
                  |L17.22|
;;;194      }
;;;195      else
;;;196      {
;;;197        /* Init the low level hardware */
;;;198        HAL_MspInit();
000016  f7fffffe          BL       HAL_MspInit
                  |L17.26|
;;;199      }
;;;200    
;;;201      /* Return function status */
;;;202      return status;
00001a  4620              MOV      r0,r4
;;;203    }
00001c  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;272      */
;;;273    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
000002  4605              MOV      r5,r0
;;;275      HAL_StatusTypeDef  status = HAL_OK;
;;;276    
;;;277      /*Configure the SysTick to have interrupt in 1ms time basis*/
;;;278      if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
000004  4809              LDR      r0,|L18.44|
000006  f44f717a          MOV      r1,#0x3e8
00000a  2400              MOVS     r4,#0                 ;275
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  f7fffffe          BL       HAL_SYSTICK_Config
000016  b108              CBZ      r0,|L18.28|
;;;279      {
;;;280        status = HAL_ERROR;
000018  2401              MOVS     r4,#1
00001a  e004              B        |L18.38|
                  |L18.28|
;;;281      }
;;;282      else
;;;283      {
;;;284        /*Configure the SysTick IRQ priority */
;;;285        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
00001c  2200              MOVS     r2,#0
00001e  4629              MOV      r1,r5
000020  1e50              SUBS     r0,r2,#1
000022  f7fffffe          BL       HAL_NVIC_SetPriority
                  |L18.38|
;;;286      }
;;;287    
;;;288      /* Return function status */
;;;289      return status;
000026  4620              MOV      r0,r4
;;;290    }
000028  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP

00002a  0000              DCW      0x0000
                  |L18.44|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;249      */
;;;250    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;251    {
;;;252      /* NOTE : This function should not be modified, when the callback is needed,
;;;253                the HAL_MspDeInit could be implemented in the user file
;;;254       */
;;;255    }
;;;256    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;238      */
;;;239    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;240    {
;;;241      /* NOTE : This function should not be modified, when the callback is needed,
;;;242                the HAL_MspInit could be implemented in the user file
;;;243       */
;;;244    }
;;;245    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;393      */
;;;394    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;395    {
;;;396      /* Enable SysTick Interrupt */
;;;397      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0410102          ORR      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;398    }
00000c  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.HAL_SYSCFG_DisableIOAnalogSwitchBooster||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_DisableIOAnalogSwitchBooster PROC
;;;693      */
;;;694    void HAL_SYSCFG_DisableIOAnalogSwitchBooster(void)
000000  4802              LDR      r0,|L22.12|
;;;695    {
;;;696      CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
000002  6841              LDR      r1,[r0,#4]
000004  f4217180          BIC      r1,r1,#0x100
000008  6041              STR      r1,[r0,#4]
;;;697    }
00000a  4770              BX       lr
;;;698    
                          ENDP

                  |L22.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_DisableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_DisableMemorySwappingBank PROC
;;;589      */
;;;590    void HAL_SYSCFG_DisableMemorySwappingBank(void)
000000  4901              LDR      r1,|L23.8|
;;;591    {
;;;592    
;;;593      *(__IO uint32_t *)FB_MODE_BB = 0x00000000UL;
000002  2000              MOVS     r0,#0
000004  6208              STR      r0,[r1,#0x20]
;;;594    }
000006  4770              BX       lr
;;;595    
                          ENDP

                  |L23.8|
                          DCD      0x42200000

                          AREA ||i.HAL_SYSCFG_DisableVREFBUF||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_DisableVREFBUF PROC
;;;672      */
;;;673    void HAL_SYSCFG_DisableVREFBUF(void)
000000  4802              LDR      r0,|L24.12|
;;;674    {
;;;675      CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
000002  6b01              LDR      r1,[r0,#0x30]
000004  f0210101          BIC      r1,r1,#1
000008  6301              STR      r1,[r0,#0x30]
;;;676    }
00000a  4770              BX       lr
;;;677    #endif /* VREFBUF */
                          ENDP

                  |L24.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_EnableIOAnalogSwitchBooster||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_EnableIOAnalogSwitchBooster PROC
;;;683      */
;;;684    void HAL_SYSCFG_EnableIOAnalogSwitchBooster(void)
000000  4802              LDR      r0,|L25.12|
;;;685    {
;;;686      SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
000002  6841              LDR      r1,[r0,#4]
000004  f4417180          ORR      r1,r1,#0x100
000008  6041              STR      r1,[r0,#4]
;;;687    }
00000a  4770              BX       lr
;;;688    
                          ENDP

                  |L25.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_EnableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_EnableMemorySwappingBank PROC
;;;574      */
;;;575    void HAL_SYSCFG_EnableMemorySwappingBank(void)
000000  4901              LDR      r1,|L26.8|
;;;576    {
;;;577      *(__IO uint32_t *)FB_MODE_BB = 0x00000000UL;
000002  2000              MOVS     r0,#0
000004  6208              STR      r0,[r1,#0x20]
;;;578    }
000006  4770              BX       lr
;;;579    
                          ENDP

                  |L26.8|
                          DCD      0x42200000

                          AREA ||i.HAL_SYSCFG_EnableVREFBUF||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_EnableVREFBUF PROC
;;;646      */
;;;647    HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
000000  b570              PUSH     {r4-r6,lr}
;;;648    {
;;;649      uint32_t  tickstart;
;;;650    
;;;651      SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
000002  4c0a              LDR      r4,|L27.44|
000004  6b20              LDR      r0,[r4,#0x30]
000006  f0400001          ORR      r0,r0,#1
00000a  6320              STR      r0,[r4,#0x30]
;;;652    
;;;653      /* Get Start Tick*/
;;;654      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;655    
;;;656      /* Wait for VRR bit  */
;;;657      while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0U)
000012  e006              B        |L27.34|
                  |L27.20|
;;;658      {
;;;659        if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
000014  f7fffffe          BL       HAL_GetTick
000018  1b40              SUBS     r0,r0,r5
00001a  280a              CMP      r0,#0xa
00001c  d901              BLS      |L27.34|
;;;660        {
;;;661          return HAL_TIMEOUT;
00001e  2003              MOVS     r0,#3
;;;662        }
;;;663      }
;;;664    
;;;665      return HAL_OK;
;;;666    }
000020  bd70              POP      {r4-r6,pc}
                  |L27.34|
000022  6b20              LDR      r0,[r4,#0x30]         ;657
000024  0700              LSLS     r0,r0,#28             ;657
000026  d5f5              BPL      |L27.20|
000028  2000              MOVS     r0,#0                 ;665
00002a  bd70              POP      {r4-r6,pc}
;;;667    
                          ENDP

                  |L27.44|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_SRAM2Erase||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_SRAM2Erase PROC
;;;555      */
;;;556    void HAL_SYSCFG_SRAM2Erase(void)
000000  4804              LDR      r0,|L28.20|
;;;557    {
;;;558      /* unlock the write protection of the SRAM2ER bit */
;;;559      SYSCFG->SKR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6241              STR      r1,[r0,#0x24]
;;;560      SYSCFG->SKR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6241              STR      r1,[r0,#0x24]
;;;561      /* Starts a hardware SRAM2 erase operation*/
;;;562      *(__IO uint32_t *) SCSR_SRAM2ER_BB = 0x00000001UL;
00000a  4903              LDR      r1,|L28.24|
00000c  2001              MOVS     r0,#1
00000e  f8c10300          STR      r0,[r1,#0x300]
;;;563    }
000012  4770              BX       lr
;;;564    
                          ENDP

                  |L28.20|
                          DCD      0x40010000
                  |L28.24|
                          DCD      0x42200000

                          AREA ||i.HAL_SYSCFG_VREFBUF_HighImpedanceConfig||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFBUF_HighImpedanceConfig PROC
;;;622      */
;;;623    void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
000000  4903              LDR      r1,|L29.16|
;;;624    {
;;;625      /* Check the parameters */
;;;626      assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
;;;627    
;;;628      MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
000002  6b0a              LDR      r2,[r1,#0x30]
000004  f0220202          BIC      r2,r2,#2
000008  4302              ORRS     r2,r2,r0
00000a  630a              STR      r2,[r1,#0x30]
;;;629    }
00000c  4770              BX       lr
;;;630    
                          ENDP

00000e  0000              DCW      0x0000
                  |L29.16|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_VREFBUF_TrimmingConfig||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFBUF_TrimmingConfig PROC
;;;634      */
;;;635    void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
000000  4903              LDR      r1,|L30.16|
;;;636    {
;;;637      /* Check the parameters */
;;;638      assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
;;;639    
;;;640      MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
000002  6b4a              LDR      r2,[r1,#0x34]
000004  f022023f          BIC      r2,r2,#0x3f
000008  4302              ORRS     r2,r2,r0
00000a  634a              STR      r2,[r1,#0x34]
;;;641    }
00000c  4770              BX       lr
;;;642    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_VREFBUF_VoltageScalingConfig||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFBUF_VoltageScalingConfig PROC
;;;606      */
;;;607    void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
000000  4903              LDR      r1,|L31.16|
;;;608    {
;;;609      /* Check the parameters */
;;;610      assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
;;;611    
;;;612      MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
000002  6b0a              LDR      r2,[r1,#0x30]
000004  f0220204          BIC      r2,r2,#4
000008  4302              ORRS     r2,r2,r0
00000a  630a              STR      r2,[r1,#0x30]
;;;613    }
00000c  4770              BX       lr
;;;614    
                          ENDP

00000e  0000              DCW      0x0000
                  |L31.16|
                          DCD      0x40010000

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;377      */
;;;378    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;379    {
;;;380      /* Disable SysTick Interrupt */
;;;381      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210102          BIC      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;382    }
00000c  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l4xx_hal_c_HAL_Init____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___15_stm32l4xx_hal_c_HAL_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l4xx_hal_c_HAL_Init____REVSH|
#line 402
|__asm___15_stm32l4xx_hal_c_HAL_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l4xx_hal_c_HAL_Init____RRX|
#line 587
|__asm___15_stm32l4xx_hal_c_HAL_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
