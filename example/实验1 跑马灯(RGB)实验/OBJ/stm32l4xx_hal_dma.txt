; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal_dma.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal_dma.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal_dma.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1075     */
;;;1076   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1077   {
;;;1078   #if defined(DMAMUX1)
;;;1079     /* Clear the DMAMUX synchro overrun flag */
;;;1080     hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;1081   
;;;1082     if(hdma->DMAmuxRequestGen != 0U)
;;;1083     {
;;;1084       /* Clear the DMAMUX request generator overrun flag */
;;;1085       hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Clear all flags */
;;;1090     hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
000002  f8904044          LDRB     r4,[r0,#0x44]
000006  f004051c          AND      r5,r4,#0x1c
00000a  2401              MOVS     r4,#1
00000c  40ac              LSLS     r4,r4,r5
00000e  6c05              LDR      r5,[r0,#0x40]
000010  606c              STR      r4,[r5,#4]
;;;1091   
;;;1092     /* Configure DMA Channel data length */
;;;1093     hdma->Instance->CNDTR = DataLength;
000012  6804              LDR      r4,[r0,#0]
000014  6063              STR      r3,[r4,#4]
;;;1094   
;;;1095     /* Memory to Peripheral */
;;;1096     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000016  6883              LDR      r3,[r0,#8]
000018  2b10              CMP      r3,#0x10
00001a  6803              LDR      r3,[r0,#0]            ;1077
00001c  d003              BEQ      |L1.38|
;;;1097     {
;;;1098       /* Configure DMA Channel destination address */
;;;1099       hdma->Instance->CPAR = DstAddress;
;;;1100   
;;;1101       /* Configure DMA Channel source address */
;;;1102       hdma->Instance->CMAR = SrcAddress;
;;;1103     }
;;;1104     /* Peripheral to Memory */
;;;1105     else
;;;1106     {
;;;1107       /* Configure DMA Channel source address */
;;;1108       hdma->Instance->CPAR = SrcAddress;
00001e  6099              STR      r1,[r3,#8]
;;;1109   
;;;1110       /* Configure DMA Channel destination address */
;;;1111       hdma->Instance->CMAR = DstAddress;
000020  6800              LDR      r0,[r0,#0]
000022  60c2              STR      r2,[r0,#0xc]
;;;1112     }
;;;1113   }
000024  bd30              POP      {r4,r5,pc}
                  |L1.38|
000026  609a              STR      r2,[r3,#8]            ;1099
000028  6800              LDR      r0,[r0,#0]            ;1102
00002a  60c1              STR      r1,[r0,#0xc]          ;1102
00002c  bd30              POP      {r4,r5,pc}
;;;1114   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;562      */
;;;563    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b1c8              CBZ      r0,|L2.54|
;;;564    {
;;;565      HAL_StatusTypeDef status = HAL_OK;
;;;566    
;;;567      /* Check the DMA peripheral handle */
;;;568      if(NULL == hdma)
;;;569      {
;;;570        return HAL_ERROR;
;;;571      }
;;;572    
;;;573      /* Disable DMA IT */
;;;574      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
000002  6801              LDR      r1,[r0,#0]
000004  680a              LDR      r2,[r1,#0]
000006  f022020e          BIC      r2,r2,#0xe
00000a  600a              STR      r2,[r1,#0]
;;;575    
;;;576    #if defined(DMAMUX1)
;;;577      /* disable the DMAMUX sync overrun IT*/
;;;578      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
;;;579    #endif /* DMAMUX1 */
;;;580    
;;;581      /* Disable the channel */
;;;582      __HAL_DMA_DISABLE(hdma);
00000c  6801              LDR      r1,[r0,#0]
00000e  680a              LDR      r2,[r1,#0]
000010  f0220201          BIC      r2,r2,#1
000014  600a              STR      r2,[r1,#0]
;;;583    
;;;584      /* Clear all flags */
;;;585      hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
000016  f8901044          LDRB     r1,[r0,#0x44]
00001a  2301              MOVS     r3,#1
00001c  f001021c          AND      r2,r1,#0x1c
000020  fa03f102          LSL      r1,r3,r2
000024  6c02              LDR      r2,[r0,#0x40]
000026  6051              STR      r1,[r2,#4]
;;;586    
;;;587    #if defined(DMAMUX1)
;;;588      /* Clear the DMAMUX synchro overrun flag */
;;;589      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;590    
;;;591      if(hdma->DMAmuxRequestGen != 0U)
;;;592      {
;;;593        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
;;;594        /* disable the request gen overrun IT*/
;;;595        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
;;;596    
;;;597        /* Clear the DMAMUX request generator overrun flag */
;;;598        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;599      }
;;;600    
;;;601    #endif /* DMAMUX1 */
;;;602    
;;;603      /* Change the DMA state */
;;;604      hdma->State = HAL_DMA_STATE_READY;
000028  f8803025          STRB     r3,[r0,#0x25]
;;;605    
;;;606      /* Process Unlocked */
;;;607      __HAL_UNLOCK(hdma);
00002c  2100              MOVS     r1,#0
00002e  f8801024          STRB     r1,[r0,#0x24]
;;;608    
;;;609      return status;
000032  4608              MOV      r0,r1
;;;610    }
000034  4770              BX       lr
                  |L2.54|
000036  2001              MOVS     r0,#1                 ;570
000038  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;617      */
;;;618    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;619    {
;;;620      HAL_StatusTypeDef status = HAL_OK;
;;;621    
;;;622      if(HAL_DMA_STATE_BUSY != hdma->State)
000002  f8901025          LDRB     r1,[r0,#0x25]
000006  2400              MOVS     r4,#0                 ;620
000008  2902              CMP      r1,#2
00000a  d003              BEQ      |L3.20|
;;;623      {
;;;624        /* no transfer ongoing */
;;;625        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000c  2104              MOVS     r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;626    
;;;627        status = HAL_ERROR;
000010  2401              MOVS     r4,#1
000012  e01a              B        |L3.74|
                  |L3.20|
;;;628      }
;;;629      else
;;;630      {
;;;631        /* Disable DMA IT */
;;;632        __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f022020e          BIC      r2,r2,#0xe
00001c  600a              STR      r2,[r1,#0]
;;;633    
;;;634        /* Disable the channel */
;;;635        __HAL_DMA_DISABLE(hdma);
00001e  6801              LDR      r1,[r0,#0]
000020  680a              LDR      r2,[r1,#0]
000022  f0220201          BIC      r2,r2,#1
000026  600a              STR      r2,[r1,#0]
;;;636    
;;;637    #if defined(DMAMUX1)
;;;638        /* disable the DMAMUX sync overrun IT*/
;;;639        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
;;;640    
;;;641        /* Clear all flags */
;;;642        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
;;;643    
;;;644        /* Clear the DMAMUX synchro overrun flag */
;;;645        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;646    
;;;647        if(hdma->DMAmuxRequestGen != 0U)
;;;648        {
;;;649          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
;;;650          /* disable the request gen overrun IT*/
;;;651          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
;;;652    
;;;653          /* Clear the DMAMUX request generator overrun flag */
;;;654          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;655        }
;;;656    
;;;657    #else
;;;658        /* Clear all flags */
;;;659        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
000028  f8901044          LDRB     r1,[r0,#0x44]
00002c  2301              MOVS     r3,#1
00002e  f001021c          AND      r2,r1,#0x1c
000032  fa03f102          LSL      r1,r3,r2
000036  6c02              LDR      r2,[r0,#0x40]
000038  6051              STR      r1,[r2,#4]
;;;660    #endif /* DMAMUX1 */
;;;661    
;;;662        /* Change the DMA state */
;;;663        hdma->State = HAL_DMA_STATE_READY;
00003a  f8803025          STRB     r3,[r0,#0x25]
;;;664    
;;;665        /* Process Unlocked */
;;;666        __HAL_UNLOCK(hdma);
00003e  2100              MOVS     r1,#0
000040  f8801024          STRB     r1,[r0,#0x24]
;;;667    
;;;668        /* Call User Abort callback */
;;;669        if(hdma->XferAbortCallback != NULL)
000044  6b81              LDR      r1,[r0,#0x38]
000046  b101              CBZ      r1,|L3.74|
;;;670        {
;;;671          hdma->XferAbortCallback(hdma);
000048  4788              BLX      r1
                  |L3.74|
;;;672        }
;;;673      }
;;;674      return status;
00004a  4620              MOV      r0,r4
;;;675    }
00004c  bd10              POP      {r4,pc}
;;;676    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DMA_DeInit PROC
;;;310      */
;;;311    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b530              PUSH     {r4,r5,lr}
;;;312    {
000002  b190              CBZ      r0,|L4.42|
;;;313    
;;;314      /* Check the DMA handle allocation */
;;;315      if (NULL == hdma )
;;;316      {
;;;317        return HAL_ERROR;
;;;318      }
;;;319    
;;;320      /* Check the parameters */
;;;321      assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
;;;322    
;;;323      /* Disable the selected DMA Channelx */
;;;324      __HAL_DMA_DISABLE(hdma);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f0220201          BIC      r2,r2,#1
00000c  600a              STR      r2,[r1,#0]
;;;325    
;;;326      /* Compute the channel index */
;;;327      if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
00000e  4c20              LDR      r4,|L4.144|
000010  6802              LDR      r2,[r0,#0]
;;;328      {
;;;329        /* DMA1 */
;;;330        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
000012  2114              MOVS     r1,#0x14
;;;331        hdma->DmaBaseAddress = DMA1;
000014  4b1f              LDR      r3,|L4.148|
000016  42a2              CMP      r2,r4                 ;327
000018  d209              BCS      |L4.46|
00001a  4c1f              LDR      r4,|L4.152|
00001c  4414              ADD      r4,r4,r2              ;330
00001e  fbb4f1f1          UDIV     r1,r4,r1              ;330
000022  0089              LSLS     r1,r1,#2              ;330
000024  e9c03110          STRD     r3,r1,[r0,#0x40]      ;330
000028  e00b              B        |L4.66|
                  |L4.42|
00002a  2001              MOVS     r0,#1                 ;317
;;;332      }
;;;333      else
;;;334      {
;;;335        /* DMA2 */
;;;336        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
;;;337        hdma->DmaBaseAddress = DMA2;
;;;338      }
;;;339    
;;;340      /* Reset DMA Channel control register */
;;;341      hdma->Instance->CCR  = 0;
;;;342    
;;;343      /* Clear all flags */
;;;344      hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
;;;345    
;;;346    #if !defined (DMAMUX1)
;;;347    
;;;348      /* Reset DMA channel selection register */
;;;349      if (DMA1 == hdma->DmaBaseAddress)
;;;350      {
;;;351        /* DMA1 */
;;;352        DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;353      }
;;;354      else
;;;355      {
;;;356        /* DMA2 */
;;;357        DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;358      }
;;;359    #endif /* STM32L431xx || STM32L432xx || STM32L433xx || STM32L442xx || STM32L443xx */
;;;360           /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L442xx || STM32L486xx */
;;;361           /* STM32L496xx || STM32L4A6xx                                              */
;;;362    
;;;363    #if defined(DMAMUX1)
;;;364    
;;;365      /* Initialize parameters for DMAMUX channel :
;;;366         DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
;;;367    
;;;368      DMA_CalcDMAMUXChannelBaseAndMask(hdma);
;;;369    
;;;370      /* Reset the DMAMUX channel that corresponds to the DMA channel */
;;;371      hdma->DMAmuxChannel->CCR = 0;
;;;372    
;;;373      /* Clear the DMAMUX synchro overrun flag */
;;;374      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;375    
;;;376      /* Reset Request generator parameters if any */
;;;377      if(((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
;;;378      {
;;;379        /* Initialize parameters for DMAMUX request generator :
;;;380           DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
;;;381        */
;;;382        DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
;;;383    
;;;384        /* Reset the DMAMUX request generator register*/
;;;385        hdma->DMAmuxRequestGen->RGCR = 0U;
;;;386    
;;;387        /* Clear the DMAMUX request generator overrun flag */
;;;388        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;389      }
;;;390    
;;;391      hdma->DMAmuxRequestGen = 0U;
;;;392      hdma->DMAmuxRequestGenStatus = 0U;
;;;393      hdma->DMAmuxRequestGenStatusMask = 0U;
;;;394    
;;;395    #endif /* DMAMUX1 */
;;;396    
;;;397      /* Clean callbacks */
;;;398      hdma->XferCpltCallback = NULL;
;;;399      hdma->XferHalfCpltCallback = NULL;
;;;400      hdma->XferErrorCallback = NULL;
;;;401      hdma->XferAbortCallback = NULL;
;;;402    
;;;403      /* Initialise the error code */
;;;404      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;405    
;;;406      /* Initialize the DMA state */
;;;407      hdma->State = HAL_DMA_STATE_RESET;
;;;408    
;;;409      /* Release Lock */
;;;410      __HAL_UNLOCK(hdma);
;;;411    
;;;412      return HAL_OK;
;;;413    }
00002c  bd30              POP      {r4,r5,pc}
                  |L4.46|
00002e  4c18              LDR      r4,|L4.144|
000030  4264              RSBS     r4,r4,#0              ;336
000032  4414              ADD      r4,r4,r2              ;336
000034  fbb4f1f1          UDIV     r1,r4,r1              ;336
000038  0089              LSLS     r1,r1,#2              ;336
00003a  6441              STR      r1,[r0,#0x44]         ;337
00003c  4914              LDR      r1,|L4.144|
00003e  3908              SUBS     r1,r1,#8              ;337
000040  6401              STR      r1,[r0,#0x40]         ;337
                  |L4.66|
000042  2100              MOVS     r1,#0                 ;341
000044  6011              STR      r1,[r2,#0]            ;341
000046  f8902044          LDRB     r2,[r0,#0x44]         ;344
00004a  f002041c          AND      r4,r2,#0x1c           ;344
00004e  2201              MOVS     r2,#1                 ;344
000050  40a2              LSLS     r2,r2,r4              ;344
000052  6c04              LDR      r4,[r0,#0x40]         ;344
000054  6062              STR      r2,[r4,#4]            ;344
000056  6c04              LDR      r4,[r0,#0x40]         ;349
000058  220f              MOVS     r2,#0xf               ;352
00005a  429c              CMP      r4,r3                 ;349
00005c  d102              BNE      |L4.100|
00005e  f8534fa8          LDR      r4,[r3,#0xa8]!        ;352
000062  e002              B        |L4.106|
                  |L4.100|
000064  4b0a              LDR      r3,|L4.144|
000066  33a0              ADDS     r3,r3,#0xa0           ;357
000068  681c              LDR      r4,[r3,#0]            ;357
                  |L4.106|
00006a  f8905044          LDRB     r5,[r0,#0x44]         ;357
00006e  f005051c          AND      r5,r5,#0x1c           ;357
000072  40aa              LSLS     r2,r2,r5              ;357
000074  4394              BICS     r4,r4,r2              ;357
000076  601c              STR      r4,[r3,#0]            ;357
000078  62c1              STR      r1,[r0,#0x2c]         ;399
00007a  6301              STR      r1,[r0,#0x30]         ;400
00007c  6341              STR      r1,[r0,#0x34]         ;401
00007e  6381              STR      r1,[r0,#0x38]         ;404
000080  63c1              STR      r1,[r0,#0x3c]         ;404
000082  f8801025          STRB     r1,[r0,#0x25]         ;407
000086  f8801024          STRB     r1,[r0,#0x24]         ;410
00008a  2000              MOVS     r0,#0                 ;412
00008c  bd30              POP      {r4,r5,pc}
;;;414    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x40020408
                  |L4.148|
                          DCD      0x40020000
                  |L4.152|
                          DCD      0xbffdfff8

                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1049     */
;;;1050   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;1051   {
;;;1052     return hdma->ErrorCode;
;;;1053   }
000002  4770              BX       lr
;;;1054   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1037     */
;;;1038   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  f8900025          LDRB     r0,[r0,#0x25]
;;;1039   {
;;;1040     /* Return DMA handle state */
;;;1041     return hdma->State;
;;;1042   }
000004  4770              BX       lr
;;;1043   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_DMA_IRQHandler PROC
;;;814      */
;;;815    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b4f0              PUSH     {r4-r7}
;;;816    {
;;;817      uint32_t flag_it = hdma->DmaBaseAddress->ISR;
000002  6c01              LDR      r1,[r0,#0x40]
000004  680b              LDR      r3,[r1,#0]
;;;818      uint32_t source_it = hdma->Instance->CCR;
000006  6801              LDR      r1,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
;;;819    
;;;820      /* Half Transfer Complete Interrupt management ******************************/
;;;821      if ((0U != (flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_HT)))
00000a  f8904044          LDRB     r4,[r0,#0x44]
00000e  2504              MOVS     r5,#4
000010  f004041c          AND      r4,r4,#0x1c
000014  fa05f604          LSL      r6,r5,r4
000018  421e              TST      r6,r3
00001a  d011              BEQ      |L7.64|
00001c  0756              LSLS     r6,r2,#29
00001e  d50f              BPL      |L7.64|
;;;822      {
;;;823          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;824          if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000020  680a              LDR      r2,[r1,#0]
000022  0692              LSLS     r2,r2,#26
000024  d403              BMI      |L7.46|
;;;825          {
;;;826            /* Disable the half transfer interrupt */
;;;827            __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
000026  680a              LDR      r2,[r1,#0]
000028  f0220204          BIC      r2,r2,#4
00002c  600a              STR      r2,[r1,#0]
                  |L7.46|
;;;828          }
;;;829          /* Clear the half transfer complete flag */
;;;830          hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1cU);
00002e  f8901044          LDRB     r1,[r0,#0x44]
000032  f001011c          AND      r1,r1,#0x1c
000036  408d              LSLS     r5,r5,r1
000038  6c01              LDR      r1,[r0,#0x40]
00003a  604d              STR      r5,[r1,#4]
;;;831    
;;;832          /* DMA peripheral state is not updated in Half Transfer */
;;;833          /* but in Transfer Complete case */
;;;834    
;;;835         if(hdma->XferHalfCpltCallback != NULL)
00003c  6b01              LDR      r1,[r0,#0x30]
00003e  e01d              B        |L7.124|
                  |L7.64|
;;;836          {
;;;837            /* Half transfer callback */
;;;838            hdma->XferHalfCpltCallback(hdma);
;;;839          }
;;;840      }
;;;841    
;;;842      /* Transfer Complete Interrupt management ***********************************/
;;;843      else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_TC)))
000040  2602              MOVS     r6,#2
000042  fa06f704          LSL      r7,r6,r4
000046  421f              TST      r7,r3
000048  f04f0c00          MOV      r12,#0
;;;844      {
;;;845        if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
;;;846        {
;;;847          /* Disable the transfer complete and error interrupt */
;;;848          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
;;;849    
;;;850          /* Change the DMA state */
;;;851          hdma->State = HAL_DMA_STATE_READY;
00004c  f04f0501          MOV      r5,#1
000050  d018              BEQ      |L7.132|
000052  0797              LSLS     r7,r2,#30             ;843
000054  d516              BPL      |L7.132|
000056  680a              LDR      r2,[r1,#0]            ;845
000058  0692              LSLS     r2,r2,#26             ;845
00005a  d405              BMI      |L7.104|
00005c  680a              LDR      r2,[r1,#0]            ;848
00005e  f022020a          BIC      r2,r2,#0xa            ;848
000062  600a              STR      r2,[r1,#0]            ;848
000064  f8805025          STRB     r5,[r0,#0x25]
                  |L7.104|
;;;852        }
;;;853        /* Clear the transfer complete flag */
;;;854        hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
000068  f8901044          LDRB     r1,[r0,#0x44]
00006c  f001011c          AND      r1,r1,#0x1c
000070  408e              LSLS     r6,r6,r1
000072  6c01              LDR      r1,[r0,#0x40]
000074  604e              STR      r6,[r1,#4]
;;;855    
;;;856        /* Process Unlocked */
;;;857        __HAL_UNLOCK(hdma);
000076  f880c024          STRB     r12,[r0,#0x24]
;;;858    
;;;859        if(hdma->XferCpltCallback != NULL)
00007a  6ac1              LDR      r1,[r0,#0x2c]
                  |L7.124|
00007c  2900              CMP      r1,#0
00007e  d01a              BEQ      |L7.182|
;;;860        {
;;;861          /* Transfer complete callback */
;;;862          hdma->XferCpltCallback(hdma);
;;;863        }
;;;864      }
;;;865    
;;;866      /* Transfer Error Interrupt management **************************************/
;;;867      else if ((0U != (flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_TE)))
;;;868      {
;;;869        /* When a DMA transfer error occurs */
;;;870        /* A hardware clear of its EN bits is performed */
;;;871        /* Disable ALL DMA IT */
;;;872        __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
;;;873    
;;;874        /* Clear all flags */
;;;875        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
;;;876    
;;;877        /* Update error code */
;;;878        hdma->ErrorCode = HAL_DMA_ERROR_TE;
;;;879    
;;;880        /* Change the DMA state */
;;;881        hdma->State = HAL_DMA_STATE_READY;
;;;882    
;;;883        /* Process Unlocked */
;;;884        __HAL_UNLOCK(hdma);
;;;885    
;;;886        if (hdma->XferErrorCallback != NULL)
;;;887        {
;;;888          /* Transfer error callback */
;;;889          hdma->XferErrorCallback(hdma);
000080  bcf0              POP      {r4-r7}
000082  4708              BX       r1
                  |L7.132|
000084  2608              MOVS     r6,#8                 ;867
000086  40a6              LSLS     r6,r6,r4              ;867
000088  421e              TST      r6,r3                 ;867
00008a  d014              BEQ      |L7.182|
00008c  0712              LSLS     r2,r2,#28             ;867
00008e  d512              BPL      |L7.182|
000090  680a              LDR      r2,[r1,#0]            ;872
000092  f022020e          BIC      r2,r2,#0xe            ;872
000096  600a              STR      r2,[r1,#0]            ;872
000098  f8901044          LDRB     r1,[r0,#0x44]         ;875
00009c  6c02              LDR      r2,[r0,#0x40]         ;875
00009e  f001011c          AND      r1,r1,#0x1c           ;875
0000a2  fa05f101          LSL      r1,r5,r1              ;875
0000a6  6051              STR      r1,[r2,#4]            ;875
0000a8  63c5              STR      r5,[r0,#0x3c]         ;878
0000aa  f8805025          STRB     r5,[r0,#0x25]         ;881
0000ae  f880c024          STRB     r12,[r0,#0x24]        ;884
0000b2  6b41              LDR      r1,[r0,#0x34]         ;886
0000b4  e7e2              B        |L7.124|
                  |L7.182|
;;;890        }
;;;891      }
;;;892      else
;;;893      {
;;;894        /* Nothing To Do */
;;;895      }
;;;896      return;
;;;897    }
0000b6  bcf0              POP      {r4-r7}
0000b8  4770              BX       lr
;;;898    
                          ENDP


                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;168      */
;;;169    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
000002  b168              CBZ      r0,|L8.32|
;;;171      uint32_t tmp;
;;;172    
;;;173      /* Check the DMA handle allocation */
;;;174      if(hdma == NULL)
;;;175      {
;;;176        return HAL_ERROR;
;;;177      }
;;;178    
;;;179      /* Check the parameters */
;;;180      assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
;;;181      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;182      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;183      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;184      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;185      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;186      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;187      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;188    
;;;189      assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));
;;;190    
;;;191      /* Compute the channel index */
;;;192      if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
000004  4c33              LDR      r4,|L8.212|
000006  6801              LDR      r1,[r0,#0]
;;;193      {
;;;194        /* DMA1 */
;;;195        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
000008  2314              MOVS     r3,#0x14
;;;196        hdma->DmaBaseAddress = DMA1;
00000a  4a33              LDR      r2,|L8.216|
00000c  42a1              CMP      r1,r4                 ;192
00000e  d209              BCS      |L8.36|
000010  4c32              LDR      r4,|L8.220|
000012  440c              ADD      r4,r4,r1              ;195
000014  fbb4f3f3          UDIV     r3,r4,r3              ;195
000018  009b              LSLS     r3,r3,#2              ;195
00001a  e9c02310          STRD     r2,r3,[r0,#0x40]      ;195
00001e  e00b              B        |L8.56|
                  |L8.32|
000020  2001              MOVS     r0,#1                 ;176
;;;197      }
;;;198      else
;;;199      {
;;;200        /* DMA2 */
;;;201        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
;;;202        hdma->DmaBaseAddress = DMA2;
;;;203      }
;;;204    
;;;205      /* Change DMA peripheral state */
;;;206      hdma->State = HAL_DMA_STATE_BUSY;
;;;207    
;;;208      /* Get the CR register value */
;;;209      tmp = hdma->Instance->CCR;
;;;210    
;;;211      /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
;;;212      tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
;;;213                          DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
;;;214                          DMA_CCR_DIR   | DMA_CCR_MEM2MEM));
;;;215    
;;;216      /* Prepare the DMA Channel configuration */
;;;217      tmp |=  hdma->Init.Direction        |
;;;218              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;219              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;220              hdma->Init.Mode                | hdma->Init.Priority;
;;;221    
;;;222      /* Write to DMA Channel CR register */
;;;223      hdma->Instance->CCR = tmp;
;;;224    
;;;225    
;;;226    #if defined(DMAMUX1)
;;;227      /* Initialize parameters for DMAMUX channel :
;;;228         DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
;;;229      */
;;;230      DMA_CalcDMAMUXChannelBaseAndMask(hdma);
;;;231    
;;;232      if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
;;;233      {
;;;234        /* if memory to memory force the request to 0*/
;;;235        hdma->Init.Request = DMA_REQUEST_MEM2MEM;
;;;236      }
;;;237    
;;;238      /* Set peripheral request  to DMAMUX channel */
;;;239      hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
;;;240    
;;;241      /* Clear the DMAMUX synchro overrun flag */
;;;242      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;243    
;;;244      if(((hdma->Init.Request > 0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
;;;245      {
;;;246        /* Initialize parameters for DMAMUX request generator :
;;;247           DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
;;;248        */
;;;249        DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
;;;250    
;;;251        /* Reset the DMAMUX request generator register*/
;;;252        hdma->DMAmuxRequestGen->RGCR = 0U;
;;;253    
;;;254        /* Clear the DMAMUX request generator overrun flag */
;;;255        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;256      }
;;;257      else
;;;258      {
;;;259        hdma->DMAmuxRequestGen = 0U;
;;;260        hdma->DMAmuxRequestGenStatus = 0U;
;;;261        hdma->DMAmuxRequestGenStatusMask = 0U;
;;;262      }
;;;263    #endif /* DMAMUX1 */
;;;264    
;;;265    #if !defined (DMAMUX1)
;;;266    
;;;267      /* Set request selection */
;;;268      if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
;;;269      {
;;;270        /* Write to DMA channel selection register */
;;;271        if (DMA1 == hdma->DmaBaseAddress)
;;;272        {
;;;273          /* Reset request selection for DMA1 Channelx */
;;;274          DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;275    
;;;276          /* Configure request selection for DMA1 Channelx */
;;;277          DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
;;;278        }
;;;279        else /* DMA2 */
;;;280        {
;;;281          /* Reset request selection for DMA2 Channelx */
;;;282          DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;283    
;;;284          /* Configure request selection for DMA2 Channelx */
;;;285          DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
;;;286        }
;;;287      }
;;;288    
;;;289    #endif /* STM32L431xx || STM32L432xx || STM32L433xx || STM32L442xx || STM32L443xx */
;;;290           /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L442xx || STM32L486xx */
;;;291           /* STM32L496xx || STM32L4A6xx                                              */
;;;292    
;;;293      /* Initialise the error code */
;;;294      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;295    
;;;296      /* Initialize the DMA state*/
;;;297      hdma->State  = HAL_DMA_STATE_READY;
;;;298    
;;;299      /* Allocate lock resource and initialize it */
;;;300      hdma->Lock = HAL_UNLOCKED;
;;;301    
;;;302      return HAL_OK;
;;;303    }
000022  bd70              POP      {r4-r6,pc}
                  |L8.36|
000024  4c2b              LDR      r4,|L8.212|
000026  4264              RSBS     r4,r4,#0              ;201
000028  440c              ADD      r4,r4,r1              ;201
00002a  fbb4f3f3          UDIV     r3,r4,r3              ;201
00002e  009b              LSLS     r3,r3,#2              ;201
000030  6443              STR      r3,[r0,#0x44]         ;202
000032  4b28              LDR      r3,|L8.212|
000034  3b08              SUBS     r3,r3,#8              ;202
000036  6403              STR      r3,[r0,#0x40]         ;202
                  |L8.56|
000038  2302              MOVS     r3,#2                 ;206
00003a  f8803025          STRB     r3,[r0,#0x25]         ;206
00003e  680c              LDR      r4,[r1,#0]            ;209
000040  f64773f0          MOV      r3,#0x7ff0            ;212
000044  439c              BICS     r4,r4,r3              ;212
000046  e9d03502          LDRD     r3,r5,[r0,#8]         ;212
00004a  432b              ORRS     r3,r3,r5              ;217
00004c  e9d05604          LDRD     r5,r6,[r0,#0x10]      ;217
000050  4335              ORRS     r5,r5,r6              ;217
000052  432b              ORRS     r3,r3,r5              ;217
000054  6985              LDR      r5,[r0,#0x18]         ;217
000056  432b              ORRS     r3,r3,r5              ;217
000058  69c5              LDR      r5,[r0,#0x1c]         ;217
00005a  432b              ORRS     r3,r3,r5              ;217
00005c  6a05              LDR      r5,[r0,#0x20]         ;217
00005e  432b              ORRS     r3,r3,r5              ;217
000060  4323              ORRS     r3,r3,r4              ;217
000062  600b              STR      r3,[r1,#0]            ;223
000064  6881              LDR      r1,[r0,#8]            ;268
000066  f5b14f80          CMP      r1,#0x4000            ;268
00006a  d029              BEQ      |L8.192|
00006c  6c01              LDR      r1,[r0,#0x40]         ;271
00006e  230f              MOVS     r3,#0xf               ;274
000070  4291              CMP      r1,r2                 ;271
000072  d112              BNE      |L8.154|
000074  f8521fa8          LDR      r1,[r2,#0xa8]!        ;274
000078  f8904044          LDRB     r4,[r0,#0x44]         ;274
00007c  f004041c          AND      r4,r4,#0x1c           ;274
000080  40a3              LSLS     r3,r3,r4              ;274
000082  4399              BICS     r1,r1,r3              ;274
000084  6011              STR      r1,[r2,#0]            ;274
000086  f8903044          LDRB     r3,[r0,#0x44]         ;277
00008a  6841              LDR      r1,[r0,#4]            ;277
00008c  f003031c          AND      r3,r3,#0x1c           ;277
000090  4099              LSLS     r1,r1,r3              ;277
000092  6813              LDR      r3,[r2,#0]            ;277
000094  4319              ORRS     r1,r1,r3              ;277
000096  6011              STR      r1,[r2,#0]            ;277
000098  e012              B        |L8.192|
                  |L8.154|
00009a  490e              LDR      r1,|L8.212|
00009c  31a0              ADDS     r1,r1,#0xa0           ;282
00009e  680a              LDR      r2,[r1,#0]            ;282
0000a0  f8904044          LDRB     r4,[r0,#0x44]         ;282
0000a4  f004041c          AND      r4,r4,#0x1c           ;282
0000a8  40a3              LSLS     r3,r3,r4              ;282
0000aa  439a              BICS     r2,r2,r3              ;282
0000ac  600a              STR      r2,[r1,#0]            ;282
0000ae  f8903044          LDRB     r3,[r0,#0x44]         ;285
0000b2  6842              LDR      r2,[r0,#4]            ;285
0000b4  f003031c          AND      r3,r3,#0x1c           ;285
0000b8  409a              LSLS     r2,r2,r3              ;285
0000ba  680b              LDR      r3,[r1,#0]            ;285
0000bc  431a              ORRS     r2,r2,r3              ;285
0000be  600a              STR      r2,[r1,#0]            ;285
                  |L8.192|
0000c0  2100              MOVS     r1,#0                 ;294
0000c2  63c1              STR      r1,[r0,#0x3c]         ;294
0000c4  2201              MOVS     r2,#1                 ;297
0000c6  f8802025          STRB     r2,[r0,#0x25]         ;297
0000ca  f8801024          STRB     r1,[r0,#0x24]         ;300
0000ce  4608              MOV      r0,r1                 ;302
0000d0  bd70              POP      {r4-r6,pc}
;;;304    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L8.212|
                          DCD      0x40020408
                  |L8.216|
                          DCD      0x40020000
                  |L8.220|
                          DCD      0xbffdfff8

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;684      */
;;;685    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;686    {
000004  4604              MOV      r4,r0
;;;687      uint32_t temp;
;;;688      uint32_t tickstart;
;;;689    
;;;690      if(HAL_DMA_STATE_BUSY != hdma->State)
000006  f8900025          LDRB     r0,[r0,#0x25]
00000a  4615              MOV      r5,r2                 ;686
00000c  468b              MOV      r11,r1                ;686
00000e  f04f0800          MOV      r8,#0
;;;691      {
;;;692        /* no transfer ongoing */
;;;693        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000012  f04f0a04          MOV      r10,#4
000016  2802              CMP      r0,#2                 ;690
000018  d002              BEQ      |L9.32|
00001a  f8c4a03c          STR      r10,[r4,#0x3c]
;;;694        __HAL_UNLOCK(hdma);
;;;695        return HAL_ERROR;
00001e  e04f              B        |L9.192|
                  |L9.32|
;;;696      }
;;;697    
;;;698      /* Polling mode not supported in circular mode */
;;;699      if (0U != (hdma->Instance->CCR & DMA_CCR_CIRC))
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  0680              LSLS     r0,r0,#26
000026  d503              BPL      |L9.48|
;;;700      {
;;;701        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
000028  f44f7080          MOV      r0,#0x100
00002c  63e0              STR      r0,[r4,#0x3c]
;;;702        return HAL_ERROR;
00002e  e049              B        |L9.196|
                  |L9.48|
;;;703      }
;;;704    
;;;705      /* Get the level transfer complete flag */
;;;706      if (HAL_DMA_FULL_TRANSFER == CompleteLevel)
;;;707      {
;;;708        /* Transfer Complete flag */
;;;709        temp = DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU);
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Half Transfer Complete flag */
;;;714        temp = DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU);
000030  f8940044          LDRB     r0,[r4,#0x44]
000034  f1bb0f00          CMP      r11,#0                ;706
000038  f000001c          AND      r0,r0,#0x1c
00003c  d007              BEQ      |L9.78|
00003e  fa0af600          LSL      r6,r10,r0
                  |L9.66|
;;;715      }
;;;716    
;;;717      /* Get tick */
;;;718      tickstart = HAL_GetTick();
000042  f7fffffe          BL       HAL_GetTick
000046  4607              MOV      r7,r0
000048  f04f0901          MOV      r9,#1                 ;695
;;;719    
;;;720      while(0U == (hdma->DmaBaseAddress->ISR & temp))
00004c  e01f              B        |L9.142|
                  |L9.78|
00004e  2602              MOVS     r6,#2                 ;709
000050  4086              LSLS     r6,r6,r0              ;709
000052  e7f6              B        |L9.66|
                  |L9.84|
;;;721      {
;;;722        if((0U != (hdma->DmaBaseAddress->ISR & (DMA_FLAG_TE1 << (hdma->ChannelIndex& 0x1cU)))))
000054  6801              LDR      r1,[r0,#0]
000056  f8940044          LDRB     r0,[r4,#0x44]
00005a  f000021c          AND      r2,r0,#0x1c
00005e  2008              MOVS     r0,#8
000060  4090              LSLS     r0,r0,r2
000062  4201              TST      r1,r0
000064  d00b              BEQ      |L9.126|
;;;723        {
;;;724          /* When a DMA transfer error occurs */
;;;725          /* A hardware clear of its EN bits is performed */
;;;726          /* Clear all flags */
;;;727          hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
000066  f8940044          LDRB     r0,[r4,#0x44]
00006a  6c22              LDR      r2,[r4,#0x40]
00006c  f000011c          AND      r1,r0,#0x1c
000070  fa09f101          LSL      r1,r9,r1
000074  4648              MOV      r0,r9
000076  6051              STR      r1,[r2,#4]
;;;728    
;;;729          /* Update error code */
;;;730          hdma->ErrorCode = HAL_DMA_ERROR_TE;
000078  f8c4903c          STR      r9,[r4,#0x3c]
;;;731    
;;;732          /* Change the DMA state */
;;;733          hdma->State= HAL_DMA_STATE_READY;
;;;734    
;;;735          /* Process Unlocked */
;;;736          __HAL_UNLOCK(hdma);
;;;737    
;;;738          return HAL_ERROR;
00007c  e01e              B        |L9.188|
                  |L9.126|
;;;739        }
;;;740        /* Check for the Timeout */
;;;741        if(Timeout != HAL_MAX_DELAY)
00007e  1c68              ADDS     r0,r5,#1
000080  d005              BEQ      |L9.142|
;;;742        {
;;;743          if(((HAL_GetTick() - tickstart) > Timeout) ||  (Timeout == 0U))
000082  f7fffffe          BL       HAL_GetTick
000086  1bc0              SUBS     r0,r0,r7
000088  42a8              CMP      r0,r5
00008a  d814              BHI      |L9.182|
00008c  b19d              CBZ      r5,|L9.182|
                  |L9.142|
00008e  6c20              LDR      r0,[r4,#0x40]         ;720
000090  6801              LDR      r1,[r0,#0]            ;720
000092  4231              TST      r1,r6                 ;720
000094  d0de              BEQ      |L9.84|
;;;744          {
;;;745            /* Update error code */
;;;746            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;747    
;;;748            /* Change the DMA state */
;;;749            hdma->State = HAL_DMA_STATE_READY;
;;;750    
;;;751            /* Process Unlocked */
;;;752            __HAL_UNLOCK(hdma);
;;;753    
;;;754            return HAL_ERROR;
;;;755          }
;;;756        }
;;;757      }
;;;758    
;;;759    #if defined(DMAMUX1)
;;;760      /*Check for DMAMUX Request generator (if used) overrun status */
;;;761      if(hdma->DMAmuxRequestGen != 0U)
;;;762      {
;;;763        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
;;;764        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
;;;765        {
;;;766          /* Disable the request gen overrun interrupt */
;;;767          hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
;;;768    
;;;769          /* Clear the DMAMUX request generator overrun flag */
;;;770          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;771    
;;;772          /* Update error code */
;;;773          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
;;;774        }
;;;775      }
;;;776    
;;;777      /* Check for DMAMUX Synchronization overrun */
;;;778      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
;;;779      {
;;;780        /* Clear the DMAMUX synchro overrun flag */
;;;781        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;782    
;;;783        /* Update error code */
;;;784        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
;;;785      }
;;;786    #endif /* DMAMUX1 */
;;;787    
;;;788      if(HAL_DMA_FULL_TRANSFER == CompleteLevel)
;;;789      {
;;;790        /* Clear the transfer complete flag */
;;;791        hdma->DmaBaseAddress->IFCR = (DMA_FLAG_TC1 << (hdma->ChannelIndex& 0x1cU));
;;;792    
;;;793        /* The selected Channelx EN bit is cleared (DMA is disabled and
;;;794        all transfers are complete) */
;;;795        hdma->State = HAL_DMA_STATE_READY;
;;;796      }
;;;797      else
;;;798      {
;;;799        /* Clear the half transfer complete flag */
;;;800        hdma->DmaBaseAddress->IFCR = (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU));
000096  f8940044          LDRB     r0,[r4,#0x44]
00009a  f1bb0f00          CMP      r11,#0                ;788
00009e  f000011c          AND      r1,r0,#0x1c
0000a2  d011              BEQ      |L9.200|
0000a4  fa0af001          LSL      r0,r10,r1
0000a8  6c21              LDR      r1,[r4,#0x40]
0000aa  6048              STR      r0,[r1,#4]
                  |L9.172|
;;;801      }
;;;802    
;;;803      /* Process unlocked */
;;;804      __HAL_UNLOCK(hdma);
0000ac  f8848024          STRB     r8,[r4,#0x24]
;;;805    
;;;806      return HAL_OK;
0000b0  2000              MOVS     r0,#0
                  |L9.178|
;;;807    }
0000b2  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.182|
0000b6  2020              MOVS     r0,#0x20              ;746
0000b8  63e0              STR      r0,[r4,#0x3c]         ;746
0000ba  4648              MOV      r0,r9                 ;749
                  |L9.188|
0000bc  f8840025          STRB     r0,[r4,#0x25]         ;749
                  |L9.192|
0000c0  f8848024          STRB     r8,[r4,#0x24]         ;694
                  |L9.196|
0000c4  2001              MOVS     r0,#1                 ;754
0000c6  e7f4              B        |L9.178|
                  |L9.200|
0000c8  2002              MOVS     r0,#2                 ;791
0000ca  4088              LSLS     r0,r0,r1              ;791
0000cc  6c21              LDR      r1,[r4,#0x40]         ;791
0000ce  6048              STR      r0,[r1,#4]            ;791
0000d0  f8849025          STRB     r9,[r4,#0x25]         ;795
0000d4  e7ea              B        |L9.172|
;;;808    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;908      */
;;;909    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))
000000  b510              PUSH     {r4,lr}
;;;910    {
;;;911      HAL_StatusTypeDef status = HAL_OK;
;;;912    
;;;913      /* Process locked */
;;;914      __HAL_LOCK(hdma);
000002  f8904024          LDRB     r4,[r0,#0x24]
000006  2300              MOVS     r3,#0                 ;911
000008  2c01              CMP      r4,#1
00000a  d007              BEQ      |L10.28|
00000c  2401              MOVS     r4,#1
00000e  f8804024          STRB     r4,[r0,#0x24]
;;;915    
;;;916      if(HAL_DMA_STATE_READY == hdma->State)
000012  f8904025          LDRB     r4,[r0,#0x25]
000016  2c01              CMP      r4,#1
000018  d002              BEQ      |L10.32|
00001a  e008              B        |L10.46|
                  |L10.28|
00001c  2002              MOVS     r0,#2                 ;914
;;;917      {
;;;918        switch (CallbackID)
;;;919        {
;;;920         case  HAL_DMA_XFER_CPLT_CB_ID:
;;;921               hdma->XferCpltCallback = pCallback;
;;;922               break;
;;;923    
;;;924         case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;925               hdma->XferHalfCpltCallback = pCallback;
;;;926               break;
;;;927    
;;;928         case  HAL_DMA_XFER_ERROR_CB_ID:
;;;929               hdma->XferErrorCallback = pCallback;
;;;930               break;
;;;931    
;;;932         case  HAL_DMA_XFER_ABORT_CB_ID:
;;;933               hdma->XferAbortCallback = pCallback;
;;;934               break;
;;;935    
;;;936         default:
;;;937               status = HAL_ERROR;
;;;938               break;
;;;939        }
;;;940      }
;;;941      else
;;;942      {
;;;943        status = HAL_ERROR;
;;;944      }
;;;945    
;;;946      /* Release Lock */
;;;947      __HAL_UNLOCK(hdma);
;;;948    
;;;949      return status;
;;;950    }
00001e  bd10              POP      {r4,pc}
                  |L10.32|
000020  b159              CBZ      r1,|L10.58|
000022  2901              CMP      r1,#1                 ;918
000024  d00b              BEQ      |L10.62|
000026  2902              CMP      r1,#2                 ;918
000028  d00b              BEQ      |L10.66|
00002a  2903              CMP      r1,#3                 ;918
00002c  d00b              BEQ      |L10.70|
                  |L10.46|
00002e  2301              MOVS     r3,#1                 ;937
                  |L10.48|
000030  2100              MOVS     r1,#0                 ;947
000032  f8801024          STRB     r1,[r0,#0x24]         ;947
000036  4618              MOV      r0,r3                 ;949
000038  bd10              POP      {r4,pc}
                  |L10.58|
00003a  62c2              STR      r2,[r0,#0x2c]         ;922
00003c  e7f8              B        |L10.48|
                  |L10.62|
00003e  6302              STR      r2,[r0,#0x30]         ;926
000040  e7f6              B        |L10.48|
                  |L10.66|
000042  6342              STR      r2,[r0,#0x34]         ;930
000044  e7f4              B        |L10.48|
                  |L10.70|
000046  6382              STR      r2,[r0,#0x38]         ;934
000048  e7f2              B        |L10.48|
;;;951    
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;446      */
;;;447    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b570              PUSH     {r4-r6,lr}
;;;448    {
000002  4604              MOV      r4,r0
;;;449      HAL_StatusTypeDef status = HAL_OK;
;;;450    
;;;451      /* Check the parameters */
;;;452      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;453    
;;;454      /* Process locked */
;;;455      __HAL_LOCK(hdma);
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  2500              MOVS     r5,#0                 ;449
00000a  2801              CMP      r0,#1
00000c  d00c              BEQ      |L11.40|
00000e  2001              MOVS     r0,#1
000010  f8840024          STRB     r0,[r4,#0x24]
;;;456    
;;;457      if(HAL_DMA_STATE_READY == hdma->State)
000014  f8946025          LDRB     r6,[r4,#0x25]
000018  2000              MOVS     r0,#0
00001a  2e01              CMP      r6,#1
00001c  d006              BEQ      |L11.44|
;;;458      {
;;;459        /* Change DMA peripheral state */
;;;460        hdma->State = HAL_DMA_STATE_BUSY;
;;;461        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;462    
;;;463        /* Disable the peripheral */
;;;464        __HAL_DMA_DISABLE(hdma);
;;;465    
;;;466        /* Configure the source, destination address and the data length & clear flags*/
;;;467        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;468    
;;;469        /* Enable the Peripheral */
;;;470        __HAL_DMA_ENABLE(hdma);
;;;471      }
;;;472      else
;;;473      {
;;;474        /* Process Unlocked */
;;;475        __HAL_UNLOCK(hdma);
00001e  f8840024          STRB     r0,[r4,#0x24]
;;;476        status = HAL_BUSY;
000022  2502              MOVS     r5,#2
                  |L11.36|
;;;477      }
;;;478      return status;
000024  4628              MOV      r0,r5
;;;479    }
000026  bd70              POP      {r4-r6,pc}
                  |L11.40|
000028  2002              MOVS     r0,#2                 ;455
00002a  bd70              POP      {r4-r6,pc}
                  |L11.44|
00002c  2602              MOVS     r6,#2                 ;460
00002e  f8846025          STRB     r6,[r4,#0x25]         ;460
000032  63e0              STR      r0,[r4,#0x3c]         ;461
000034  6820              LDR      r0,[r4,#0]            ;464
000036  6806              LDR      r6,[r0,#0]            ;464
000038  f0260601          BIC      r6,r6,#1              ;464
00003c  6006              STR      r6,[r0,#0]            ;464
00003e  4620              MOV      r0,r4                 ;467
000040  f7fffffe          BL       DMA_SetConfig
000044  6820              LDR      r0,[r4,#0]            ;470
000046  6801              LDR      r1,[r0,#0]            ;470
000048  f0410101          ORR      r1,r1,#1              ;470
00004c  6001              STR      r1,[r0,#0]            ;470
00004e  e7e9              B        |L11.36|
;;;480    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;489      */
;;;490    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b570              PUSH     {r4-r6,lr}
;;;491    {
000002  4604              MOV      r4,r0
;;;492      HAL_StatusTypeDef status = HAL_OK;
;;;493    
;;;494      /* Check the parameters */
;;;495      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;496    
;;;497      /* Process locked */
;;;498      __HAL_LOCK(hdma);
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  2500              MOVS     r5,#0                 ;492
00000a  2801              CMP      r0,#1
00000c  d00c              BEQ      |L12.40|
00000e  2001              MOVS     r0,#1
000010  f8840024          STRB     r0,[r4,#0x24]
;;;499    
;;;500      if(HAL_DMA_STATE_READY == hdma->State)
000014  f8946025          LDRB     r6,[r4,#0x25]
000018  2000              MOVS     r0,#0
00001a  2e01              CMP      r6,#1
00001c  d006              BEQ      |L12.44|
;;;501      {
;;;502        /* Change DMA peripheral state */
;;;503        hdma->State = HAL_DMA_STATE_BUSY;
;;;504        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;505    
;;;506        /* Disable the peripheral */
;;;507        __HAL_DMA_DISABLE(hdma);
;;;508    
;;;509        /* Configure the source, destination address and the data length & clear flags*/
;;;510        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;511    
;;;512        /* Enable the transfer complete interrupt */
;;;513        /* Enable the transfer Error interrupt */
;;;514        if(NULL != hdma->XferHalfCpltCallback )
;;;515        {
;;;516          /* Enable the Half transfer complete interrupt as well */
;;;517          __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
;;;518        }
;;;519        else
;;;520        {
;;;521          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
;;;522          __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
;;;523        }
;;;524    
;;;525    #ifdef DMAMUX1
;;;526    
;;;527        /* Check if DMAMUX Synchronization is enabled*/
;;;528        if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
;;;529        {
;;;530          /* Enable DMAMUX sync overrun IT*/
;;;531          hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
;;;532        }
;;;533    
;;;534        if(hdma->DMAmuxRequestGen != 0U)
;;;535        {
;;;536          /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
;;;537          /* enable the request gen overrun IT*/
;;;538          hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
;;;539        }
;;;540    
;;;541    #endif /* DMAMUX1 */
;;;542    
;;;543        /* Enable the Peripheral */
;;;544        __HAL_DMA_ENABLE(hdma);
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Process Unlocked */
;;;549        __HAL_UNLOCK(hdma);
00001e  f8840024          STRB     r0,[r4,#0x24]
;;;550    
;;;551        /* Remain BUSY */
;;;552        status = HAL_BUSY;
000022  2502              MOVS     r5,#2
                  |L12.36|
;;;553      }
;;;554      return status;
000024  4628              MOV      r0,r5
;;;555    }
000026  bd70              POP      {r4-r6,pc}
                  |L12.40|
000028  2002              MOVS     r0,#2                 ;498
00002a  bd70              POP      {r4-r6,pc}
                  |L12.44|
00002c  2602              MOVS     r6,#2                 ;503
00002e  f8846025          STRB     r6,[r4,#0x25]         ;503
000032  63e0              STR      r0,[r4,#0x3c]         ;504
000034  6820              LDR      r0,[r4,#0]            ;507
000036  6806              LDR      r6,[r0,#0]            ;507
000038  f0260601          BIC      r6,r6,#1              ;507
00003c  6006              STR      r6,[r0,#0]            ;507
00003e  4620              MOV      r0,r4                 ;510
000040  f7fffffe          BL       DMA_SetConfig
000044  6b20              LDR      r0,[r4,#0x30]         ;514
000046  2800              CMP      r0,#0                 ;514
000048  6820              LDR      r0,[r4,#0]            ;521
00004a  6801              LDR      r1,[r0,#0]            ;521
00004c  d002              BEQ      |L12.84|
00004e  f041010e          ORR      r1,r1,#0xe            ;517
000052  e006              B        |L12.98|
                  |L12.84|
000054  f0210104          BIC      r1,r1,#4              ;521
000058  6001              STR      r1,[r0,#0]            ;521
00005a  6820              LDR      r0,[r4,#0]            ;522
00005c  6801              LDR      r1,[r0,#0]            ;522
00005e  f041010a          ORR      r1,r1,#0xa            ;522
                  |L12.98|
000062  6001              STR      r1,[r0,#0]            ;522
000064  6820              LDR      r0,[r4,#0]            ;544
000066  6801              LDR      r1,[r0,#0]            ;544
000068  f0410101          ORR      r1,r1,#1              ;544
00006c  6001              STR      r1,[r0,#0]            ;544
00006e  e7d9              B        |L12.36|
;;;556    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;959      */
;;;960    HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  b510              PUSH     {r4,lr}
;;;961    {
;;;962      HAL_StatusTypeDef status = HAL_OK;
;;;963    
;;;964        /* Process locked */
;;;965      __HAL_LOCK(hdma);
000002  f8903024          LDRB     r3,[r0,#0x24]
000006  2200              MOVS     r2,#0                 ;962
000008  2b01              CMP      r3,#1
00000a  d008              BEQ      |L13.30|
00000c  2301              MOVS     r3,#1
00000e  f8803024          STRB     r3,[r0,#0x24]
;;;966    
;;;967      if(HAL_DMA_STATE_READY == hdma->State)
000012  f8904025          LDRB     r4,[r0,#0x25]
000016  2300              MOVS     r3,#0
000018  2c01              CMP      r4,#1
00001a  d002              BEQ      |L13.34|
00001c  e014              B        |L13.72|
                  |L13.30|
00001e  2002              MOVS     r0,#2                 ;965
;;;968      {
;;;969        switch (CallbackID)
;;;970        {
;;;971         case  HAL_DMA_XFER_CPLT_CB_ID:
;;;972               hdma->XferCpltCallback = NULL;
;;;973               break;
;;;974    
;;;975         case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;976               hdma->XferHalfCpltCallback = NULL;
;;;977               break;
;;;978    
;;;979         case  HAL_DMA_XFER_ERROR_CB_ID:
;;;980               hdma->XferErrorCallback = NULL;
;;;981               break;
;;;982    
;;;983         case  HAL_DMA_XFER_ABORT_CB_ID:
;;;984               hdma->XferAbortCallback = NULL;
;;;985               break;
;;;986    
;;;987        case   HAL_DMA_XFER_ALL_CB_ID:
;;;988               hdma->XferCpltCallback = NULL;
;;;989               hdma->XferHalfCpltCallback = NULL;
;;;990               hdma->XferErrorCallback = NULL;
;;;991               hdma->XferAbortCallback = NULL;
;;;992               break;
;;;993    
;;;994        default:
;;;995               status = HAL_ERROR;
;;;996               break;
;;;997        }
;;;998      }
;;;999      else
;;;1000     {
;;;1001       status = HAL_ERROR;
;;;1002     }
;;;1003   
;;;1004     /* Release Lock */
;;;1005     __HAL_UNLOCK(hdma);
;;;1006   
;;;1007     return status;
;;;1008   }
000020  bd10              POP      {r4,pc}
                  |L13.34|
000022  2905              CMP      r1,#5                 ;969
000024  d210              BCS      |L13.72|
000026  e8dff001          TBB      [pc,r1]               ;969
00002a  0305              DCB      0x03,0x05
00002c  07090b00          DCB      0x07,0x09,0x0b,0x00
000030  62c3              STR      r3,[r0,#0x2c]         ;973
000032  e00a              B        |L13.74|
000034  6303              STR      r3,[r0,#0x30]         ;977
000036  e008              B        |L13.74|
000038  6343              STR      r3,[r0,#0x34]         ;981
00003a  e006              B        |L13.74|
                  |L13.60|
00003c  6383              STR      r3,[r0,#0x38]         ;985
00003e  e004              B        |L13.74|
000040  62c3              STR      r3,[r0,#0x2c]         ;989
000042  6303              STR      r3,[r0,#0x30]         ;990
000044  6343              STR      r3,[r0,#0x34]         ;992
000046  e7f9              B        |L13.60|
                  |L13.72|
000048  2201              MOVS     r2,#1                 ;995
                  |L13.74|
00004a  f8803024          STRB     r3,[r0,#0x24]         ;1005
00004e  4610              MOV      r0,r2                 ;1007
000050  bd10              POP      {r4,pc}
;;;1009   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32l4xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
