; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32l4xx_hal_cortex.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32l4xx_hal_cortex.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\stm32l4xx_hal_cortex.crf ..\HALLIB\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;481      */
;;;482    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  4a13              LDR      r2,|L1.80|
;;;483    {
;;;484      /* Check the parameters */
;;;485      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;486      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;487    
;;;488      /* Set the Region number */
;;;489      MPU->RNR = MPU_Init->Number;
000002  7841              LDRB     r1,[r0,#1]
000004  6011              STR      r1,[r2,#0]
;;;490    
;;;491      if ((MPU_Init->Enable) != RESET)
000006  7803              LDRB     r3,[r0,#0]
;;;492      {
;;;493        /* Check the parameters */
;;;494        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;495        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;496        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;497        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;498        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;499        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;500        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;501        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;502    
;;;503        MPU->RBAR = MPU_Init->BaseAddress;
000008  1d11              ADDS     r1,r2,#4
;;;504        MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
00000a  1d0a              ADDS     r2,r1,#4
00000c  b1e3              CBZ      r3,|L1.72|
00000e  6843              LDR      r3,[r0,#4]            ;503
000010  600b              STR      r3,[r1,#0]            ;503
000012  7b01              LDRB     r1,[r0,#0xc]
000014  7ac3              LDRB     r3,[r0,#0xb]
000016  0709              LSLS     r1,r1,#28
000018  ea416103          ORR      r1,r1,r3,LSL #24
00001c  7a83              LDRB     r3,[r0,#0xa]
00001e  ea4141c3          ORR      r1,r1,r3,LSL #19
000022  7b43              LDRB     r3,[r0,#0xd]
000024  ea414183          ORR      r1,r1,r3,LSL #18
000028  7b83              LDRB     r3,[r0,#0xe]
00002a  ea414143          ORR      r1,r1,r3,LSL #17
00002e  7bc3              LDRB     r3,[r0,#0xf]
000030  ea414103          ORR      r1,r1,r3,LSL #16
000034  7a43              LDRB     r3,[r0,#9]
000036  ea412103          ORR      r1,r1,r3,LSL #8
00003a  7a03              LDRB     r3,[r0,#8]
00003c  7800              LDRB     r0,[r0,#0]
00003e  ea410143          ORR      r1,r1,r3,LSL #1
000042  4301              ORRS     r1,r1,r0
000044  6011              STR      r1,[r2,#0]
;;;505                    ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
;;;506                    ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
;;;507                    ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
;;;508                    ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
;;;509                    ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
;;;510                    ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
;;;511                    ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
;;;512                    ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
;;;513      }
;;;514      else
;;;515      {
;;;516        MPU->RBAR = 0x00;
;;;517        MPU->RASR = 0x00;
;;;518      }
;;;519    }
000046  4770              BX       lr
                  |L1.72|
000048  2000              MOVS     r0,#0                 ;516
00004a  6008              STR      r0,[r1,#0]            ;516
00004c  6010              STR      r0,[r2,#0]            ;517
00004e  4770              BX       lr
;;;520    #endif /* __MPU_PRESENT */
                          ENDP

                  |L1.80|
                          DCD      0xe000ed98

                          AREA ||i.HAL_MPU_Disable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Disable PROC
;;;439      */
;;;440    void HAL_MPU_Disable(void)
000000  f3bf8f5f          DMB      
;;;441    {
;;;442      /* Make sure outstanding transfers are done */
;;;443      __DMB();
;;;444    
;;;445      /* Disable fault exceptions */
;;;446      SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
000004  4804              LDR      r0,|L2.24|
000006  6801              LDR      r1,[r0,#0]
000008  f4213180          BIC      r1,r1,#0x10000
00000c  6001              STR      r1,[r0,#0]
;;;447      
;;;448      /* Disable the MPU and clear the control register*/
;;;449      MPU->CTRL = 0U;
00000e  4902              LDR      r1,|L2.24|
000010  2000              MOVS     r0,#0
000012  3170              ADDS     r1,r1,#0x70
000014  6008              STR      r0,[r1,#0]
;;;450    }
000016  4770              BX       lr
;;;451    
                          ENDP

                  |L2.24|
                          DCD      0xe000ed24

                          AREA ||i.HAL_MPU_Enable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Enable PROC
;;;462      */
;;;463    void HAL_MPU_Enable(uint32_t MPU_Control)
000000  4907              LDR      r1,|L3.32|
;;;464    {
;;;465      /* Enable the MPU */
;;;466      MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
000002  f0400001          ORR      r0,r0,#1
000006  6008              STR      r0,[r1,#0]
;;;467      
;;;468      /* Enable fault exceptions */
;;;469      SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
000008  4805              LDR      r0,|L3.32|
00000a  3870              SUBS     r0,r0,#0x70
00000c  6801              LDR      r1,[r0,#0]
00000e  f4413180          ORR      r1,r1,#0x10000
000012  6001              STR      r1,[r0,#0]
;;;470      
;;;471      /* Ensure MPU settings take effects */
;;;472      __DSB();
000014  f3bf8f4f          DSB      
;;;473      __ISB();
000018  f3bf8f6f          ISB      
;;;474    }
00001c  4770              BX       lr
;;;475    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0xe000ed94

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_ClearPendingIRQ PROC
;;;369      */
;;;370    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01280          STR      r1,[r0,#0x280]
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;374    
;;;375      /* Clear pending interrupt */
;;;376      NVIC_ClearPendingIRQ(IRQn);
;;;377    }
000014  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_DisableIRQ PROC
;;;239      */
;;;240    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01180          STR      r1,[r0,#0x180]
;;;241    {
;;;242      /* Check the parameters */
;;;243      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;244      
;;;245      /* Disable interrupt */
;;;246      NVIC_DisableIRQ(IRQn);
;;;247    }
000014  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;223      */
;;;224    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;225    {
;;;226      /* Check the parameters */
;;;227      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;228      
;;;229      /* Enable interrupt */
;;;230      NVIC_EnableIRQ(IRQn);
;;;231    }
000014  4770              BX       lr
;;;232    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetActive PROC
;;;386      */
;;;387    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
000002  0089              LSLS     r1,r1,#2
000004  f10121e0          ADD      r1,r1,#0xe000e000
000008  f8d11300          LDR      r1,[r1,#0x300]
00000c  f000021f          AND      r2,r0,#0x1f
000010  2001              MOVS     r0,#1
000012  4090              LSLS     r0,r0,r2
000014  4201              TST      r1,r0
;;;388    {
000016  d001              BEQ      |L7.28|
000018  2001              MOVS     r0,#1
;;;389      /* Return 1 if active else 0 */
;;;390      return NVIC_GetActive(IRQn);
;;;391    }
00001a  4770              BX       lr
                  |L7.28|
00001c  2000              MOVS     r0,#0
00001e  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPendingIRQ PROC
;;;353      */
;;;354    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
000002  0089              LSLS     r1,r1,#2
000004  f10121e0          ADD      r1,r1,#0xe000e000
000008  f8d11200          LDR      r1,[r1,#0x200]
00000c  f000021f          AND      r2,r0,#0x1f
000010  2001              MOVS     r0,#1
000012  4090              LSLS     r0,r0,r2
000014  4201              TST      r1,r0
;;;355    {
000016  d001              BEQ      |L8.28|
000018  2001              MOVS     r0,#1
;;;356      /* Check the parameters */
;;;357      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;358    
;;;359      /* Return 1 if pending else 0 */
;;;360      return NVIC_GetPendingIRQ(IRQn);
;;;361    }
00001a  4770              BX       lr
                  |L8.28|
00001c  2000              MOVS     r0,#0
00001e  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriority PROC
;;;320      */
;;;321    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  b5f0              PUSH     {r4-r7,lr}
000002  2800              CMP      r0,#0
;;;322    {
000004  da06              BGE      |L9.20|
000006  f000000f          AND      r0,r0,#0xf
00000a  f10020e0          ADD      r0,r0,#0xe000e000
00000e  f8900d14          LDRB     r0,[r0,#0xd14]
000012  e003              B        |L9.28|
                  |L9.20|
000014  f10020e0          ADD      r0,r0,#0xe000e000
000018  f8900400          LDRB     r0,[r0,#0x400]
                  |L9.28|
00001c  0904              LSRS     r4,r0,#4
00001e  f0010007          AND      r0,r1,#7
000022  f1c00107          RSB      r1,r0,#7
000026  2904              CMP      r1,#4
000028  d900              BLS      |L9.44|
00002a  2104              MOVS     r1,#4
                  |L9.44|
00002c  1d05              ADDS     r5,r0,#4
00002e  2d07              CMP      r5,#7
000030  d201              BCS      |L9.54|
000032  2000              MOVS     r0,#0
000034  e000              B        |L9.56|
                  |L9.54|
000036  1ec0              SUBS     r0,r0,#3
                  |L9.56|
000038  2701              MOVS     r7,#1
00003a  fa24f600          LSR      r6,r4,r0
00003e  fa07f501          LSL      r5,r7,r1
000042  1e6d              SUBS     r5,r5,#1
000044  402e              ANDS     r6,r6,r5
000046  fa07f500          LSL      r5,r7,r0
00004a  1e6d              SUBS     r5,r5,#1
00004c  4025              ANDS     r5,r5,r4
00004e  6016              STR      r6,[r2,#0]
000050  601d              STR      r5,[r3,#0]
;;;323      /* Check the parameters */
;;;324      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;325     /* Get priority for Cortex-M system or device specific interrupts */
;;;326      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
;;;327    }
000052  bdf0              POP      {r4-r7,pc}
;;;328    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriorityGrouping PROC
;;;293      */
;;;294    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L10.12|
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;295    {
;;;296      /* Get the PRIGROUP[10:8] field value */
;;;297      return NVIC_GetPriorityGrouping();
;;;298    }
000008  4770              BX       lr
;;;299    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPendingIRQ PROC
;;;335      */
;;;336    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01200          STR      r1,[r0,#0x200]
;;;337    {
;;;338      /* Check the parameters */
;;;339      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;340    
;;;341      /* Set interrupt pending */
;;;342      NVIC_SetPendingIRQ(IRQn);
;;;343    }
000014  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriority PROC
;;;201      */
;;;202    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  b4f0              PUSH     {r4-r7}
000002  4b0e              LDR      r3,|L12.60|
000004  681b              LDR      r3,[r3,#0]
000006  f3c32302          UBFX     r3,r3,#8,#3
00000a  f1c30407          RSB      r4,r3,#7
00000e  2c04              CMP      r4,#4
;;;203    {
000010  d900              BLS      |L12.20|
000012  2404              MOVS     r4,#4
                  |L12.20|
000014  1d1d              ADDS     r5,r3,#4
000016  2d07              CMP      r5,#7
000018  d201              BCS      |L12.30|
00001a  2300              MOVS     r3,#0
00001c  e000              B        |L12.32|
                  |L12.30|
00001e  1edb              SUBS     r3,r3,#3
                  |L12.32|
000020  2601              MOVS     r6,#1
000022  fa06f504          LSL      r5,r6,r4
000026  1e6d              SUBS     r5,r5,#1
000028  400d              ANDS     r5,r5,r1
00002a  409d              LSLS     r5,r5,r3
00002c  409e              LSLS     r6,r6,r3
00002e  1e76              SUBS     r6,r6,#1
000030  4016              ANDS     r6,r6,r2
000032  ea450106          ORR      r1,r5,r6
;;;204      uint32_t prioritygroup = 0x00;
;;;205    
;;;206      /* Check the parameters */
;;;207      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;208      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;209    
;;;210      prioritygroup = NVIC_GetPriorityGrouping();
;;;211    
;;;212      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
000036  bcf0              POP      {r4-r7}
000038  f7ffbffe          B.W      NVIC_SetPriority
;;;213    }
;;;214    
                          ENDP

                  |L12.60|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;179      */
;;;180    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  4a06              LDR      r2,|L13.28|
000002  f0000107          AND      r1,r0,#7
000006  6810              LDR      r0,[r2,#0]
000008  f64f03ff          MOV      r3,#0xf8ff
00000c  4018              ANDS     r0,r0,r3
00000e  ea402001          ORR      r0,r0,r1,LSL #8
000012  4903              LDR      r1,|L13.32|
000014  4308              ORRS     r0,r0,r1
000016  6010              STR      r0,[r2,#0]
;;;181    {
;;;182      /* Check the parameters */
;;;183      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;184    
;;;185      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;186      NVIC_SetPriorityGrouping(PriorityGroup);
;;;187    }
000018  4770              BX       lr
;;;188    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0xe000ed0c
                  |L13.32|
                          DCD      0x05fa0000

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;252      */
;;;253    void HAL_NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
000004  4805              LDR      r0,|L14.28|
000006  6801              LDR      r1,[r0,#0]
000008  4a05              LDR      r2,|L14.32|
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
000012  f3bf8f4f          DSB      
                  |L14.22|
000016  bf00              NOP      
000018  e7fd              B        |L14.22|
;;;254    {
;;;255      /* System Reset */
;;;256      NVIC_SystemReset();
;;;257    }
;;;258    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0xe000ed0c
                  |L14.32|
                          DCD      0x05fa0004

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;400      */
;;;401    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;402    {
;;;403      /* Check the parameters */
;;;404      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;405      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
000004  2804              CMP      r0,#4
;;;406      {
;;;407        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
;;;408      }
;;;409      else
;;;410      {
;;;411        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000006  6908              LDR      r0,[r1,#0x10]
000008  d003              BEQ      |L15.18|
00000a  f0200004          BIC      r0,r0,#4
                  |L15.14|
00000e  6108              STR      r0,[r1,#0x10]         ;407
;;;412      }
;;;413    }
000010  4770              BX       lr
                  |L15.18|
000012  f0400004          ORR      r0,r0,#4              ;407
000016  e7fa              B        |L15.14|
;;;414    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;427      */
;;;428    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;429    {
;;;430      /* NOTE : This function should not be modified, when the callback is needed,
;;;431                the HAL_SYSTICK_Callback could be implemented in the user file
;;;432       */
;;;433    }
;;;434    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Config PROC
;;;265      */
;;;266    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  b510              PUSH     {r4,lr}
;;;267    {
000002  1e40              SUBS     r0,r0,#1
000004  f1b07f80          CMP      r0,#0x1000000
000008  d301              BCC      |L17.14|
00000a  2001              MOVS     r0,#1
;;;268       return SysTick_Config(TicksNumb);
;;;269    }
00000c  bd10              POP      {r4,pc}
                  |L17.14|
00000e  f04f24e0          MOV      r4,#0xe000e000
000012  6160              STR      r0,[r4,#0x14]
000014  210f              MOVS     r1,#0xf
000016  1760              ASRS     r0,r4,#29
000018  f7fffffe          BL       NVIC_SetPriority
00001c  2000              MOVS     r0,#0
00001e  61a0              STR      r0,[r4,#0x18]
000020  2007              MOVS     r0,#7
000022  6120              STR      r0,[r4,#0x10]
000024  2000              MOVS     r0,#0
000026  bd10              POP      {r4,pc}
;;;270    /**
                          ENDP


                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;418      */
;;;419    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;420    {
;;;421      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;422    }
000006  bd10              POP      {r4,pc}
;;;423    
                          ENDP


                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1700
000006  da06              BGE      |L19.22|
000008  f000000f          AND      r0,r0,#0xf
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8801d14          STRB     r1,[r0,#0xd14]
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1707     }
;;;1708   }
000014  4770              BX       lr
                  |L19.22|
000016  f10020e0          ADD      r0,r0,#0xe000e000
00001a  f8801400          STRB     r1,[r0,#0x400]        ;1706
00001e  4770              BX       lr
;;;1709   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REVSH|
#line 402
|__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____RRX|
#line 587
|__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
