; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\delay.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\delay.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\HALLIB\STM32L4xx_HAL_Driver\Inc -I..\HALLIB\STM32L4xx_HAL_Driver\Inc\Legacy -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\App\src -I.\RTE\_ATK_LED -IF:\KEIL5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IF:\KEIL5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32L475xx -DUSE_HAL_DRIVER -DSTM32L475xx --omf_browse=..\obj\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;142     */
;;;143    void delay_init(u8 SYSCLK)
000000  b510              PUSH     {r4,lr}
;;;144    {
000002  4604              MOV      r4,r0
;;;145    #if SYSTEM_SUPPORT_OS 						//如果需要支持OS.
;;;146        u32 reload;
;;;147    #endif
;;;148        HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);//SysTick频率为HCLK
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       HAL_SYSTICK_CLKSourceConfig
;;;149        fac_us = SYSCLK;						//不论是否使用OS,fac_us都需要使用
00000a  4801              LDR      r0,|L1.16|
00000c  6004              STR      r4,[r0,#0]  ; fac_us
;;;150    
;;;151    #if SYSTEM_SUPPORT_OS 						//如果需要支持OS.
;;;152        reload = SYSCLK;					  //每秒钟的计数次数 单位为K
;;;153        reload *= 1000000 / delay_ostickspersec;	//根据delay_ostickspersec设定溢出时间
;;;154        //reload为24位寄存器,最大值:16777216,在80M下，约209.7ms左右
;;;155        fac_ms = 1000 / delay_ostickspersec;		//代表OS可以延时的最少单位
;;;156        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk; //开启SYSTICK中断
;;;157        SysTick->LOAD = reload; 					//每1/OS_TICKS_PER_SEC秒中断一次
;;;158        SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk; //开启SYSTICK
;;;159    #else
;;;160    #endif
;;;161    }
00000e  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L1.16|
                          DCD      ||.data||

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=1

                  delay_ms PROC
;;;203     */
;;;204    void delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4605              MOV      r5,r0
;;;206        u32 i;
;;;207    
;;;208        for(i = 0; i < nms; i++) delay_us(1000);
000004  2400              MOVS     r4,#0
000006  f44f767a          MOV      r6,#0x3e8
00000a  e003              B        |L2.20|
                  |L2.12|
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       delay_us
000012  1c64              ADDS     r4,r4,#1
                  |L2.20|
000014  42ac              CMP      r4,r5
000016  d3f9              BCC      |L2.12|
;;;209    }
000018  bd70              POP      {r4-r6,pc}
;;;210    
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;172     */
;;;173    void delay_us(u32 nus)
000000  b570              PUSH     {r4-r6,lr}
;;;174    {
;;;175        u32 ticks;
;;;176        u32 told, tnow, tcnt = 0;
;;;177        u32 reload = SysTick->LOAD;				//LOAD的值
000002  f04f25e0          MOV      r5,#0xe000e000
000006  2100              MOVS     r1,#0                 ;176
000008  696c              LDR      r4,[r5,#0x14]
;;;178        ticks = nus * fac_us; 						//需要的节拍数
00000a  4a09              LDR      r2,|L3.48|
;;;179        told = SysTick->VAL;        				//刚进入时的计数器值
00000c  69ab              LDR      r3,[r5,#0x18]
00000e  6812              LDR      r2,[r2,#0]            ;178  ; fac_us
000010  4350              MULS     r0,r2,r0              ;178
                  |L3.18|
;;;180    
;;;181        while(1)
;;;182        {
;;;183            tnow = SysTick->VAL;
000012  69aa              LDR      r2,[r5,#0x18]
;;;184    
;;;185            if(tnow != told)
000014  429a              CMP      r2,r3
000016  d0fc              BEQ      |L3.18|
;;;186            {
;;;187                if(tnow < told)tcnt += told - tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
000018  d202              BCS      |L3.32|
00001a  eba30302          SUB      r3,r3,r2
00001e  e002              B        |L3.38|
                  |L3.32|
;;;188                else tcnt += reload - tnow + told;
000020  eba40602          SUB      r6,r4,r2
000024  4433              ADD      r3,r3,r6
                  |L3.38|
000026  4419              ADD      r1,r1,r3
;;;189    			
;;;190                told = tnow;
000028  4613              MOV      r3,r2
;;;191                if(tcnt >= ticks)break;			//时间超过/等于要延迟的时间,则退出.
00002a  4281              CMP      r1,r0
00002c  d3f1              BCC      |L3.18|
;;;192            }
;;;193        }
;;;194    }
00002e  bd70              POP      {r4-r6,pc}
;;;195    
                          ENDP

                  |L3.48|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  fac_us
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\delay\\delay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_f6a9c549____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___7_delay_c_f6a9c549____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_f6a9c549____REVSH|
#line 402
|__asm___7_delay_c_f6a9c549____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_f6a9c549____RRX|
#line 587
|__asm___7_delay_c_f6a9c549____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
